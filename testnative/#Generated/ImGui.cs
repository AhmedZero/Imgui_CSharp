// <auto-generated>
// This file was automatically generated by Biohazrd and should not be modified by hand!
// </auto-generated>
#nullable enable
using Mochi.DearImGui.Infrastructure;
using Mochi.DearImGui.Internal;
using System;
using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Mochi.DearImGui
{
    public unsafe static partial class ImGui
    {
        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z", ExactSpelling = true)]
        public static extern ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = null);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DestroyContext@ImGui@@YAXPEAUImGuiContext@@@Z", ExactSpelling = true)]
        public static extern void DestroyContext(ImGuiContext* ctx = null);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetCurrentContext@ImGui@@YAPEAUImGuiContext@@XZ", ExactSpelling = true)]
        public static extern ImGuiContext* GetCurrentContext();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetCurrentContext@ImGui@@YAXPEAUImGuiContext@@@Z", ExactSpelling = true)]
        public static extern void SetCurrentContext(ImGuiContext* ctx);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetIO@ImGui@@YAAEAUImGuiIO@@XZ", ExactSpelling = true)]
        public static extern ImGuiIO* GetIO();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ", ExactSpelling = true)]
        public static extern ImGuiStyle* GetStyle();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?NewFrame@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void NewFrame();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndFrame@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndFrame();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Render@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void Render();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetDrawData@ImGui@@YAPEAUImDrawData@@XZ", ExactSpelling = true)]
        public static extern ImDrawData* GetDrawData();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ShowDemoWindow@ImGui@@YAXPEA_N@Z", ExactSpelling = true)]
        public static extern void ShowDemoWindow(bool* p_open = null);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ShowMetricsWindow@ImGui@@YAXPEA_N@Z", ExactSpelling = true)]
        public static extern void ShowMetricsWindow(bool* p_open = null);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ShowStackToolWindow@ImGui@@YAXPEA_N@Z", ExactSpelling = true)]
        public static extern void ShowStackToolWindow(bool* p_open = null);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ShowAboutWindow@ImGui@@YAXPEA_N@Z", ExactSpelling = true)]
        public static extern void ShowAboutWindow(bool* p_open = null);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ShowStyleEditor@ImGui@@YAXPEAUImGuiStyle@@@Z", ExactSpelling = true)]
        public static extern void ShowStyleEditor(ImGuiStyle* @ref = null);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ShowStyleSelector@ImGui@@YA_NPEBD@Z", ExactSpelling = true)]
        private static extern byte ShowStyleSelector_PInvoke(byte* label);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ShowStyleSelector(byte* label)
        {
            byte __result;

            __result = ShowStyleSelector_PInvoke(label);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ShowStyleSelector(DearImGuiInterpolatedStringHandler label)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = ShowStyleSelector_PInvoke(__labelP); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ShowFontSelector@ImGui@@YAXPEBD@Z", ExactSpelling = true)]
        public static extern void ShowFontSelector(byte* label);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ShowFontSelector(DearImGuiInterpolatedStringHandler label)
        {
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { ShowFontSelector(__labelP); }

            label.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ShowUserGuide@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void ShowUserGuide();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetVersion@ImGui@@YAPEBDXZ", ExactSpelling = true)]
        public static extern byte* GetVersion();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z", ExactSpelling = true)]
        public static extern void StyleColorsDark(ImGuiStyle* dst = null);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?StyleColorsLight@ImGui@@YAXPEAUImGuiStyle@@@Z", ExactSpelling = true)]
        public static extern void StyleColorsLight(ImGuiStyle* dst = null);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?StyleColorsClassic@ImGui@@YAXPEAUImGuiStyle@@@Z", ExactSpelling = true)]
        public static extern void StyleColorsClassic(ImGuiStyle* dst = null);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Begin@ImGui@@YA_NPEBDPEA_NH@Z", ExactSpelling = true)]
        private static extern byte Begin_PInvoke(byte* name, bool* p_open, ImGuiWindowFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Begin(byte* name, bool* p_open = null, ImGuiWindowFlags flags = ImGuiWindowFlags.None)
        {
            byte __result;

            __result = Begin_PInvoke(name, p_open, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Begin(DearImGuiInterpolatedStringHandler name, bool* p_open = null, ImGuiWindowFlags flags = ImGuiWindowFlags.None)
        {
            byte __result;

            fixed (byte* __nameP = name.NullTerminateAndGetString())
            { __result = Begin_PInvoke(__nameP, p_open, flags); }

            name.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?End@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void End();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginChild@ImGui@@YA_NPEBDAEBUImVec2@@_NH@Z", ExactSpelling = true)]
        private static extern byte BeginChild_PInvoke(byte* str_id, Vector2* size, byte border, ImGuiWindowFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginChild(byte* str_id, in Vector2 size, bool border = false, ImGuiWindowFlags flags = ImGuiWindowFlags.None)
        {
            byte __result;

            fixed (Vector2* __sizeP = &size)
            { __result = BeginChild_PInvoke(str_id, __sizeP, Unsafe.As<bool, byte>(ref border), flags); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginChild(DearImGuiInterpolatedStringHandler str_id, in Vector2 size, bool border = false, ImGuiWindowFlags flags = ImGuiWindowFlags.None)
        {
            byte __result;

            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            fixed (Vector2* __sizeP = &size)
            { __result = BeginChild_PInvoke(__str_idP, __sizeP, Unsafe.As<bool, byte>(ref border), flags); }

            str_id.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginChild@ImGui@@YA_NIAEBUImVec2@@_NH@Z", ExactSpelling = true)]
        private static extern byte BeginChild_PInvoke(uint id, Vector2* size, byte border, ImGuiWindowFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginChild(uint id, in Vector2 size, bool border = false, ImGuiWindowFlags flags = ImGuiWindowFlags.None)
        {
            byte __result;

            fixed (Vector2* __sizeP = &size)
            { __result = BeginChild_PInvoke(id, __sizeP, Unsafe.As<bool, byte>(ref border), flags); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndChild@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndChild();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsWindowAppearing@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte IsWindowAppearing_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsWindowAppearing()
        {
            byte __result;

            __result = IsWindowAppearing_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsWindowCollapsed@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte IsWindowCollapsed_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsWindowCollapsed()
        {
            byte __result;

            __result = IsWindowCollapsed_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsWindowFocused@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte IsWindowFocused_PInvoke(ImGuiFocusedFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsWindowFocused(ImGuiFocusedFlags flags = ImGuiFocusedFlags.None)
        {
            byte __result;

            __result = IsWindowFocused_PInvoke(flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsWindowHovered@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte IsWindowHovered_PInvoke(ImGuiHoveredFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsWindowHovered(ImGuiHoveredFlags flags = ImGuiHoveredFlags.None)
        {
            byte __result;

            __result = IsWindowHovered_PInvoke(flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetWindowDrawList@ImGui@@YAPEAUImDrawList@@XZ", ExactSpelling = true)]
        public static extern ImDrawList* GetWindowDrawList();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetWindowDpiScale@ImGui@@YAMXZ", ExactSpelling = true)]
        public static extern float GetWindowDpiScale();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetWindowPos@ImGui@@YA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetWindowPos_PInvoke(Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetWindowPos()
        {
            Vector2 __returnBuffer;

            GetWindowPos_PInvoke(&__returnBuffer);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetWindowSize@ImGui@@YA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetWindowSize_PInvoke(Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetWindowSize()
        {
            Vector2 __returnBuffer;

            GetWindowSize_PInvoke(&__returnBuffer);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetWindowWidth@ImGui@@YAMXZ", ExactSpelling = true)]
        public static extern float GetWindowWidth();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetWindowHeight@ImGui@@YAMXZ", ExactSpelling = true)]
        public static extern float GetWindowHeight();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetWindowViewport@ImGui@@YAPEAUImGuiViewport@@XZ", ExactSpelling = true)]
        public static extern ImGuiViewport* GetWindowViewport();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z", ExactSpelling = true)]
        private static extern void SetNextWindowPos_PInvoke(Vector2* pos, ImGuiCond cond, Vector2* pivot);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetNextWindowPos(in Vector2 pos, ImGuiCond cond, in Vector2 pivot)
        {
            fixed (Vector2* __posP = &pos)
            fixed (Vector2* __pivotP = &pivot)
            { SetNextWindowPos_PInvoke(__posP, cond, __pivotP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetNextWindowSize@ImGui@@YAXAEBUImVec2@@H@Z", ExactSpelling = true)]
        private static extern void SetNextWindowSize_PInvoke(Vector2* size, ImGuiCond cond);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetNextWindowSize(in Vector2 size, ImGuiCond cond = ImGuiCond.None)
        {
            fixed (Vector2* __sizeP = &size)
            { SetNextWindowSize_PInvoke(__sizeP, cond); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetNextWindowSizeConstraints@ImGui@@YAXAEBUImVec2@@0P6AXPEAUImGuiSizeCallbackData@@@ZPEAX@Z", ExactSpelling = true)]
        private static extern void SetNextWindowSizeConstraints_PInvoke(Vector2* size_min, Vector2* size_max, delegate* unmanaged[Cdecl]<ImGuiSizeCallbackData*, void> custom_callback, void* custom_callback_data);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetNextWindowSizeConstraints(in Vector2 size_min, in Vector2 size_max, delegate* unmanaged[Cdecl]<ImGuiSizeCallbackData*, void> custom_callback = null, void* custom_callback_data = null)
        {
            fixed (Vector2* __size_minP = &size_min)
            fixed (Vector2* __size_maxP = &size_max)
            { SetNextWindowSizeConstraints_PInvoke(__size_minP, __size_maxP, custom_callback, custom_callback_data); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetNextWindowContentSize@ImGui@@YAXAEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern void SetNextWindowContentSize_PInvoke(Vector2* size);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetNextWindowContentSize(in Vector2 size)
        {
            fixed (Vector2* __sizeP = &size)
            { SetNextWindowContentSize_PInvoke(__sizeP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetNextWindowCollapsed@ImGui@@YAX_NH@Z", ExactSpelling = true)]
        private static extern void SetNextWindowCollapsed_PInvoke(byte collapsed, ImGuiCond cond);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetNextWindowCollapsed(bool collapsed, ImGuiCond cond = ImGuiCond.None)
        {
            SetNextWindowCollapsed_PInvoke(Unsafe.As<bool, byte>(ref collapsed), cond);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetNextWindowFocus@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void SetNextWindowFocus();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetNextWindowBgAlpha@ImGui@@YAXM@Z", ExactSpelling = true)]
        public static extern void SetNextWindowBgAlpha(float alpha);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetNextWindowViewport@ImGui@@YAXI@Z", ExactSpelling = true)]
        public static extern void SetNextWindowViewport(uint viewport_id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetWindowPos@ImGui@@YAXAEBUImVec2@@H@Z", ExactSpelling = true)]
        private static extern void SetWindowPos_PInvoke(Vector2* pos, ImGuiCond cond);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetWindowPos(in Vector2 pos, ImGuiCond cond = ImGuiCond.None)
        {
            fixed (Vector2* __posP = &pos)
            { SetWindowPos_PInvoke(__posP, cond); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetWindowSize@ImGui@@YAXAEBUImVec2@@H@Z", ExactSpelling = true)]
        private static extern void SetWindowSize_PInvoke(Vector2* size, ImGuiCond cond);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetWindowSize(in Vector2 size, ImGuiCond cond = ImGuiCond.None)
        {
            fixed (Vector2* __sizeP = &size)
            { SetWindowSize_PInvoke(__sizeP, cond); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetWindowCollapsed@ImGui@@YAX_NH@Z", ExactSpelling = true)]
        private static extern void SetWindowCollapsed_PInvoke(byte collapsed, ImGuiCond cond);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetWindowCollapsed(bool collapsed, ImGuiCond cond = ImGuiCond.None)
        {
            SetWindowCollapsed_PInvoke(Unsafe.As<bool, byte>(ref collapsed), cond);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetWindowFocus@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void SetWindowFocus();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetWindowFontScale@ImGui@@YAXM@Z", ExactSpelling = true)]
        public static extern void SetWindowFontScale(float scale);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetWindowPos@ImGui@@YAXPEBDAEBUImVec2@@H@Z", ExactSpelling = true)]
        private static extern void SetWindowPos_PInvoke(byte* name, Vector2* pos, ImGuiCond cond);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetWindowPos(byte* name, in Vector2 pos, ImGuiCond cond = ImGuiCond.None)
        {
            fixed (Vector2* __posP = &pos)
            { SetWindowPos_PInvoke(name, __posP, cond); }
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetWindowPos(DearImGuiInterpolatedStringHandler name, in Vector2 pos, ImGuiCond cond = ImGuiCond.None)
        {
            fixed (byte* __nameP = name.NullTerminateAndGetString())
            fixed (Vector2* __posP = &pos)
            { SetWindowPos_PInvoke(__nameP, __posP, cond); }

            name.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetWindowSize@ImGui@@YAXPEBDAEBUImVec2@@H@Z", ExactSpelling = true)]
        private static extern void SetWindowSize_PInvoke(byte* name, Vector2* size, ImGuiCond cond);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetWindowSize(byte* name, in Vector2 size, ImGuiCond cond = ImGuiCond.None)
        {
            fixed (Vector2* __sizeP = &size)
            { SetWindowSize_PInvoke(name, __sizeP, cond); }
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetWindowSize(DearImGuiInterpolatedStringHandler name, in Vector2 size, ImGuiCond cond = ImGuiCond.None)
        {
            fixed (byte* __nameP = name.NullTerminateAndGetString())
            fixed (Vector2* __sizeP = &size)
            { SetWindowSize_PInvoke(__nameP, __sizeP, cond); }

            name.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetWindowCollapsed@ImGui@@YAXPEBD_NH@Z", ExactSpelling = true)]
        private static extern void SetWindowCollapsed_PInvoke(byte* name, byte collapsed, ImGuiCond cond);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetWindowCollapsed(byte* name, bool collapsed, ImGuiCond cond = ImGuiCond.None)
        {
            SetWindowCollapsed_PInvoke(name, Unsafe.As<bool, byte>(ref collapsed), cond);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetWindowCollapsed(DearImGuiInterpolatedStringHandler name, bool collapsed, ImGuiCond cond = ImGuiCond.None)
        {
            fixed (byte* __nameP = name.NullTerminateAndGetString())
            { SetWindowCollapsed_PInvoke(__nameP, Unsafe.As<bool, byte>(ref collapsed), cond); }

            name.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetWindowFocus@ImGui@@YAXPEBD@Z", ExactSpelling = true)]
        public static extern void SetWindowFocus(byte* name);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetWindowFocus(DearImGuiInterpolatedStringHandler name)
        {
            fixed (byte* __nameP = name.NullTerminateAndGetString())
            { SetWindowFocus(__nameP); }

            name.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetContentRegionAvail_PInvoke(Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetContentRegionAvail()
        {
            Vector2 __returnBuffer;

            GetContentRegionAvail_PInvoke(&__returnBuffer);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetContentRegionMax_PInvoke(Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetContentRegionMax()
        {
            Vector2 __returnBuffer;

            GetContentRegionMax_PInvoke(&__returnBuffer);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetWindowContentRegionMin@ImGui@@YA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetWindowContentRegionMin_PInvoke(Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetWindowContentRegionMin()
        {
            Vector2 __returnBuffer;

            GetWindowContentRegionMin_PInvoke(&__returnBuffer);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetWindowContentRegionMax@ImGui@@YA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetWindowContentRegionMax_PInvoke(Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetWindowContentRegionMax()
        {
            Vector2 __returnBuffer;

            GetWindowContentRegionMax_PInvoke(&__returnBuffer);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetScrollX@ImGui@@YAMXZ", ExactSpelling = true)]
        public static extern float GetScrollX();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetScrollY@ImGui@@YAMXZ", ExactSpelling = true)]
        public static extern float GetScrollY();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetScrollX@ImGui@@YAXM@Z", ExactSpelling = true)]
        public static extern void SetScrollX(float scroll_x);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetScrollY@ImGui@@YAXM@Z", ExactSpelling = true)]
        public static extern void SetScrollY(float scroll_y);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetScrollMaxX@ImGui@@YAMXZ", ExactSpelling = true)]
        public static extern float GetScrollMaxX();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetScrollMaxY@ImGui@@YAMXZ", ExactSpelling = true)]
        public static extern float GetScrollMaxY();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetScrollHereX@ImGui@@YAXM@Z", ExactSpelling = true)]
        public static extern void SetScrollHereX(float center_x_ratio = 0.5f);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetScrollHereY@ImGui@@YAXM@Z", ExactSpelling = true)]
        public static extern void SetScrollHereY(float center_y_ratio = 0.5f);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetScrollFromPosX@ImGui@@YAXMM@Z", ExactSpelling = true)]
        public static extern void SetScrollFromPosX(float local_x, float center_x_ratio = 0.5f);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetScrollFromPosY@ImGui@@YAXMM@Z", ExactSpelling = true)]
        public static extern void SetScrollFromPosY(float local_y, float center_y_ratio = 0.5f);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushFont@ImGui@@YAXPEAUImFont@@@Z", ExactSpelling = true)]
        public static extern void PushFont(ImFont* font);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PopFont@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void PopFont();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushStyleColor@ImGui@@YAXHI@Z", ExactSpelling = true)]
        public static extern void PushStyleColor(ImGuiCol idx, uint col);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z", ExactSpelling = true)]
        private static extern void PushStyleColor_PInvoke(ImGuiCol idx, Vector4* col);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void PushStyleColor(ImGuiCol idx, in Vector4 col)
        {
            fixed (Vector4* __colP = &col)
            { PushStyleColor_PInvoke(idx, __colP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PopStyleColor@ImGui@@YAXH@Z", ExactSpelling = true)]
        public static extern void PopStyleColor(int count = 1);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushStyleVar@ImGui@@YAXHM@Z", ExactSpelling = true)]
        public static extern void PushStyleVar(ImGuiStyleVar idx, float val);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern void PushStyleVar_PInvoke(ImGuiStyleVar idx, Vector2* val);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void PushStyleVar(ImGuiStyleVar idx, in Vector2 val)
        {
            fixed (Vector2* __valP = &val)
            { PushStyleVar_PInvoke(idx, __valP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PopStyleVar@ImGui@@YAXH@Z", ExactSpelling = true)]
        public static extern void PopStyleVar(int count = 1);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushAllowKeyboardFocus@ImGui@@YAX_N@Z", ExactSpelling = true)]
        private static extern void PushAllowKeyboardFocus_PInvoke(byte allow_keyboard_focus);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void PushAllowKeyboardFocus(bool allow_keyboard_focus)
        {
            PushAllowKeyboardFocus_PInvoke(Unsafe.As<bool, byte>(ref allow_keyboard_focus));
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PopAllowKeyboardFocus@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void PopAllowKeyboardFocus();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushButtonRepeat@ImGui@@YAX_N@Z", ExactSpelling = true)]
        private static extern void PushButtonRepeat_PInvoke(byte repeat);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void PushButtonRepeat(bool repeat)
        {
            PushButtonRepeat_PInvoke(Unsafe.As<bool, byte>(ref repeat));
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PopButtonRepeat@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void PopButtonRepeat();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushItemWidth@ImGui@@YAXM@Z", ExactSpelling = true)]
        public static extern void PushItemWidth(float item_width);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PopItemWidth@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void PopItemWidth();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetNextItemWidth@ImGui@@YAXM@Z", ExactSpelling = true)]
        public static extern void SetNextItemWidth(float item_width);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CalcItemWidth@ImGui@@YAMXZ", ExactSpelling = true)]
        public static extern float CalcItemWidth();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushTextWrapPos@ImGui@@YAXM@Z", ExactSpelling = true)]
        public static extern void PushTextWrapPos(float wrap_local_pos_x = 0f);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PopTextWrapPos@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void PopTextWrapPos();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetFont@ImGui@@YAPEAUImFont@@XZ", ExactSpelling = true)]
        public static extern ImFont* GetFont();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetFontSize@ImGui@@YAMXZ", ExactSpelling = true)]
        public static extern float GetFontSize();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetFontTexUvWhitePixel@ImGui@@YA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetFontTexUvWhitePixel_PInvoke(Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetFontTexUvWhitePixel()
        {
            Vector2 __returnBuffer;

            GetFontTexUvWhitePixel_PInvoke(&__returnBuffer);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetColorU32@ImGui@@YAIHM@Z", ExactSpelling = true)]
        public static extern uint GetColorU32(ImGuiCol idx, float alpha_mul = 1f);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z", ExactSpelling = true)]
        private static extern uint GetColorU32_PInvoke(Vector4* col);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint GetColorU32(in Vector4 col)
        {
            fixed (Vector4* __colP = &col)
            { return GetColorU32_PInvoke(__colP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetColorU32@ImGui@@YAII@Z", ExactSpelling = true)]
        public static extern uint GetColorU32(uint col);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetStyleColorVec4@ImGui@@YAAEBUImVec4@@H@Z", ExactSpelling = true)]
        public static extern Vector4* GetStyleColorVec4(ImGuiCol idx);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Separator@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void Separator();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SameLine@ImGui@@YAXMM@Z", ExactSpelling = true)]
        public static extern void SameLine(float offset_from_start_x = 0f, float spacing = -1f);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?NewLine@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void NewLine();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Spacing@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void Spacing();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Dummy@ImGui@@YAXAEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern void Dummy_PInvoke(Vector2* size);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Dummy(in Vector2 size)
        {
            fixed (Vector2* __sizeP = &size)
            { Dummy_PInvoke(__sizeP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Indent@ImGui@@YAXM@Z", ExactSpelling = true)]
        public static extern void Indent(float indent_w = 0f);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Unindent@ImGui@@YAXM@Z", ExactSpelling = true)]
        public static extern void Unindent(float indent_w = 0f);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginGroup@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void BeginGroup();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndGroup@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndGroup();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetCursorPos@ImGui@@YA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetCursorPos_PInvoke(Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetCursorPos()
        {
            Vector2 __returnBuffer;

            GetCursorPos_PInvoke(&__returnBuffer);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetCursorPosX@ImGui@@YAMXZ", ExactSpelling = true)]
        public static extern float GetCursorPosX();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetCursorPosY@ImGui@@YAMXZ", ExactSpelling = true)]
        public static extern float GetCursorPosY();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetCursorPos@ImGui@@YAXAEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern void SetCursorPos_PInvoke(Vector2* local_pos);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetCursorPos(in Vector2 local_pos)
        {
            fixed (Vector2* __local_posP = &local_pos)
            { SetCursorPos_PInvoke(__local_posP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetCursorPosX@ImGui@@YAXM@Z", ExactSpelling = true)]
        public static extern void SetCursorPosX(float local_x);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetCursorPosY@ImGui@@YAXM@Z", ExactSpelling = true)]
        public static extern void SetCursorPosY(float local_y);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetCursorStartPos@ImGui@@YA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetCursorStartPos_PInvoke(Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetCursorStartPos()
        {
            Vector2 __returnBuffer;

            GetCursorStartPos_PInvoke(&__returnBuffer);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetCursorScreenPos_PInvoke(Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetCursorScreenPos()
        {
            Vector2 __returnBuffer;

            GetCursorScreenPos_PInvoke(&__returnBuffer);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetCursorScreenPos@ImGui@@YAXAEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern void SetCursorScreenPos_PInvoke(Vector2* pos);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetCursorScreenPos(in Vector2 pos)
        {
            fixed (Vector2* __posP = &pos)
            { SetCursorScreenPos_PInvoke(__posP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?AlignTextToFramePadding@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void AlignTextToFramePadding();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetTextLineHeight@ImGui@@YAMXZ", ExactSpelling = true)]
        public static extern float GetTextLineHeight();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetTextLineHeightWithSpacing@ImGui@@YAMXZ", ExactSpelling = true)]
        public static extern float GetTextLineHeightWithSpacing();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetFrameHeight@ImGui@@YAMXZ", ExactSpelling = true)]
        public static extern float GetFrameHeight();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetFrameHeightWithSpacing@ImGui@@YAMXZ", ExactSpelling = true)]
        public static extern float GetFrameHeightWithSpacing();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushID@ImGui@@YAXPEBD@Z", ExactSpelling = true)]
        public static extern void PushID(byte* str_id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushID@ImGui@@YAXPEBD0@Z", ExactSpelling = true)]
        public static extern void PushID(byte* str_id_begin, byte* str_id_end);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void PushID(DearImGuiInterpolatedStringHandler str_id_begin)
        {
            ReadOnlySpan<byte> __str_id_begin = str_id_begin.NullTerminateAndGetString();

            fixed (byte* __str_id_beginP = __str_id_begin)
            { PushID(__str_id_beginP, __str_id_beginP + __str_id_begin.Length); }

            str_id_begin.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushID@ImGui@@YAXPEBX@Z", ExactSpelling = true)]
        public static extern void PushID(void* ptr_id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushID@ImGui@@YAXH@Z", ExactSpelling = true)]
        public static extern void PushID(int int_id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PopID@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void PopID();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetID@ImGui@@YAIPEBD@Z", ExactSpelling = true)]
        public static extern uint GetID(byte* str_id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetID@ImGui@@YAIPEBD0@Z", ExactSpelling = true)]
        public static extern uint GetID(byte* str_id_begin, byte* str_id_end);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint GetID(DearImGuiInterpolatedStringHandler str_id_begin)
        {
            uint __result;
            ReadOnlySpan<byte> __str_id_begin = str_id_begin.NullTerminateAndGetString();

            fixed (byte* __str_id_beginP = __str_id_begin)
            { __result = GetID(__str_id_beginP, __str_id_beginP + __str_id_begin.Length); }

            str_id_begin.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetID@ImGui@@YAIPEBX@Z", ExactSpelling = true)]
        public static extern uint GetID(void* ptr_id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TextUnformatted@ImGui@@YAXPEBD0@Z", ExactSpelling = true)]
        public static extern void TextUnformatted(byte* text, byte* text_end = null);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TextUnformatted(DearImGuiInterpolatedStringHandler text)
        {
            ReadOnlySpan<byte> __text = text.NullTerminateAndGetString();

            fixed (byte* __textP = __text)
            { TextUnformatted(__textP, __textP + __text.Length); }

            text.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Text@ImGui@@YAXPEBDZZ", ExactSpelling = true)]
        public static extern void Text(byte* fmt);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Text(DearImGuiInterpolatedStringHandler fmt)
        {
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { Text(__fmtP); }

            fmt.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TextV@ImGui@@YAXPEBDPEAD@Z", ExactSpelling = true)]
        public static extern void TextV(byte* fmt, byte* args);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TextV(DearImGuiInterpolatedStringHandler fmt, byte* args)
        {
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { TextV(__fmtP, args); }

            fmt.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ", ExactSpelling = true)]
        private static extern void TextColored_PInvoke(Vector4* col, byte* fmt);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TextColored(in Vector4 col, byte* fmt)
        {
            fixed (Vector4* __colP = &col)
            { TextColored_PInvoke(__colP, fmt); }
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TextColored(in Vector4 col, DearImGuiInterpolatedStringHandler fmt)
        {
            fixed (Vector4* __colP = &col)
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { TextColored_PInvoke(__colP, __fmtP); }

            fmt.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TextColoredV@ImGui@@YAXAEBUImVec4@@PEBDPEAD@Z", ExactSpelling = true)]
        private static extern void TextColoredV_PInvoke(Vector4* col, byte* fmt, byte* args);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TextColoredV(in Vector4 col, byte* fmt, byte* args)
        {
            fixed (Vector4* __colP = &col)
            { TextColoredV_PInvoke(__colP, fmt, args); }
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TextColoredV(in Vector4 col, DearImGuiInterpolatedStringHandler fmt, byte* args)
        {
            fixed (Vector4* __colP = &col)
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { TextColoredV_PInvoke(__colP, __fmtP, args); }

            fmt.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TextDisabled@ImGui@@YAXPEBDZZ", ExactSpelling = true)]
        public static extern void TextDisabled(byte* fmt);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TextDisabled(DearImGuiInterpolatedStringHandler fmt)
        {
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { TextDisabled(__fmtP); }

            fmt.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TextDisabledV@ImGui@@YAXPEBDPEAD@Z", ExactSpelling = true)]
        public static extern void TextDisabledV(byte* fmt, byte* args);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TextDisabledV(DearImGuiInterpolatedStringHandler fmt, byte* args)
        {
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { TextDisabledV(__fmtP, args); }

            fmt.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TextWrapped@ImGui@@YAXPEBDZZ", ExactSpelling = true)]
        public static extern void TextWrapped(byte* fmt);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TextWrapped(DearImGuiInterpolatedStringHandler fmt)
        {
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { TextWrapped(__fmtP); }

            fmt.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TextWrappedV@ImGui@@YAXPEBDPEAD@Z", ExactSpelling = true)]
        public static extern void TextWrappedV(byte* fmt, byte* args);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TextWrappedV(DearImGuiInterpolatedStringHandler fmt, byte* args)
        {
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { TextWrappedV(__fmtP, args); }

            fmt.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?LabelText@ImGui@@YAXPEBD0ZZ", ExactSpelling = true)]
        public static extern void LabelText(byte* label, byte* fmt);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LabelText(DearImGuiInterpolatedStringHandler label, DearImGuiInterpolatedStringHandler fmt)
        {
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { LabelText(__labelP, __fmtP); }

            label.Dispose();
            fmt.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?LabelTextV@ImGui@@YAXPEBD0PEAD@Z", ExactSpelling = true)]
        public static extern void LabelTextV(byte* label, byte* fmt, byte* args);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LabelTextV(DearImGuiInterpolatedStringHandler label, DearImGuiInterpolatedStringHandler fmt, byte* args)
        {
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { LabelTextV(__labelP, __fmtP, args); }

            label.Dispose();
            fmt.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BulletText@ImGui@@YAXPEBDZZ", ExactSpelling = true)]
        public static extern void BulletText(byte* fmt);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void BulletText(DearImGuiInterpolatedStringHandler fmt)
        {
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { BulletText(__fmtP); }

            fmt.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BulletTextV@ImGui@@YAXPEBDPEAD@Z", ExactSpelling = true)]
        public static extern void BulletTextV(byte* fmt, byte* args);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void BulletTextV(DearImGuiInterpolatedStringHandler fmt, byte* args)
        {
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { BulletTextV(__fmtP, args); }

            fmt.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern byte Button_PInvoke(byte* label, Vector2* size);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Button(byte* label, in Vector2 size)
        {
            byte __result;

            fixed (Vector2* __sizeP = &size)
            { __result = Button_PInvoke(label, __sizeP); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Button(DearImGuiInterpolatedStringHandler label, in Vector2 size)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (Vector2* __sizeP = &size)
            { __result = Button_PInvoke(__labelP, __sizeP); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SmallButton@ImGui@@YA_NPEBD@Z", ExactSpelling = true)]
        private static extern byte SmallButton_PInvoke(byte* label);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SmallButton(byte* label)
        {
            byte __result;

            __result = SmallButton_PInvoke(label);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SmallButton(DearImGuiInterpolatedStringHandler label)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = SmallButton_PInvoke(__labelP); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@H@Z", ExactSpelling = true)]
        private static extern byte InvisibleButton_PInvoke(byte* str_id, Vector2* size, ImGuiButtonFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InvisibleButton(byte* str_id, in Vector2 size, ImGuiButtonFlags flags = ImGuiButtonFlags.None)
        {
            byte __result;

            fixed (Vector2* __sizeP = &size)
            { __result = InvisibleButton_PInvoke(str_id, __sizeP, flags); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InvisibleButton(DearImGuiInterpolatedStringHandler str_id, in Vector2 size, ImGuiButtonFlags flags = ImGuiButtonFlags.None)
        {
            byte __result;

            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            fixed (Vector2* __sizeP = &size)
            { __result = InvisibleButton_PInvoke(__str_idP, __sizeP, flags); }

            str_id.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ArrowButton@ImGui@@YA_NPEBDH@Z", ExactSpelling = true)]
        private static extern byte ArrowButton_PInvoke(byte* str_id, ImGuiDir dir);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ArrowButton(byte* str_id, ImGuiDir dir)
        {
            byte __result;

            __result = ArrowButton_PInvoke(str_id, dir);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ArrowButton(DearImGuiInterpolatedStringHandler str_id, ImGuiDir dir)
        {
            byte __result;

            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            { __result = ArrowButton_PInvoke(__str_idP, dir); }

            str_id.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z", ExactSpelling = true)]
        private static extern void Image_PInvoke(void* user_texture_id, Vector2* size, Vector2* uv0, Vector2* uv1, Vector4* tint_col, Vector4* border_col);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Image(void* user_texture_id, in Vector2 size, in Vector2 uv0, in Vector2 uv1, in Vector4 tint_col, in Vector4 border_col)
        {
            fixed (Vector2* __sizeP = &size)
            fixed (Vector2* __uv0P = &uv0)
            fixed (Vector2* __uv1P = &uv1)
            fixed (Vector4* __tint_colP = &tint_col)
            fixed (Vector4* __border_colP = &border_col)
            { Image_PInvoke(user_texture_id, __sizeP, __uv0P, __uv1P, __tint_colP, __border_colP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z", ExactSpelling = true)]
        private static extern byte ImageButton_PInvoke(void* user_texture_id, Vector2* size, Vector2* uv0, Vector2* uv1, int frame_padding, Vector4* bg_col, Vector4* tint_col);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ImageButton(void* user_texture_id, in Vector2 size, in Vector2 uv0, in Vector2 uv1, int frame_padding, in Vector4 bg_col, in Vector4 tint_col)
        {
            byte __result;

            fixed (Vector2* __sizeP = &size)
            fixed (Vector2* __uv0P = &uv0)
            fixed (Vector2* __uv1P = &uv1)
            fixed (Vector4* __bg_colP = &bg_col)
            fixed (Vector4* __tint_colP = &tint_col)
            { __result = ImageButton_PInvoke(user_texture_id, __sizeP, __uv0P, __uv1P, frame_padding, __bg_colP, __tint_colP); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Checkbox@ImGui@@YA_NPEBDPEA_N@Z", ExactSpelling = true)]
        private static extern byte Checkbox_PInvoke(byte* label, bool* v);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Checkbox(byte* label, bool* v)
        {
            byte __result;

            __result = Checkbox_PInvoke(label, v);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Checkbox(DearImGuiInterpolatedStringHandler label, bool* v)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = Checkbox_PInvoke(__labelP, v); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CheckboxFlags@ImGui@@YA_NPEBDPEAHH@Z", ExactSpelling = true)]
        private static extern byte CheckboxFlags_PInvoke(byte* label, int* flags, int flags_value);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool CheckboxFlags(byte* label, int* flags, int flags_value)
        {
            byte __result;

            __result = CheckboxFlags_PInvoke(label, flags, flags_value);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool CheckboxFlags(DearImGuiInterpolatedStringHandler label, int* flags, int flags_value)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = CheckboxFlags_PInvoke(__labelP, flags, flags_value); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CheckboxFlags@ImGui@@YA_NPEBDPEAII@Z", ExactSpelling = true)]
        private static extern byte CheckboxFlags_PInvoke(byte* label, uint* flags, uint flags_value);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool CheckboxFlags(byte* label, uint* flags, uint flags_value)
        {
            byte __result;

            __result = CheckboxFlags_PInvoke(label, flags, flags_value);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool CheckboxFlags(DearImGuiInterpolatedStringHandler label, uint* flags, uint flags_value)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = CheckboxFlags_PInvoke(__labelP, flags, flags_value); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RadioButton@ImGui@@YA_NPEBD_N@Z", ExactSpelling = true)]
        private static extern byte RadioButton_PInvoke(byte* label, byte active);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool RadioButton(byte* label, bool active)
        {
            byte __result;

            __result = RadioButton_PInvoke(label, Unsafe.As<bool, byte>(ref active));

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool RadioButton(DearImGuiInterpolatedStringHandler label, bool active)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = RadioButton_PInvoke(__labelP, Unsafe.As<bool, byte>(ref active)); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RadioButton@ImGui@@YA_NPEBDPEAHH@Z", ExactSpelling = true)]
        private static extern byte RadioButton_PInvoke(byte* label, int* v, int v_button);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool RadioButton(byte* label, int* v, int v_button)
        {
            byte __result;

            __result = RadioButton_PInvoke(label, v, v_button);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool RadioButton(DearImGuiInterpolatedStringHandler label, int* v, int v_button)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = RadioButton_PInvoke(__labelP, v, v_button); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ProgressBar@ImGui@@YAXMAEBUImVec2@@PEBD@Z", ExactSpelling = true)]
        private static extern void ProgressBar_PInvoke(float fraction, Vector2* size_arg, byte* overlay);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ProgressBar(float fraction, in Vector2 size_arg, byte* overlay = null)
        {
            fixed (Vector2* __size_argP = &size_arg)
            { ProgressBar_PInvoke(fraction, __size_argP, overlay); }
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ProgressBar(float fraction, in Vector2 size_arg, DearImGuiInterpolatedStringHandler overlay)
        {
            fixed (Vector2* __size_argP = &size_arg)
            fixed (byte* __overlayP = overlay.NullTerminateAndGetString())
            { ProgressBar_PInvoke(fraction, __size_argP, __overlayP); }

            overlay.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Bullet@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void Bullet();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginCombo@ImGui@@YA_NPEBD0H@Z", ExactSpelling = true)]
        private static extern byte BeginCombo_PInvoke(byte* label, byte* preview_value, ImGuiComboFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginCombo(byte* label, byte* preview_value, ImGuiComboFlags flags = ImGuiComboFlags.None)
        {
            byte __result;

            __result = BeginCombo_PInvoke(label, preview_value, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginCombo(DearImGuiInterpolatedStringHandler label, DearImGuiInterpolatedStringHandler preview_value, ImGuiComboFlags flags = ImGuiComboFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __preview_valueP = preview_value.NullTerminateAndGetString())
            { __result = BeginCombo_PInvoke(__labelP, __preview_valueP, flags); }

            label.Dispose();
            preview_value.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndCombo@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndCombo();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Combo@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z", ExactSpelling = true)]
        private static extern byte Combo_PInvoke(byte* label, int* current_item, byte** items, int items_count, int popup_max_height_in_items);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Combo(byte* label, int* current_item, byte** items, int items_count, int popup_max_height_in_items = -1)
        {
            byte __result;

            __result = Combo_PInvoke(label, current_item, items, items_count, popup_max_height_in_items);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Combo(DearImGuiInterpolatedStringHandler label, int* current_item, byte** items, int items_count, int popup_max_height_in_items = -1)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = Combo_PInvoke(__labelP, current_item, items, items_count, popup_max_height_in_items); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Combo@ImGui@@YA_NPEBDPEAH0H@Z", ExactSpelling = true)]
        private static extern byte Combo_PInvoke(byte* label, int* current_item, byte* items_separated_by_zeros, int popup_max_height_in_items);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Combo(byte* label, int* current_item, byte* items_separated_by_zeros, int popup_max_height_in_items = -1)
        {
            byte __result;

            __result = Combo_PInvoke(label, current_item, items_separated_by_zeros, popup_max_height_in_items);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Combo(DearImGuiInterpolatedStringHandler label, int* current_item, DearImGuiInterpolatedStringHandler items_separated_by_zeros, int popup_max_height_in_items = -1)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __items_separated_by_zerosP = items_separated_by_zeros.NullTerminateAndGetString())
            { __result = Combo_PInvoke(__labelP, current_item, __items_separated_by_zerosP, popup_max_height_in_items); }

            label.Dispose();
            items_separated_by_zeros.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z", ExactSpelling = true)]
        private static extern byte Combo_PInvoke(byte* label, int* current_item, delegate* unmanaged[Cdecl]<void*, int, byte**, NativeBoolean> items_getter, void* data, int items_count, int popup_max_height_in_items);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Combo(byte* label, int* current_item, delegate* unmanaged[Cdecl]<void*, int, byte**, NativeBoolean> items_getter, void* data, int items_count, int popup_max_height_in_items = -1)
        {
            byte __result;

            __result = Combo_PInvoke(label, current_item, items_getter, data, items_count, popup_max_height_in_items);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Combo(DearImGuiInterpolatedStringHandler label, int* current_item, delegate* unmanaged[Cdecl]<void*, int, byte**, NativeBoolean> items_getter, void* data, int items_count, int popup_max_height_in_items = -1)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = Combo_PInvoke(__labelP, current_item, items_getter, data, items_count, popup_max_height_in_items); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DragFloat@ImGui@@YA_NPEBDPEAMMMM0H@Z", ExactSpelling = true)]
        private static extern byte DragFloat_PInvoke(byte* label, float* v, float v_speed, float v_min, float v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragFloat(byte* label, float* v, float v_speed, float v_min, float v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = DragFloat_PInvoke(label, v, v_speed, v_min, v_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragFloat(DearImGuiInterpolatedStringHandler label, float* v, float v_speed, float v_min, float v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = DragFloat_PInvoke(__labelP, v, v_speed, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DragFloat2@ImGui@@YA_NPEBDQEAMMMM0H@Z", ExactSpelling = true)]
        private static extern byte DragFloat2_PInvoke(byte* label, Vector2* v, float v_speed, float v_min, float v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragFloat2(byte* label, Vector2* v, float v_speed, float v_min, float v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = DragFloat2_PInvoke(label, v, v_speed, v_min, v_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragFloat2(DearImGuiInterpolatedStringHandler label, Vector2* v, float v_speed, float v_min, float v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = DragFloat2_PInvoke(__labelP, v, v_speed, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DragFloat3@ImGui@@YA_NPEBDQEAMMMM0H@Z", ExactSpelling = true)]
        private static extern byte DragFloat3_PInvoke(byte* label, Vector3* v, float v_speed, float v_min, float v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragFloat3(byte* label, Vector3* v, float v_speed, float v_min, float v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = DragFloat3_PInvoke(label, v, v_speed, v_min, v_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragFloat3(DearImGuiInterpolatedStringHandler label, Vector3* v, float v_speed, float v_min, float v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = DragFloat3_PInvoke(__labelP, v, v_speed, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DragFloat4@ImGui@@YA_NPEBDQEAMMMM0H@Z", ExactSpelling = true)]
        private static extern byte DragFloat4_PInvoke(byte* label, Vector4* v, float v_speed, float v_min, float v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragFloat4(byte* label, Vector4* v, float v_speed, float v_min, float v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = DragFloat4_PInvoke(label, v, v_speed, v_min, v_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragFloat4(DearImGuiInterpolatedStringHandler label, Vector4* v, float v_speed, float v_min, float v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = DragFloat4_PInvoke(__labelP, v, v_speed, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DragFloatRange2@ImGui@@YA_NPEBDPEAM1MMM00H@Z", ExactSpelling = true)]
        private static extern byte DragFloatRange2_PInvoke(byte* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, byte* format, byte* format_max, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragFloatRange2(byte* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, byte* format, byte* format_max = null, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = DragFloatRange2_PInvoke(label, v_current_min, v_current_max, v_speed, v_min, v_max, format, format_max, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragFloatRange2(DearImGuiInterpolatedStringHandler label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, DearImGuiInterpolatedStringHandler format, DearImGuiInterpolatedStringHandler format_max, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            fixed (byte* __format_maxP = format_max.NullTerminateAndGetString())
            { __result = DragFloatRange2_PInvoke(__labelP, v_current_min, v_current_max, v_speed, v_min, v_max, __formatP, __format_maxP, flags); }

            label.Dispose();
            format.Dispose();
            format_max.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DragInt@ImGui@@YA_NPEBDPEAHMHH0H@Z", ExactSpelling = true)]
        private static extern byte DragInt_PInvoke(byte* label, int* v, float v_speed, int v_min, int v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragInt(byte* label, int* v, float v_speed, int v_min, int v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = DragInt_PInvoke(label, v, v_speed, v_min, v_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragInt(DearImGuiInterpolatedStringHandler label, int* v, float v_speed, int v_min, int v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = DragInt_PInvoke(__labelP, v, v_speed, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DragInt2@ImGui@@YA_NPEBDQEAHMHH0H@Z", ExactSpelling = true)]
        private static extern byte DragInt2_PInvoke(byte* label, (int x, int y)* v, float v_speed, int v_min, int v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragInt2(byte* label, (int x, int y)* v, float v_speed, int v_min, int v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = DragInt2_PInvoke(label, v, v_speed, v_min, v_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragInt2(DearImGuiInterpolatedStringHandler label, (int x, int y)* v, float v_speed, int v_min, int v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = DragInt2_PInvoke(__labelP, v, v_speed, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DragInt3@ImGui@@YA_NPEBDQEAHMHH0H@Z", ExactSpelling = true)]
        private static extern byte DragInt3_PInvoke(byte* label, (int x, int y, int z)* v, float v_speed, int v_min, int v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragInt3(byte* label, (int x, int y, int z)* v, float v_speed, int v_min, int v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = DragInt3_PInvoke(label, v, v_speed, v_min, v_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragInt3(DearImGuiInterpolatedStringHandler label, (int x, int y, int z)* v, float v_speed, int v_min, int v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = DragInt3_PInvoke(__labelP, v, v_speed, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DragInt4@ImGui@@YA_NPEBDQEAHMHH0H@Z", ExactSpelling = true)]
        private static extern byte DragInt4_PInvoke(byte* label, (int x, int y, int z, int w)* v, float v_speed, int v_min, int v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragInt4(byte* label, (int x, int y, int z, int w)* v, float v_speed, int v_min, int v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = DragInt4_PInvoke(label, v, v_speed, v_min, v_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragInt4(DearImGuiInterpolatedStringHandler label, (int x, int y, int z, int w)* v, float v_speed, int v_min, int v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = DragInt4_PInvoke(__labelP, v, v_speed, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DragIntRange2@ImGui@@YA_NPEBDPEAH1MHH00H@Z", ExactSpelling = true)]
        private static extern byte DragIntRange2_PInvoke(byte* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, byte* format, byte* format_max, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragIntRange2(byte* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, byte* format, byte* format_max = null, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = DragIntRange2_PInvoke(label, v_current_min, v_current_max, v_speed, v_min, v_max, format, format_max, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragIntRange2(DearImGuiInterpolatedStringHandler label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, DearImGuiInterpolatedStringHandler format, DearImGuiInterpolatedStringHandler format_max, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            fixed (byte* __format_maxP = format_max.NullTerminateAndGetString())
            { __result = DragIntRange2_PInvoke(__labelP, v_current_min, v_current_max, v_speed, v_min, v_max, __formatP, __format_maxP, flags); }

            label.Dispose();
            format.Dispose();
            format_max.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z", ExactSpelling = true)]
        private static extern byte DragScalar_PInvoke(byte* label, ImGuiDataType data_type, void* p_data, float v_speed, void* p_min, void* p_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragScalar(byte* label, ImGuiDataType data_type, void* p_data, float v_speed = 1f, void* p_min = null, void* p_max = null, byte* format = null, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = DragScalar_PInvoke(label, data_type, p_data, v_speed, p_min, p_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragScalar(DearImGuiInterpolatedStringHandler label, ImGuiDataType data_type, void* p_data, float v_speed, void* p_min, void* p_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = DragScalar_PInvoke(__labelP, data_type, p_data, v_speed, p_min, p_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DragScalarN@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z", ExactSpelling = true)]
        private static extern byte DragScalarN_PInvoke(byte* label, ImGuiDataType data_type, void* p_data, int components, float v_speed, void* p_min, void* p_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragScalarN(byte* label, ImGuiDataType data_type, void* p_data, int components, float v_speed = 1f, void* p_min = null, void* p_max = null, byte* format = null, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = DragScalarN_PInvoke(label, data_type, p_data, components, v_speed, p_min, p_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragScalarN(DearImGuiInterpolatedStringHandler label, ImGuiDataType data_type, void* p_data, int components, float v_speed, void* p_min, void* p_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = DragScalarN_PInvoke(__labelP, data_type, p_data, components, v_speed, p_min, p_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SliderFloat@ImGui@@YA_NPEBDPEAMMM0H@Z", ExactSpelling = true)]
        private static extern byte SliderFloat_PInvoke(byte* label, float* v, float v_min, float v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderFloat(byte* label, float* v, float v_min, float v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = SliderFloat_PInvoke(label, v, v_min, v_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderFloat(DearImGuiInterpolatedStringHandler label, float* v, float v_min, float v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = SliderFloat_PInvoke(__labelP, v, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SliderFloat2@ImGui@@YA_NPEBDQEAMMM0H@Z", ExactSpelling = true)]
        private static extern byte SliderFloat2_PInvoke(byte* label, Vector2* v, float v_min, float v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderFloat2(byte* label, Vector2* v, float v_min, float v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = SliderFloat2_PInvoke(label, v, v_min, v_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderFloat2(DearImGuiInterpolatedStringHandler label, Vector2* v, float v_min, float v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = SliderFloat2_PInvoke(__labelP, v, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SliderFloat3@ImGui@@YA_NPEBDQEAMMM0H@Z", ExactSpelling = true)]
        private static extern byte SliderFloat3_PInvoke(byte* label, Vector3* v, float v_min, float v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderFloat3(byte* label, Vector3* v, float v_min, float v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = SliderFloat3_PInvoke(label, v, v_min, v_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderFloat3(DearImGuiInterpolatedStringHandler label, Vector3* v, float v_min, float v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = SliderFloat3_PInvoke(__labelP, v, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SliderFloat4@ImGui@@YA_NPEBDQEAMMM0H@Z", ExactSpelling = true)]
        private static extern byte SliderFloat4_PInvoke(byte* label, Vector4* v, float v_min, float v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderFloat4(byte* label, Vector4* v, float v_min, float v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = SliderFloat4_PInvoke(label, v, v_min, v_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderFloat4(DearImGuiInterpolatedStringHandler label, Vector4* v, float v_min, float v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = SliderFloat4_PInvoke(__labelP, v, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SliderAngle@ImGui@@YA_NPEBDPEAMMM0H@Z", ExactSpelling = true)]
        private static extern byte SliderAngle_PInvoke(byte* label, float* v_rad, float v_degrees_min, float v_degrees_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderAngle(byte* label, float* v_rad, float v_degrees_min, float v_degrees_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = SliderAngle_PInvoke(label, v_rad, v_degrees_min, v_degrees_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderAngle(DearImGuiInterpolatedStringHandler label, float* v_rad, float v_degrees_min, float v_degrees_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = SliderAngle_PInvoke(__labelP, v_rad, v_degrees_min, v_degrees_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SliderInt@ImGui@@YA_NPEBDPEAHHH0H@Z", ExactSpelling = true)]
        private static extern byte SliderInt_PInvoke(byte* label, int* v, int v_min, int v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderInt(byte* label, int* v, int v_min, int v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = SliderInt_PInvoke(label, v, v_min, v_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderInt(DearImGuiInterpolatedStringHandler label, int* v, int v_min, int v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = SliderInt_PInvoke(__labelP, v, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SliderInt2@ImGui@@YA_NPEBDQEAHHH0H@Z", ExactSpelling = true)]
        private static extern byte SliderInt2_PInvoke(byte* label, (int x, int y)* v, int v_min, int v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderInt2(byte* label, (int x, int y)* v, int v_min, int v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = SliderInt2_PInvoke(label, v, v_min, v_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderInt2(DearImGuiInterpolatedStringHandler label, (int x, int y)* v, int v_min, int v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = SliderInt2_PInvoke(__labelP, v, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SliderInt3@ImGui@@YA_NPEBDQEAHHH0H@Z", ExactSpelling = true)]
        private static extern byte SliderInt3_PInvoke(byte* label, (int x, int y, int z)* v, int v_min, int v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderInt3(byte* label, (int x, int y, int z)* v, int v_min, int v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = SliderInt3_PInvoke(label, v, v_min, v_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderInt3(DearImGuiInterpolatedStringHandler label, (int x, int y, int z)* v, int v_min, int v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = SliderInt3_PInvoke(__labelP, v, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SliderInt4@ImGui@@YA_NPEBDQEAHHH0H@Z", ExactSpelling = true)]
        private static extern byte SliderInt4_PInvoke(byte* label, (int x, int y, int z, int w)* v, int v_min, int v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderInt4(byte* label, (int x, int y, int z, int w)* v, int v_min, int v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = SliderInt4_PInvoke(label, v, v_min, v_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderInt4(DearImGuiInterpolatedStringHandler label, (int x, int y, int z, int w)* v, int v_min, int v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = SliderInt4_PInvoke(__labelP, v, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SliderScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z", ExactSpelling = true)]
        private static extern byte SliderScalar_PInvoke(byte* label, ImGuiDataType data_type, void* p_data, void* p_min, void* p_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderScalar(byte* label, ImGuiDataType data_type, void* p_data, void* p_min, void* p_max, byte* format = null, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = SliderScalar_PInvoke(label, data_type, p_data, p_min, p_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderScalar(DearImGuiInterpolatedStringHandler label, ImGuiDataType data_type, void* p_data, void* p_min, void* p_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = SliderScalar_PInvoke(__labelP, data_type, p_data, p_min, p_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SliderScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z", ExactSpelling = true)]
        private static extern byte SliderScalarN_PInvoke(byte* label, ImGuiDataType data_type, void* p_data, int components, void* p_min, void* p_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderScalarN(byte* label, ImGuiDataType data_type, void* p_data, int components, void* p_min, void* p_max, byte* format = null, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            __result = SliderScalarN_PInvoke(label, data_type, p_data, components, p_min, p_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderScalarN(DearImGuiInterpolatedStringHandler label, ImGuiDataType data_type, void* p_data, int components, void* p_min, void* p_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = SliderScalarN_PInvoke(__labelP, data_type, p_data, components, p_min, p_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?VSliderFloat@ImGui@@YA_NPEBDAEBUImVec2@@PEAMMM0H@Z", ExactSpelling = true)]
        private static extern byte VSliderFloat_PInvoke(byte* label, Vector2* size, float* v, float v_min, float v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool VSliderFloat(byte* label, in Vector2 size, float* v, float v_min, float v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (Vector2* __sizeP = &size)
            { __result = VSliderFloat_PInvoke(label, __sizeP, v, v_min, v_max, format, flags); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool VSliderFloat(DearImGuiInterpolatedStringHandler label, in Vector2 size, float* v, float v_min, float v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (Vector2* __sizeP = &size)
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = VSliderFloat_PInvoke(__labelP, __sizeP, v, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?VSliderInt@ImGui@@YA_NPEBDAEBUImVec2@@PEAHHH0H@Z", ExactSpelling = true)]
        private static extern byte VSliderInt_PInvoke(byte* label, Vector2* size, int* v, int v_min, int v_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool VSliderInt(byte* label, in Vector2 size, int* v, int v_min, int v_max, byte* format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (Vector2* __sizeP = &size)
            { __result = VSliderInt_PInvoke(label, __sizeP, v, v_min, v_max, format, flags); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool VSliderInt(DearImGuiInterpolatedStringHandler label, in Vector2 size, int* v, int v_min, int v_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (Vector2* __sizeP = &size)
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = VSliderInt_PInvoke(__labelP, __sizeP, v, v_min, v_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?VSliderScalar@ImGui@@YA_NPEBDAEBUImVec2@@HPEAXPEBX30H@Z", ExactSpelling = true)]
        private static extern byte VSliderScalar_PInvoke(byte* label, Vector2* size, ImGuiDataType data_type, void* p_data, void* p_min, void* p_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool VSliderScalar(byte* label, in Vector2 size, ImGuiDataType data_type, void* p_data, void* p_min, void* p_max, byte* format = null, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (Vector2* __sizeP = &size)
            { __result = VSliderScalar_PInvoke(label, __sizeP, data_type, p_data, p_min, p_max, format, flags); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool VSliderScalar(DearImGuiInterpolatedStringHandler label, in Vector2 size, ImGuiDataType data_type, void* p_data, void* p_min, void* p_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags = ImGuiSliderFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (Vector2* __sizeP = &size)
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = VSliderScalar_PInvoke(__labelP, __sizeP, data_type, p_data, p_min, p_max, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z", ExactSpelling = true)]
        private static extern byte InputText_PInvoke(byte* label, byte* buf, nuint buf_size, ImGuiInputTextFlags flags, delegate* unmanaged[Cdecl]<ImGuiInputTextCallbackData*, int> callback, void* user_data);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputText(byte* label, byte* buf, nuint buf_size, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None, delegate* unmanaged[Cdecl]<ImGuiInputTextCallbackData*, int> callback = null, void* user_data = null)
        {
            byte __result;

            __result = InputText_PInvoke(label, buf, buf_size, flags, callback, user_data);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputText(DearImGuiInterpolatedStringHandler label, byte* buf, nuint buf_size, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None, delegate* unmanaged[Cdecl]<ImGuiInputTextCallbackData*, int> callback = null, void* user_data = null)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = InputText_PInvoke(__labelP, buf, buf_size, flags, callback, user_data); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?InputTextMultiline@ImGui@@YA_NPEBDPEAD_KAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z", ExactSpelling = true)]
        private static extern byte InputTextMultiline_PInvoke(byte* label, byte* buf, nuint buf_size, Vector2* size, ImGuiInputTextFlags flags, delegate* unmanaged[Cdecl]<ImGuiInputTextCallbackData*, int> callback, void* user_data);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputTextMultiline(byte* label, byte* buf, nuint buf_size, in Vector2 size, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None, delegate* unmanaged[Cdecl]<ImGuiInputTextCallbackData*, int> callback = null, void* user_data = null)
        {
            byte __result;

            fixed (Vector2* __sizeP = &size)
            { __result = InputTextMultiline_PInvoke(label, buf, buf_size, __sizeP, flags, callback, user_data); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputTextMultiline(DearImGuiInterpolatedStringHandler label, byte* buf, nuint buf_size, in Vector2 size, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None, delegate* unmanaged[Cdecl]<ImGuiInputTextCallbackData*, int> callback = null, void* user_data = null)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (Vector2* __sizeP = &size)
            { __result = InputTextMultiline_PInvoke(__labelP, buf, buf_size, __sizeP, flags, callback, user_data); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?InputTextWithHint@ImGui@@YA_NPEBD0PEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z", ExactSpelling = true)]
        private static extern byte InputTextWithHint_PInvoke(byte* label, byte* hint, byte* buf, nuint buf_size, ImGuiInputTextFlags flags, delegate* unmanaged[Cdecl]<ImGuiInputTextCallbackData*, int> callback, void* user_data);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputTextWithHint(byte* label, byte* hint, byte* buf, nuint buf_size, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None, delegate* unmanaged[Cdecl]<ImGuiInputTextCallbackData*, int> callback = null, void* user_data = null)
        {
            byte __result;

            __result = InputTextWithHint_PInvoke(label, hint, buf, buf_size, flags, callback, user_data);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputTextWithHint(DearImGuiInterpolatedStringHandler label, DearImGuiInterpolatedStringHandler hint, byte* buf, nuint buf_size, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None, delegate* unmanaged[Cdecl]<ImGuiInputTextCallbackData*, int> callback = null, void* user_data = null)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __hintP = hint.NullTerminateAndGetString())
            { __result = InputTextWithHint_PInvoke(__labelP, __hintP, buf, buf_size, flags, callback, user_data); }

            label.Dispose();
            hint.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z", ExactSpelling = true)]
        private static extern byte InputFloat_PInvoke(byte* label, float* v, float step, float step_fast, byte* format, ImGuiInputTextFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputFloat(byte* label, float* v, float step, float step_fast, byte* format, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            __result = InputFloat_PInvoke(label, v, step, step_fast, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputFloat(DearImGuiInterpolatedStringHandler label, float* v, float step, float step_fast, DearImGuiInterpolatedStringHandler format, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = InputFloat_PInvoke(__labelP, v, step, step_fast, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?InputFloat2@ImGui@@YA_NPEBDQEAM0H@Z", ExactSpelling = true)]
        private static extern byte InputFloat2_PInvoke(byte* label, Vector2* v, byte* format, ImGuiInputTextFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputFloat2(byte* label, Vector2* v, byte* format, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            __result = InputFloat2_PInvoke(label, v, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputFloat2(DearImGuiInterpolatedStringHandler label, Vector2* v, DearImGuiInterpolatedStringHandler format, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = InputFloat2_PInvoke(__labelP, v, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?InputFloat3@ImGui@@YA_NPEBDQEAM0H@Z", ExactSpelling = true)]
        private static extern byte InputFloat3_PInvoke(byte* label, Vector3* v, byte* format, ImGuiInputTextFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputFloat3(byte* label, Vector3* v, byte* format, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            __result = InputFloat3_PInvoke(label, v, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputFloat3(DearImGuiInterpolatedStringHandler label, Vector3* v, DearImGuiInterpolatedStringHandler format, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = InputFloat3_PInvoke(__labelP, v, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?InputFloat4@ImGui@@YA_NPEBDQEAM0H@Z", ExactSpelling = true)]
        private static extern byte InputFloat4_PInvoke(byte* label, Vector4* v, byte* format, ImGuiInputTextFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputFloat4(byte* label, Vector4* v, byte* format, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            __result = InputFloat4_PInvoke(label, v, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputFloat4(DearImGuiInterpolatedStringHandler label, Vector4* v, DearImGuiInterpolatedStringHandler format, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = InputFloat4_PInvoke(__labelP, v, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?InputInt@ImGui@@YA_NPEBDPEAHHHH@Z", ExactSpelling = true)]
        private static extern byte InputInt_PInvoke(byte* label, int* v, int step, int step_fast, ImGuiInputTextFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputInt(byte* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            __result = InputInt_PInvoke(label, v, step, step_fast, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputInt(DearImGuiInterpolatedStringHandler label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = InputInt_PInvoke(__labelP, v, step, step_fast, flags); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?InputInt2@ImGui@@YA_NPEBDQEAHH@Z", ExactSpelling = true)]
        private static extern byte InputInt2_PInvoke(byte* label, (int x, int y)* v, ImGuiInputTextFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputInt2(byte* label, (int x, int y)* v, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            __result = InputInt2_PInvoke(label, v, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputInt2(DearImGuiInterpolatedStringHandler label, (int x, int y)* v, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = InputInt2_PInvoke(__labelP, v, flags); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?InputInt3@ImGui@@YA_NPEBDQEAHH@Z", ExactSpelling = true)]
        private static extern byte InputInt3_PInvoke(byte* label, (int x, int y, int z)* v, ImGuiInputTextFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputInt3(byte* label, (int x, int y, int z)* v, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            __result = InputInt3_PInvoke(label, v, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputInt3(DearImGuiInterpolatedStringHandler label, (int x, int y, int z)* v, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = InputInt3_PInvoke(__labelP, v, flags); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?InputInt4@ImGui@@YA_NPEBDQEAHH@Z", ExactSpelling = true)]
        private static extern byte InputInt4_PInvoke(byte* label, (int x, int y, int z, int w)* v, ImGuiInputTextFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputInt4(byte* label, (int x, int y, int z, int w)* v, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            __result = InputInt4_PInvoke(label, v, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputInt4(DearImGuiInterpolatedStringHandler label, (int x, int y, int z, int w)* v, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = InputInt4_PInvoke(__labelP, v, flags); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?InputDouble@ImGui@@YA_NPEBDPEANNN0H@Z", ExactSpelling = true)]
        private static extern byte InputDouble_PInvoke(byte* label, double* v, double step, double step_fast, byte* format, ImGuiInputTextFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputDouble(byte* label, double* v, double step, double step_fast, byte* format, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            __result = InputDouble_PInvoke(label, v, step, step_fast, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputDouble(DearImGuiInterpolatedStringHandler label, double* v, double step, double step_fast, DearImGuiInterpolatedStringHandler format, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = InputDouble_PInvoke(__labelP, v, step, step_fast, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z", ExactSpelling = true)]
        private static extern byte InputScalar_PInvoke(byte* label, ImGuiDataType data_type, void* p_data, void* p_step, void* p_step_fast, byte* format, ImGuiInputTextFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputScalar(byte* label, ImGuiDataType data_type, void* p_data, void* p_step = null, void* p_step_fast = null, byte* format = null, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            __result = InputScalar_PInvoke(label, data_type, p_data, p_step, p_step_fast, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputScalar(DearImGuiInterpolatedStringHandler label, ImGuiDataType data_type, void* p_data, void* p_step, void* p_step_fast, DearImGuiInterpolatedStringHandler format, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = InputScalar_PInvoke(__labelP, data_type, p_data, p_step, p_step_fast, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z", ExactSpelling = true)]
        private static extern byte InputScalarN_PInvoke(byte* label, ImGuiDataType data_type, void* p_data, int components, void* p_step, void* p_step_fast, byte* format, ImGuiInputTextFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputScalarN(byte* label, ImGuiDataType data_type, void* p_data, int components, void* p_step = null, void* p_step_fast = null, byte* format = null, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            __result = InputScalarN_PInvoke(label, data_type, p_data, components, p_step, p_step_fast, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputScalarN(DearImGuiInterpolatedStringHandler label, ImGuiDataType data_type, void* p_data, int components, void* p_step, void* p_step_fast, DearImGuiInterpolatedStringHandler format, ImGuiInputTextFlags flags = ImGuiInputTextFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = InputScalarN_PInvoke(__labelP, data_type, p_data, components, p_step, p_step_fast, __formatP, flags); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ColorEdit3@ImGui@@YA_NPEBDQEAMH@Z", ExactSpelling = true)]
        private static extern byte ColorEdit3_PInvoke(byte* label, Vector3* col, ImGuiColorEditFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ColorEdit3(byte* label, Vector3* col, ImGuiColorEditFlags flags = ImGuiColorEditFlags.None)
        {
            byte __result;

            __result = ColorEdit3_PInvoke(label, col, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ColorEdit3(DearImGuiInterpolatedStringHandler label, Vector3* col, ImGuiColorEditFlags flags = ImGuiColorEditFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = ColorEdit3_PInvoke(__labelP, col, flags); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z", ExactSpelling = true)]
        private static extern byte ColorEdit4_PInvoke(byte* label, Vector4* col, ImGuiColorEditFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ColorEdit4(byte* label, Vector4* col, ImGuiColorEditFlags flags = ImGuiColorEditFlags.None)
        {
            byte __result;

            __result = ColorEdit4_PInvoke(label, col, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ColorEdit4(DearImGuiInterpolatedStringHandler label, Vector4* col, ImGuiColorEditFlags flags = ImGuiColorEditFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = ColorEdit4_PInvoke(__labelP, col, flags); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ColorPicker3@ImGui@@YA_NPEBDQEAMH@Z", ExactSpelling = true)]
        private static extern byte ColorPicker3_PInvoke(byte* label, Vector3* col, ImGuiColorEditFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ColorPicker3(byte* label, Vector3* col, ImGuiColorEditFlags flags = ImGuiColorEditFlags.None)
        {
            byte __result;

            __result = ColorPicker3_PInvoke(label, col, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ColorPicker3(DearImGuiInterpolatedStringHandler label, Vector3* col, ImGuiColorEditFlags flags = ImGuiColorEditFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = ColorPicker3_PInvoke(__labelP, col, flags); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z", ExactSpelling = true)]
        private static extern byte ColorPicker4_PInvoke(byte* label, Vector4* col, ImGuiColorEditFlags flags, float* ref_col);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ColorPicker4(byte* label, Vector4* col, ImGuiColorEditFlags flags = ImGuiColorEditFlags.None, float* ref_col = null)
        {
            byte __result;

            __result = ColorPicker4_PInvoke(label, col, flags, ref_col);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ColorPicker4(DearImGuiInterpolatedStringHandler label, Vector4* col, ImGuiColorEditFlags flags = ImGuiColorEditFlags.None, float* ref_col = null)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = ColorPicker4_PInvoke(__labelP, col, flags, ref_col); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HUImVec2@@@Z", ExactSpelling = true)]
        private static extern byte ColorButton_PInvoke(byte* desc_id, Vector4* col, ImGuiColorEditFlags flags, Vector2 size);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ColorButton(byte* desc_id, in Vector4 col, ImGuiColorEditFlags flags, Vector2 size)
        {
            byte __result;

            fixed (Vector4* __colP = &col)
            { __result = ColorButton_PInvoke(desc_id, __colP, flags, size); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ColorButton(DearImGuiInterpolatedStringHandler desc_id, in Vector4 col, ImGuiColorEditFlags flags, Vector2 size)
        {
            byte __result;

            fixed (byte* __desc_idP = desc_id.NullTerminateAndGetString())
            fixed (Vector4* __colP = &col)
            { __result = ColorButton_PInvoke(__desc_idP, __colP, flags, size); }

            desc_id.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetColorEditOptions@ImGui@@YAXH@Z", ExactSpelling = true)]
        public static extern void SetColorEditOptions(ImGuiColorEditFlags flags);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TreeNode@ImGui@@YA_NPEBD@Z", ExactSpelling = true)]
        private static extern byte TreeNode_PInvoke(byte* label);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNode(byte* label)
        {
            byte __result;

            __result = TreeNode_PInvoke(label);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNode(DearImGuiInterpolatedStringHandler label)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = TreeNode_PInvoke(__labelP); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TreeNode@ImGui@@YA_NPEBD0ZZ", ExactSpelling = true)]
        private static extern byte TreeNode_PInvoke(byte* str_id, byte* fmt);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNode(byte* str_id, byte* fmt)
        {
            byte __result;

            __result = TreeNode_PInvoke(str_id, fmt);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNode(DearImGuiInterpolatedStringHandler str_id, DearImGuiInterpolatedStringHandler fmt)
        {
            byte __result;

            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { __result = TreeNode_PInvoke(__str_idP, __fmtP); }

            str_id.Dispose();
            fmt.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TreeNode@ImGui@@YA_NPEBXPEBDZZ", ExactSpelling = true)]
        private static extern byte TreeNode_PInvoke(void* ptr_id, byte* fmt);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNode(void* ptr_id, byte* fmt)
        {
            byte __result;

            __result = TreeNode_PInvoke(ptr_id, fmt);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNode(void* ptr_id, DearImGuiInterpolatedStringHandler fmt)
        {
            byte __result;

            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { __result = TreeNode_PInvoke(ptr_id, __fmtP); }

            fmt.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TreeNodeV@ImGui@@YA_NPEBD0PEAD@Z", ExactSpelling = true)]
        private static extern byte TreeNodeV_PInvoke(byte* str_id, byte* fmt, byte* args);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNodeV(byte* str_id, byte* fmt, byte* args)
        {
            byte __result;

            __result = TreeNodeV_PInvoke(str_id, fmt, args);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNodeV(DearImGuiInterpolatedStringHandler str_id, DearImGuiInterpolatedStringHandler fmt, byte* args)
        {
            byte __result;

            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { __result = TreeNodeV_PInvoke(__str_idP, __fmtP, args); }

            str_id.Dispose();
            fmt.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TreeNodeV@ImGui@@YA_NPEBXPEBDPEAD@Z", ExactSpelling = true)]
        private static extern byte TreeNodeV_PInvoke(void* ptr_id, byte* fmt, byte* args);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNodeV(void* ptr_id, byte* fmt, byte* args)
        {
            byte __result;

            __result = TreeNodeV_PInvoke(ptr_id, fmt, args);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNodeV(void* ptr_id, DearImGuiInterpolatedStringHandler fmt, byte* args)
        {
            byte __result;

            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { __result = TreeNodeV_PInvoke(ptr_id, __fmtP, args); }

            fmt.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TreeNodeEx@ImGui@@YA_NPEBDH@Z", ExactSpelling = true)]
        private static extern byte TreeNodeEx_PInvoke(byte* label, ImGuiTreeNodeFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNodeEx(byte* label, ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags.None)
        {
            byte __result;

            __result = TreeNodeEx_PInvoke(label, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNodeEx(DearImGuiInterpolatedStringHandler label, ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = TreeNodeEx_PInvoke(__labelP, flags); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TreeNodeEx@ImGui@@YA_NPEBDH0ZZ", ExactSpelling = true)]
        private static extern byte TreeNodeEx_PInvoke(byte* str_id, ImGuiTreeNodeFlags flags, byte* fmt);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNodeEx(byte* str_id, ImGuiTreeNodeFlags flags, byte* fmt)
        {
            byte __result;

            __result = TreeNodeEx_PInvoke(str_id, flags, fmt);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNodeEx(DearImGuiInterpolatedStringHandler str_id, ImGuiTreeNodeFlags flags, DearImGuiInterpolatedStringHandler fmt)
        {
            byte __result;

            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { __result = TreeNodeEx_PInvoke(__str_idP, flags, __fmtP); }

            str_id.Dispose();
            fmt.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TreeNodeEx@ImGui@@YA_NPEBXHPEBDZZ", ExactSpelling = true)]
        private static extern byte TreeNodeEx_PInvoke(void* ptr_id, ImGuiTreeNodeFlags flags, byte* fmt);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNodeEx(void* ptr_id, ImGuiTreeNodeFlags flags, byte* fmt)
        {
            byte __result;

            __result = TreeNodeEx_PInvoke(ptr_id, flags, fmt);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNodeEx(void* ptr_id, ImGuiTreeNodeFlags flags, DearImGuiInterpolatedStringHandler fmt)
        {
            byte __result;

            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { __result = TreeNodeEx_PInvoke(ptr_id, flags, __fmtP); }

            fmt.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TreeNodeExV@ImGui@@YA_NPEBDH0PEAD@Z", ExactSpelling = true)]
        private static extern byte TreeNodeExV_PInvoke(byte* str_id, ImGuiTreeNodeFlags flags, byte* fmt, byte* args);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNodeExV(byte* str_id, ImGuiTreeNodeFlags flags, byte* fmt, byte* args)
        {
            byte __result;

            __result = TreeNodeExV_PInvoke(str_id, flags, fmt, args);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNodeExV(DearImGuiInterpolatedStringHandler str_id, ImGuiTreeNodeFlags flags, DearImGuiInterpolatedStringHandler fmt, byte* args)
        {
            byte __result;

            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { __result = TreeNodeExV_PInvoke(__str_idP, flags, __fmtP, args); }

            str_id.Dispose();
            fmt.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TreeNodeExV@ImGui@@YA_NPEBXHPEBDPEAD@Z", ExactSpelling = true)]
        private static extern byte TreeNodeExV_PInvoke(void* ptr_id, ImGuiTreeNodeFlags flags, byte* fmt, byte* args);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNodeExV(void* ptr_id, ImGuiTreeNodeFlags flags, byte* fmt, byte* args)
        {
            byte __result;

            __result = TreeNodeExV_PInvoke(ptr_id, flags, fmt, args);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNodeExV(void* ptr_id, ImGuiTreeNodeFlags flags, DearImGuiInterpolatedStringHandler fmt, byte* args)
        {
            byte __result;

            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { __result = TreeNodeExV_PInvoke(ptr_id, flags, __fmtP, args); }

            fmt.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TreePush@ImGui@@YAXPEBD@Z", ExactSpelling = true)]
        public static extern void TreePush(byte* str_id);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TreePush(DearImGuiInterpolatedStringHandler str_id)
        {
            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            { TreePush(__str_idP); }

            str_id.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TreePush@ImGui@@YAXPEBX@Z", ExactSpelling = true)]
        public static extern void TreePush(void* ptr_id = null);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TreePop@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void TreePop();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ", ExactSpelling = true)]
        public static extern float GetTreeNodeToLabelSpacing();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CollapsingHeader@ImGui@@YA_NPEBDH@Z", ExactSpelling = true)]
        private static extern byte CollapsingHeader_PInvoke(byte* label, ImGuiTreeNodeFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool CollapsingHeader(byte* label, ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags.None)
        {
            byte __result;

            __result = CollapsingHeader_PInvoke(label, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool CollapsingHeader(DearImGuiInterpolatedStringHandler label, ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = CollapsingHeader_PInvoke(__labelP, flags); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CollapsingHeader@ImGui@@YA_NPEBDPEA_NH@Z", ExactSpelling = true)]
        private static extern byte CollapsingHeader_PInvoke(byte* label, bool* p_visible, ImGuiTreeNodeFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool CollapsingHeader(byte* label, bool* p_visible, ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags.None)
        {
            byte __result;

            __result = CollapsingHeader_PInvoke(label, p_visible, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool CollapsingHeader(DearImGuiInterpolatedStringHandler label, bool* p_visible, ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = CollapsingHeader_PInvoke(__labelP, p_visible, flags); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetNextItemOpen@ImGui@@YAX_NH@Z", ExactSpelling = true)]
        private static extern void SetNextItemOpen_PInvoke(byte is_open, ImGuiCond cond);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetNextItemOpen(bool is_open, ImGuiCond cond = ImGuiCond.None)
        {
            SetNextItemOpen_PInvoke(Unsafe.As<bool, byte>(ref is_open), cond);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern byte Selectable_PInvoke(byte* label, byte selected, ImGuiSelectableFlags flags, Vector2* size);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Selectable(byte* label, bool selected, ImGuiSelectableFlags flags, in Vector2 size)
        {
            byte __result;

            fixed (Vector2* __sizeP = &size)
            { __result = Selectable_PInvoke(label, Unsafe.As<bool, byte>(ref selected), flags, __sizeP); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Selectable(DearImGuiInterpolatedStringHandler label, bool selected, ImGuiSelectableFlags flags, in Vector2 size)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (Vector2* __sizeP = &size)
            { __result = Selectable_PInvoke(__labelP, Unsafe.As<bool, byte>(ref selected), flags, __sizeP); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Selectable@ImGui@@YA_NPEBDPEA_NHAEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern byte Selectable_PInvoke(byte* label, bool* p_selected, ImGuiSelectableFlags flags, Vector2* size);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Selectable(byte* label, bool* p_selected, ImGuiSelectableFlags flags, in Vector2 size)
        {
            byte __result;

            fixed (Vector2* __sizeP = &size)
            { __result = Selectable_PInvoke(label, p_selected, flags, __sizeP); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Selectable(DearImGuiInterpolatedStringHandler label, bool* p_selected, ImGuiSelectableFlags flags, in Vector2 size)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (Vector2* __sizeP = &size)
            { __result = Selectable_PInvoke(__labelP, p_selected, flags, __sizeP); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern byte BeginListBox_PInvoke(byte* label, Vector2* size);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginListBox(byte* label, in Vector2 size)
        {
            byte __result;

            fixed (Vector2* __sizeP = &size)
            { __result = BeginListBox_PInvoke(label, __sizeP); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginListBox(DearImGuiInterpolatedStringHandler label, in Vector2 size)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (Vector2* __sizeP = &size)
            { __result = BeginListBox_PInvoke(__labelP, __sizeP); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndListBox@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndListBox();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ListBox@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z", ExactSpelling = true)]
        private static extern byte ListBox_PInvoke(byte* label, int* current_item, byte** items, int items_count, int height_in_items);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ListBox(byte* label, int* current_item, byte** items, int items_count, int height_in_items = -1)
        {
            byte __result;

            __result = ListBox_PInvoke(label, current_item, items, items_count, height_in_items);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ListBox(DearImGuiInterpolatedStringHandler label, int* current_item, byte** items, int items_count, int height_in_items = -1)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = ListBox_PInvoke(__labelP, current_item, items, items_count, height_in_items); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z", ExactSpelling = true)]
        private static extern byte ListBox_PInvoke(byte* label, int* current_item, delegate* unmanaged[Cdecl]<void*, int, byte**, NativeBoolean> items_getter, void* data, int items_count, int height_in_items);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ListBox(byte* label, int* current_item, delegate* unmanaged[Cdecl]<void*, int, byte**, NativeBoolean> items_getter, void* data, int items_count, int height_in_items = -1)
        {
            byte __result;

            __result = ListBox_PInvoke(label, current_item, items_getter, data, items_count, height_in_items);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ListBox(DearImGuiInterpolatedStringHandler label, int* current_item, delegate* unmanaged[Cdecl]<void*, int, byte**, NativeBoolean> items_getter, void* data, int items_count, int height_in_items = -1)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = ListBox_PInvoke(__labelP, current_item, items_getter, data, items_count, height_in_items); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PlotLines@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z", ExactSpelling = true)]
        public static extern void PlotLines(byte* label, float* values, int values_count, int values_offset, byte* overlay_text, float scale_min, float scale_max, Vector2 graph_size, int stride = 4);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void PlotLines(DearImGuiInterpolatedStringHandler label, float* values, int values_count, int values_offset, DearImGuiInterpolatedStringHandler overlay_text, float scale_min, float scale_max, Vector2 graph_size, int stride = 4)
        {
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __overlay_textP = overlay_text.NullTerminateAndGetString())
            { PlotLines(__labelP, values, values_count, values_offset, __overlay_textP, scale_min, scale_max, graph_size, stride); }

            label.Dispose();
            overlay_text.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PlotLines@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z", ExactSpelling = true)]
        public static extern void PlotLines(byte* label, delegate* unmanaged[Cdecl]<void*, int, float> values_getter, void* data, int values_count, int values_offset, byte* overlay_text, float scale_min, float scale_max, Vector2 graph_size);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void PlotLines(DearImGuiInterpolatedStringHandler label, delegate* unmanaged[Cdecl]<void*, int, float> values_getter, void* data, int values_count, int values_offset, DearImGuiInterpolatedStringHandler overlay_text, float scale_min, float scale_max, Vector2 graph_size)
        {
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __overlay_textP = overlay_text.NullTerminateAndGetString())
            { PlotLines(__labelP, values_getter, data, values_count, values_offset, __overlay_textP, scale_min, scale_max, graph_size); }

            label.Dispose();
            overlay_text.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PlotHistogram@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z", ExactSpelling = true)]
        public static extern void PlotHistogram(byte* label, float* values, int values_count, int values_offset, byte* overlay_text, float scale_min, float scale_max, Vector2 graph_size, int stride = 4);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void PlotHistogram(DearImGuiInterpolatedStringHandler label, float* values, int values_count, int values_offset, DearImGuiInterpolatedStringHandler overlay_text, float scale_min, float scale_max, Vector2 graph_size, int stride = 4)
        {
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __overlay_textP = overlay_text.NullTerminateAndGetString())
            { PlotHistogram(__labelP, values, values_count, values_offset, __overlay_textP, scale_min, scale_max, graph_size, stride); }

            label.Dispose();
            overlay_text.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PlotHistogram@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z", ExactSpelling = true)]
        public static extern void PlotHistogram(byte* label, delegate* unmanaged[Cdecl]<void*, int, float> values_getter, void* data, int values_count, int values_offset, byte* overlay_text, float scale_min, float scale_max, Vector2 graph_size);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void PlotHistogram(DearImGuiInterpolatedStringHandler label, delegate* unmanaged[Cdecl]<void*, int, float> values_getter, void* data, int values_count, int values_offset, DearImGuiInterpolatedStringHandler overlay_text, float scale_min, float scale_max, Vector2 graph_size)
        {
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __overlay_textP = overlay_text.NullTerminateAndGetString())
            { PlotHistogram(__labelP, values_getter, data, values_count, values_offset, __overlay_textP, scale_min, scale_max, graph_size); }

            label.Dispose();
            overlay_text.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Value@ImGui@@YAXPEBD_N@Z", ExactSpelling = true)]
        private static extern void Value_PInvoke(byte* prefix, byte b);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Value(byte* prefix, bool b)
        {
            Value_PInvoke(prefix, Unsafe.As<bool, byte>(ref b));
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Value(DearImGuiInterpolatedStringHandler prefix, bool b)
        {
            fixed (byte* __prefixP = prefix.NullTerminateAndGetString())
            { Value_PInvoke(__prefixP, Unsafe.As<bool, byte>(ref b)); }

            prefix.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Value@ImGui@@YAXPEBDH@Z", ExactSpelling = true)]
        public static extern void Value(byte* prefix, int v);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Value(DearImGuiInterpolatedStringHandler prefix, int v)
        {
            fixed (byte* __prefixP = prefix.NullTerminateAndGetString())
            { Value(__prefixP, v); }

            prefix.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Value@ImGui@@YAXPEBDI@Z", ExactSpelling = true)]
        public static extern void Value(byte* prefix, uint v);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Value(DearImGuiInterpolatedStringHandler prefix, uint v)
        {
            fixed (byte* __prefixP = prefix.NullTerminateAndGetString())
            { Value(__prefixP, v); }

            prefix.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Value@ImGui@@YAXPEBDM0@Z", ExactSpelling = true)]
        public static extern void Value(byte* prefix, float v, byte* float_format = null);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Value(DearImGuiInterpolatedStringHandler prefix, float v, DearImGuiInterpolatedStringHandler float_format)
        {
            fixed (byte* __prefixP = prefix.NullTerminateAndGetString())
            fixed (byte* __float_formatP = float_format.NullTerminateAndGetString())
            { Value(__prefixP, v, __float_formatP); }

            prefix.Dispose();
            float_format.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginMenuBar@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte BeginMenuBar_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginMenuBar()
        {
            byte __result;

            __result = BeginMenuBar_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndMenuBar@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndMenuBar();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginMainMenuBar@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte BeginMainMenuBar_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginMainMenuBar()
        {
            byte __result;

            __result = BeginMainMenuBar_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndMainMenuBar@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndMainMenuBar();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginMenu@ImGui@@YA_NPEBD_N@Z", ExactSpelling = true)]
        private static extern byte BeginMenu_PInvoke(byte* label, byte enabled);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginMenu(byte* label, bool enabled = true)
        {
            byte __result;

            __result = BeginMenu_PInvoke(label, Unsafe.As<bool, byte>(ref enabled));

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginMenu(DearImGuiInterpolatedStringHandler label, bool enabled = true)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = BeginMenu_PInvoke(__labelP, Unsafe.As<bool, byte>(ref enabled)); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndMenu@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndMenu();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?MenuItem@ImGui@@YA_NPEBD0_N1@Z", ExactSpelling = true)]
        private static extern byte MenuItem_PInvoke(byte* label, byte* shortcut, byte selected, byte enabled);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool MenuItem(byte* label, byte* shortcut = null, bool selected = false, bool enabled = true)
        {
            byte __result;

            __result = MenuItem_PInvoke(label, shortcut, Unsafe.As<bool, byte>(ref selected), Unsafe.As<bool, byte>(ref enabled));

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool MenuItem(DearImGuiInterpolatedStringHandler label, DearImGuiInterpolatedStringHandler shortcut, bool selected = false, bool enabled = true)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __shortcutP = shortcut.NullTerminateAndGetString())
            { __result = MenuItem_PInvoke(__labelP, __shortcutP, Unsafe.As<bool, byte>(ref selected), Unsafe.As<bool, byte>(ref enabled)); }

            label.Dispose();
            shortcut.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?MenuItem@ImGui@@YA_NPEBD0PEA_N_N@Z", ExactSpelling = true)]
        private static extern byte MenuItem_PInvoke(byte* label, byte* shortcut, bool* p_selected, byte enabled);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool MenuItem(byte* label, byte* shortcut, bool* p_selected, bool enabled = true)
        {
            byte __result;

            __result = MenuItem_PInvoke(label, shortcut, p_selected, Unsafe.As<bool, byte>(ref enabled));

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool MenuItem(DearImGuiInterpolatedStringHandler label, DearImGuiInterpolatedStringHandler shortcut, bool* p_selected, bool enabled = true)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __shortcutP = shortcut.NullTerminateAndGetString())
            { __result = MenuItem_PInvoke(__labelP, __shortcutP, p_selected, Unsafe.As<bool, byte>(ref enabled)); }

            label.Dispose();
            shortcut.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginTooltip@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void BeginTooltip();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndTooltip@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndTooltip();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetTooltip@ImGui@@YAXPEBDZZ", ExactSpelling = true)]
        public static extern void SetTooltip(byte* fmt);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetTooltip(DearImGuiInterpolatedStringHandler fmt)
        {
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { SetTooltip(__fmtP); }

            fmt.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetTooltipV@ImGui@@YAXPEBDPEAD@Z", ExactSpelling = true)]
        public static extern void SetTooltipV(byte* fmt, byte* args);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetTooltipV(DearImGuiInterpolatedStringHandler fmt, byte* args)
        {
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { SetTooltipV(__fmtP, args); }

            fmt.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginPopup@ImGui@@YA_NPEBDH@Z", ExactSpelling = true)]
        private static extern byte BeginPopup_PInvoke(byte* str_id, ImGuiWindowFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginPopup(byte* str_id, ImGuiWindowFlags flags = ImGuiWindowFlags.None)
        {
            byte __result;

            __result = BeginPopup_PInvoke(str_id, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginPopup(DearImGuiInterpolatedStringHandler str_id, ImGuiWindowFlags flags = ImGuiWindowFlags.None)
        {
            byte __result;

            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            { __result = BeginPopup_PInvoke(__str_idP, flags); }

            str_id.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginPopupModal@ImGui@@YA_NPEBDPEA_NH@Z", ExactSpelling = true)]
        private static extern byte BeginPopupModal_PInvoke(byte* name, bool* p_open, ImGuiWindowFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginPopupModal(byte* name, bool* p_open = null, ImGuiWindowFlags flags = ImGuiWindowFlags.None)
        {
            byte __result;

            __result = BeginPopupModal_PInvoke(name, p_open, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginPopupModal(DearImGuiInterpolatedStringHandler name, bool* p_open = null, ImGuiWindowFlags flags = ImGuiWindowFlags.None)
        {
            byte __result;

            fixed (byte* __nameP = name.NullTerminateAndGetString())
            { __result = BeginPopupModal_PInvoke(__nameP, p_open, flags); }

            name.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndPopup@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndPopup();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?OpenPopup@ImGui@@YAXPEBDH@Z", ExactSpelling = true)]
        public static extern void OpenPopup(byte* str_id, ImGuiPopupFlags popup_flags = ImGuiPopupFlags.None);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void OpenPopup(DearImGuiInterpolatedStringHandler str_id, ImGuiPopupFlags popup_flags = ImGuiPopupFlags.None)
        {
            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            { OpenPopup(__str_idP, popup_flags); }

            str_id.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?OpenPopup@ImGui@@YAXIH@Z", ExactSpelling = true)]
        public static extern void OpenPopup(uint id, ImGuiPopupFlags popup_flags = ImGuiPopupFlags.None);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?OpenPopupOnItemClick@ImGui@@YAXPEBDH@Z", ExactSpelling = true)]
        public static extern void OpenPopupOnItemClick(byte* str_id = null, ImGuiPopupFlags popup_flags = ImGuiPopupFlags.MouseButtonRight);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void OpenPopupOnItemClick(DearImGuiInterpolatedStringHandler str_id, ImGuiPopupFlags popup_flags = ImGuiPopupFlags.MouseButtonRight)
        {
            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            { OpenPopupOnItemClick(__str_idP, popup_flags); }

            str_id.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CloseCurrentPopup@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void CloseCurrentPopup();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginPopupContextItem@ImGui@@YA_NPEBDH@Z", ExactSpelling = true)]
        private static extern byte BeginPopupContextItem_PInvoke(byte* str_id, ImGuiPopupFlags popup_flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginPopupContextItem(byte* str_id = null, ImGuiPopupFlags popup_flags = ImGuiPopupFlags.MouseButtonRight)
        {
            byte __result;

            __result = BeginPopupContextItem_PInvoke(str_id, popup_flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginPopupContextItem(DearImGuiInterpolatedStringHandler str_id, ImGuiPopupFlags popup_flags = ImGuiPopupFlags.MouseButtonRight)
        {
            byte __result;

            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            { __result = BeginPopupContextItem_PInvoke(__str_idP, popup_flags); }

            str_id.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginPopupContextWindow@ImGui@@YA_NPEBDH@Z", ExactSpelling = true)]
        private static extern byte BeginPopupContextWindow_PInvoke(byte* str_id, ImGuiPopupFlags popup_flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginPopupContextWindow(byte* str_id = null, ImGuiPopupFlags popup_flags = ImGuiPopupFlags.MouseButtonRight)
        {
            byte __result;

            __result = BeginPopupContextWindow_PInvoke(str_id, popup_flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginPopupContextWindow(DearImGuiInterpolatedStringHandler str_id, ImGuiPopupFlags popup_flags = ImGuiPopupFlags.MouseButtonRight)
        {
            byte __result;

            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            { __result = BeginPopupContextWindow_PInvoke(__str_idP, popup_flags); }

            str_id.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginPopupContextVoid@ImGui@@YA_NPEBDH@Z", ExactSpelling = true)]
        private static extern byte BeginPopupContextVoid_PInvoke(byte* str_id, ImGuiPopupFlags popup_flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginPopupContextVoid(byte* str_id = null, ImGuiPopupFlags popup_flags = ImGuiPopupFlags.MouseButtonRight)
        {
            byte __result;

            __result = BeginPopupContextVoid_PInvoke(str_id, popup_flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginPopupContextVoid(DearImGuiInterpolatedStringHandler str_id, ImGuiPopupFlags popup_flags = ImGuiPopupFlags.MouseButtonRight)
        {
            byte __result;

            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            { __result = BeginPopupContextVoid_PInvoke(__str_idP, popup_flags); }

            str_id.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsPopupOpen@ImGui@@YA_NPEBDH@Z", ExactSpelling = true)]
        private static extern byte IsPopupOpen_PInvoke(byte* str_id, ImGuiPopupFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPopupOpen(byte* str_id, ImGuiPopupFlags flags = ImGuiPopupFlags.None)
        {
            byte __result;

            __result = IsPopupOpen_PInvoke(str_id, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPopupOpen(DearImGuiInterpolatedStringHandler str_id, ImGuiPopupFlags flags = ImGuiPopupFlags.None)
        {
            byte __result;

            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            { __result = IsPopupOpen_PInvoke(__str_idP, flags); }

            str_id.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginTable@ImGui@@YA_NPEBDHHAEBUImVec2@@M@Z", ExactSpelling = true)]
        private static extern byte BeginTable_PInvoke(byte* str_id, int column, ImGuiTableFlags flags, Vector2* outer_size, float inner_width);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginTable(byte* str_id, int column, ImGuiTableFlags flags, in Vector2 outer_size, float inner_width = 0f)
        {
            byte __result;

            fixed (Vector2* __outer_sizeP = &outer_size)
            { __result = BeginTable_PInvoke(str_id, column, flags, __outer_sizeP, inner_width); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginTable(DearImGuiInterpolatedStringHandler str_id, int column, ImGuiTableFlags flags, in Vector2 outer_size, float inner_width = 0f)
        {
            byte __result;

            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            fixed (Vector2* __outer_sizeP = &outer_size)
            { __result = BeginTable_PInvoke(__str_idP, column, flags, __outer_sizeP, inner_width); }

            str_id.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndTable@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndTable();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableNextRow@ImGui@@YAXHM@Z", ExactSpelling = true)]
        public static extern void TableNextRow(ImGuiTableRowFlags row_flags = ImGuiTableRowFlags.None, float min_row_height = 0f);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableNextColumn@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte TableNextColumn_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TableNextColumn()
        {
            byte __result;

            __result = TableNextColumn_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableSetColumnIndex@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte TableSetColumnIndex_PInvoke(int column_n);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TableSetColumnIndex(int column_n)
        {
            byte __result;

            __result = TableSetColumnIndex_PInvoke(column_n);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableSetupColumn@ImGui@@YAXPEBDHMI@Z", ExactSpelling = true)]
        public static extern void TableSetupColumn(byte* label, ImGuiTableColumnFlags flags = ImGuiTableColumnFlags.None, float init_width_or_weight = 0f, uint user_id = 0);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TableSetupColumn(DearImGuiInterpolatedStringHandler label, ImGuiTableColumnFlags flags = ImGuiTableColumnFlags.None, float init_width_or_weight = 0f, uint user_id = 0)
        {
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { TableSetupColumn(__labelP, flags, init_width_or_weight, user_id); }

            label.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableSetupScrollFreeze@ImGui@@YAXHH@Z", ExactSpelling = true)]
        public static extern void TableSetupScrollFreeze(int cols, int rows);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableHeadersRow@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void TableHeadersRow();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableHeader@ImGui@@YAXPEBD@Z", ExactSpelling = true)]
        public static extern void TableHeader(byte* label);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TableHeader(DearImGuiInterpolatedStringHandler label)
        {
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { TableHeader(__labelP); }

            label.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGetSortSpecs@ImGui@@YAPEAUImGuiTableSortSpecs@@XZ", ExactSpelling = true)]
        public static extern ImGuiTableSortSpecs* TableGetSortSpecs();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGetColumnCount@ImGui@@YAHXZ", ExactSpelling = true)]
        public static extern int TableGetColumnCount();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGetColumnIndex@ImGui@@YAHXZ", ExactSpelling = true)]
        public static extern int TableGetColumnIndex();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGetRowIndex@ImGui@@YAHXZ", ExactSpelling = true)]
        public static extern int TableGetRowIndex();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGetColumnName@ImGui@@YAPEBDH@Z", ExactSpelling = true)]
        public static extern byte* TableGetColumnName(int column_n = -1);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGetColumnFlags@ImGui@@YAHH@Z", ExactSpelling = true)]
        public static extern ImGuiTableColumnFlags TableGetColumnFlags(int column_n = -1);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableSetColumnEnabled@ImGui@@YAXH_N@Z", ExactSpelling = true)]
        private static extern void TableSetColumnEnabled_PInvoke(int column_n, byte v);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TableSetColumnEnabled(int column_n, bool v)
        {
            TableSetColumnEnabled_PInvoke(column_n, Unsafe.As<bool, byte>(ref v));
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableSetBgColor@ImGui@@YAXHIH@Z", ExactSpelling = true)]
        public static extern void TableSetBgColor(ImGuiTableBgTarget target, uint color, int column_n = -1);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Columns@ImGui@@YAXHPEBD_N@Z", ExactSpelling = true)]
        private static extern void Columns_PInvoke(int count, byte* id, byte border);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Columns(int count = 1, byte* id = null, bool border = true)
        {
            Columns_PInvoke(count, id, Unsafe.As<bool, byte>(ref border));
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Columns(int count, DearImGuiInterpolatedStringHandler id, bool border = true)
        {
            fixed (byte* __idP = id.NullTerminateAndGetString())
            { Columns_PInvoke(count, __idP, Unsafe.As<bool, byte>(ref border)); }

            id.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?NextColumn@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void NextColumn();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetColumnIndex@ImGui@@YAHXZ", ExactSpelling = true)]
        public static extern int GetColumnIndex();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetColumnWidth@ImGui@@YAMH@Z", ExactSpelling = true)]
        public static extern float GetColumnWidth(int column_index = -1);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetColumnWidth@ImGui@@YAXHM@Z", ExactSpelling = true)]
        public static extern void SetColumnWidth(int column_index, float width);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetColumnOffset@ImGui@@YAMH@Z", ExactSpelling = true)]
        public static extern float GetColumnOffset(int column_index = -1);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetColumnOffset@ImGui@@YAXHM@Z", ExactSpelling = true)]
        public static extern void SetColumnOffset(int column_index, float offset_x);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetColumnsCount@ImGui@@YAHXZ", ExactSpelling = true)]
        public static extern int GetColumnsCount();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginTabBar@ImGui@@YA_NPEBDH@Z", ExactSpelling = true)]
        private static extern byte BeginTabBar_PInvoke(byte* str_id, ImGuiTabBarFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginTabBar(byte* str_id, ImGuiTabBarFlags flags = ImGuiTabBarFlags.None)
        {
            byte __result;

            __result = BeginTabBar_PInvoke(str_id, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginTabBar(DearImGuiInterpolatedStringHandler str_id, ImGuiTabBarFlags flags = ImGuiTabBarFlags.None)
        {
            byte __result;

            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            { __result = BeginTabBar_PInvoke(__str_idP, flags); }

            str_id.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndTabBar@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndTabBar();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginTabItem@ImGui@@YA_NPEBDPEA_NH@Z", ExactSpelling = true)]
        private static extern byte BeginTabItem_PInvoke(byte* label, bool* p_open, ImGuiTabItemFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginTabItem(byte* label, bool* p_open = null, ImGuiTabItemFlags flags = ImGuiTabItemFlags.None)
        {
            byte __result;

            __result = BeginTabItem_PInvoke(label, p_open, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginTabItem(DearImGuiInterpolatedStringHandler label, bool* p_open = null, ImGuiTabItemFlags flags = ImGuiTabItemFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = BeginTabItem_PInvoke(__labelP, p_open, flags); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndTabItem@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndTabItem();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TabItemButton@ImGui@@YA_NPEBDH@Z", ExactSpelling = true)]
        private static extern byte TabItemButton_PInvoke(byte* label, ImGuiTabItemFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TabItemButton(byte* label, ImGuiTabItemFlags flags = ImGuiTabItemFlags.None)
        {
            byte __result;

            __result = TabItemButton_PInvoke(label, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TabItemButton(DearImGuiInterpolatedStringHandler label, ImGuiTabItemFlags flags = ImGuiTabItemFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = TabItemButton_PInvoke(__labelP, flags); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetTabItemClosed@ImGui@@YAXPEBD@Z", ExactSpelling = true)]
        public static extern void SetTabItemClosed(byte* tab_or_docked_window_label);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetTabItemClosed(DearImGuiInterpolatedStringHandler tab_or_docked_window_label)
        {
            fixed (byte* __tab_or_docked_window_labelP = tab_or_docked_window_label.NullTerminateAndGetString())
            { SetTabItemClosed(__tab_or_docked_window_labelP); }

            tab_or_docked_window_label.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockSpace@ImGui@@YAIIAEBUImVec2@@HPEBUImGuiWindowClass@@@Z", ExactSpelling = true)]
        private static extern uint DockSpace_PInvoke(uint id, Vector2* size, ImGuiDockNodeFlags flags, ImGuiWindowClass* window_class);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint DockSpace(uint id, in Vector2 size, ImGuiDockNodeFlags flags = ImGuiDockNodeFlags.None, ImGuiWindowClass* window_class = null)
        {
            fixed (Vector2* __sizeP = &size)
            { return DockSpace_PInvoke(id, __sizeP, flags, window_class); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockSpaceOverViewport@ImGui@@YAIPEBUImGuiViewport@@HPEBUImGuiWindowClass@@@Z", ExactSpelling = true)]
        public static extern uint DockSpaceOverViewport(ImGuiViewport* viewport = null, ImGuiDockNodeFlags flags = ImGuiDockNodeFlags.None, ImGuiWindowClass* window_class = null);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetNextWindowDockID@ImGui@@YAXIH@Z", ExactSpelling = true)]
        public static extern void SetNextWindowDockID(uint dock_id, ImGuiCond cond = ImGuiCond.None);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetNextWindowClass@ImGui@@YAXPEBUImGuiWindowClass@@@Z", ExactSpelling = true)]
        public static extern void SetNextWindowClass(ImGuiWindowClass* window_class);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetWindowDockID@ImGui@@YAIXZ", ExactSpelling = true)]
        public static extern uint GetWindowDockID();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsWindowDocked@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte IsWindowDocked_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsWindowDocked()
        {
            byte __result;

            __result = IsWindowDocked_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?LogToTTY@ImGui@@YAXH@Z", ExactSpelling = true)]
        public static extern void LogToTTY(int auto_open_depth = -1);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?LogToFile@ImGui@@YAXHPEBD@Z", ExactSpelling = true)]
        public static extern void LogToFile(int auto_open_depth = -1, byte* filename = null);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogToFile(int auto_open_depth, DearImGuiInterpolatedStringHandler filename)
        {
            fixed (byte* __filenameP = filename.NullTerminateAndGetString())
            { LogToFile(auto_open_depth, __filenameP); }

            filename.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?LogToClipboard@ImGui@@YAXH@Z", ExactSpelling = true)]
        public static extern void LogToClipboard(int auto_open_depth = -1);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?LogFinish@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void LogFinish();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?LogButtons@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void LogButtons();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?LogText@ImGui@@YAXPEBDZZ", ExactSpelling = true)]
        public static extern void LogText(byte* fmt);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogText(DearImGuiInterpolatedStringHandler fmt)
        {
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { LogText(__fmtP); }

            fmt.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?LogTextV@ImGui@@YAXPEBDPEAD@Z", ExactSpelling = true)]
        public static extern void LogTextV(byte* fmt, byte* args);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogTextV(DearImGuiInterpolatedStringHandler fmt, byte* args)
        {
            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { LogTextV(__fmtP, args); }

            fmt.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginDragDropSource@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte BeginDragDropSource_PInvoke(ImGuiDragDropFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginDragDropSource(ImGuiDragDropFlags flags = ImGuiDragDropFlags.None)
        {
            byte __result;

            __result = BeginDragDropSource_PInvoke(flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetDragDropPayload@ImGui@@YA_NPEBDPEBX_KH@Z", ExactSpelling = true)]
        private static extern byte SetDragDropPayload_PInvoke(byte* type, void* data, nuint sz, ImGuiCond cond);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SetDragDropPayload(byte* type, void* data, nuint sz, ImGuiCond cond = ImGuiCond.None)
        {
            byte __result;

            __result = SetDragDropPayload_PInvoke(type, data, sz, cond);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SetDragDropPayload(DearImGuiInterpolatedStringHandler type, void* data, nuint sz, ImGuiCond cond = ImGuiCond.None)
        {
            byte __result;

            fixed (byte* __typeP = type.NullTerminateAndGetString())
            { __result = SetDragDropPayload_PInvoke(__typeP, data, sz, cond); }

            type.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndDragDropSource@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndDragDropSource();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginDragDropTarget@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte BeginDragDropTarget_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginDragDropTarget()
        {
            byte __result;

            __result = BeginDragDropTarget_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?AcceptDragDropPayload@ImGui@@YAPEBUImGuiPayload@@PEBDH@Z", ExactSpelling = true)]
        public static extern ImGuiPayload* AcceptDragDropPayload(byte* type, ImGuiDragDropFlags flags = ImGuiDragDropFlags.None);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ImGuiPayload* AcceptDragDropPayload(DearImGuiInterpolatedStringHandler type, ImGuiDragDropFlags flags = ImGuiDragDropFlags.None)
        {
            ImGuiPayload* __result;

            fixed (byte* __typeP = type.NullTerminateAndGetString())
            { __result = AcceptDragDropPayload(__typeP, flags); }

            type.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndDragDropTarget@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndDragDropTarget();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetDragDropPayload@ImGui@@YAPEBUImGuiPayload@@XZ", ExactSpelling = true)]
        public static extern ImGuiPayload* GetDragDropPayload();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginDisabled@ImGui@@YAX_N@Z", ExactSpelling = true)]
        private static extern void BeginDisabled_PInvoke(byte disabled);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void BeginDisabled(bool disabled = true)
        {
            BeginDisabled_PInvoke(Unsafe.As<bool, byte>(ref disabled));
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndDisabled@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndDisabled();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z", ExactSpelling = true)]
        private static extern void PushClipRect_PInvoke(Vector2* clip_rect_min, Vector2* clip_rect_max, byte intersect_with_current_clip_rect);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void PushClipRect(in Vector2 clip_rect_min, in Vector2 clip_rect_max, bool intersect_with_current_clip_rect)
        {
            fixed (Vector2* __clip_rect_minP = &clip_rect_min)
            fixed (Vector2* __clip_rect_maxP = &clip_rect_max)
            { PushClipRect_PInvoke(__clip_rect_minP, __clip_rect_maxP, Unsafe.As<bool, byte>(ref intersect_with_current_clip_rect)); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PopClipRect@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void PopClipRect();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetItemDefaultFocus@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void SetItemDefaultFocus();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetKeyboardFocusHere@ImGui@@YAXH@Z", ExactSpelling = true)]
        public static extern void SetKeyboardFocusHere(int offset = 0);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsItemHovered@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte IsItemHovered_PInvoke(ImGuiHoveredFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsItemHovered(ImGuiHoveredFlags flags = ImGuiHoveredFlags.None)
        {
            byte __result;

            __result = IsItemHovered_PInvoke(flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsItemActive@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte IsItemActive_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsItemActive()
        {
            byte __result;

            __result = IsItemActive_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsItemFocused@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte IsItemFocused_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsItemFocused()
        {
            byte __result;

            __result = IsItemFocused_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsItemClicked@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte IsItemClicked_PInvoke(ImGuiMouseButton mouse_button);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsItemClicked(ImGuiMouseButton mouse_button = ImGuiMouseButton.Left)
        {
            byte __result;

            __result = IsItemClicked_PInvoke(mouse_button);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsItemVisible@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte IsItemVisible_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsItemVisible()
        {
            byte __result;

            __result = IsItemVisible_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsItemEdited@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte IsItemEdited_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsItemEdited()
        {
            byte __result;

            __result = IsItemEdited_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsItemActivated@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte IsItemActivated_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsItemActivated()
        {
            byte __result;

            __result = IsItemActivated_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsItemDeactivated@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte IsItemDeactivated_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsItemDeactivated()
        {
            byte __result;

            __result = IsItemDeactivated_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsItemDeactivatedAfterEdit@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte IsItemDeactivatedAfterEdit_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsItemDeactivatedAfterEdit()
        {
            byte __result;

            __result = IsItemDeactivatedAfterEdit_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsItemToggledOpen@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte IsItemToggledOpen_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsItemToggledOpen()
        {
            byte __result;

            __result = IsItemToggledOpen_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsAnyItemHovered@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte IsAnyItemHovered_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsAnyItemHovered()
        {
            byte __result;

            __result = IsAnyItemHovered_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsAnyItemActive@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte IsAnyItemActive_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsAnyItemActive()
        {
            byte __result;

            __result = IsAnyItemActive_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsAnyItemFocused@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte IsAnyItemFocused_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsAnyItemFocused()
        {
            byte __result;

            __result = IsAnyItemFocused_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetItemRectMin@ImGui@@YA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetItemRectMin_PInvoke(Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetItemRectMin()
        {
            Vector2 __returnBuffer;

            GetItemRectMin_PInvoke(&__returnBuffer);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetItemRectMax@ImGui@@YA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetItemRectMax_PInvoke(Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetItemRectMax()
        {
            Vector2 __returnBuffer;

            GetItemRectMax_PInvoke(&__returnBuffer);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetItemRectSize@ImGui@@YA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetItemRectSize_PInvoke(Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetItemRectSize()
        {
            Vector2 __returnBuffer;

            GetItemRectSize_PInvoke(&__returnBuffer);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetItemAllowOverlap@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void SetItemAllowOverlap();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetMainViewport@ImGui@@YAPEAUImGuiViewport@@XZ", ExactSpelling = true)]
        public static extern ImGuiViewport* GetMainViewport();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsRectVisible@ImGui@@YA_NAEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern byte IsRectVisible_PInvoke(Vector2* size);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsRectVisible(in Vector2 size)
        {
            byte __result;

            fixed (Vector2* __sizeP = &size)
            { __result = IsRectVisible_PInvoke(__sizeP); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsRectVisible@ImGui@@YA_NAEBUImVec2@@0@Z", ExactSpelling = true)]
        private static extern byte IsRectVisible_PInvoke(Vector2* rect_min, Vector2* rect_max);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsRectVisible(in Vector2 rect_min, in Vector2 rect_max)
        {
            byte __result;

            fixed (Vector2* __rect_minP = &rect_min)
            fixed (Vector2* __rect_maxP = &rect_max)
            { __result = IsRectVisible_PInvoke(__rect_minP, __rect_maxP); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetTime@ImGui@@YANXZ", ExactSpelling = true)]
        public static extern double GetTime();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetFrameCount@ImGui@@YAHXZ", ExactSpelling = true)]
        public static extern int GetFrameCount();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetBackgroundDrawList@ImGui@@YAPEAUImDrawList@@XZ", ExactSpelling = true)]
        public static extern ImDrawList* GetBackgroundDrawList();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetForegroundDrawList@ImGui@@YAPEAUImDrawList@@XZ", ExactSpelling = true)]
        public static extern ImDrawList* GetForegroundDrawList();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetBackgroundDrawList@ImGui@@YAPEAUImDrawList@@PEAUImGuiViewport@@@Z", ExactSpelling = true)]
        public static extern ImDrawList* GetBackgroundDrawList(ImGuiViewport* viewport);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetForegroundDrawList@ImGui@@YAPEAUImDrawList@@PEAUImGuiViewport@@@Z", ExactSpelling = true)]
        public static extern ImDrawList* GetForegroundDrawList(ImGuiViewport* viewport);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetDrawListSharedData@ImGui@@YAPEAUImDrawListSharedData@@XZ", ExactSpelling = true)]
        public static extern ImDrawListSharedData* GetDrawListSharedData();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetStyleColorName@ImGui@@YAPEBDH@Z", ExactSpelling = true)]
        public static extern byte* GetStyleColorName(ImGuiCol idx);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetStateStorage@ImGui@@YAXPEAUImGuiStorage@@@Z", ExactSpelling = true)]
        public static extern void SetStateStorage(ImGuiStorage* storage);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetStateStorage@ImGui@@YAPEAUImGuiStorage@@XZ", ExactSpelling = true)]
        public static extern ImGuiStorage* GetStateStorage();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginChildFrame@ImGui@@YA_NIAEBUImVec2@@H@Z", ExactSpelling = true)]
        private static extern byte BeginChildFrame_PInvoke(uint id, Vector2* size, ImGuiWindowFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginChildFrame(uint id, in Vector2 size, ImGuiWindowFlags flags = ImGuiWindowFlags.None)
        {
            byte __result;

            fixed (Vector2* __sizeP = &size)
            { __result = BeginChildFrame_PInvoke(id, __sizeP, flags); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndChildFrame@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndChildFrame();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z", ExactSpelling = true)]
        private static extern Vector2* CalcTextSize_PInvoke(Vector2* __returnBuffer, byte* text, byte* text_end, byte hide_text_after_double_hash, float wrap_width);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 CalcTextSize(byte* text, byte* text_end = null, bool hide_text_after_double_hash = false, float wrap_width = -1f)
        {
            Vector2 __returnBuffer;

            CalcTextSize_PInvoke(&__returnBuffer, text, text_end, Unsafe.As<bool, byte>(ref hide_text_after_double_hash), wrap_width);

            return __returnBuffer;
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 CalcTextSize(DearImGuiInterpolatedStringHandler text, bool hide_text_after_double_hash = false, float wrap_width = -1f)
        {
            Vector2 __returnBuffer;
            ReadOnlySpan<byte> __text = text.NullTerminateAndGetString();

            fixed (byte* __textP = __text)
            { CalcTextSize_PInvoke(&__returnBuffer, __textP, __textP + __text.Length, Unsafe.As<bool, byte>(ref hide_text_after_double_hash), wrap_width); }

            text.Dispose();
            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ColorConvertU32ToFloat4@ImGui@@YA?AUImVec4@@I@Z", ExactSpelling = true)]
        private static extern Vector4* ColorConvertU32ToFloat4_PInvoke(Vector4* __returnBuffer, uint @in);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 ColorConvertU32ToFloat4(uint @in)
        {
            Vector4 __returnBuffer;

            ColorConvertU32ToFloat4_PInvoke(&__returnBuffer, @in);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z", ExactSpelling = true)]
        private static extern uint ColorConvertFloat4ToU32_PInvoke(Vector4* @in);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint ColorConvertFloat4ToU32(in Vector4 @in)
        {
            fixed (Vector4* __inP = &@in)
            { return ColorConvertFloat4ToU32_PInvoke(__inP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ColorConvertRGBtoHSV@ImGui@@YAXMMMAEAM00@Z", ExactSpelling = true)]
        private static extern void ColorConvertRGBtoHSV_PInvoke(float r, float g, float b, float* out_h, float* out_s, float* out_v);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float out_h, ref float out_s, ref float out_v)
        {
            fixed (float* __out_hP = &out_h)
            fixed (float* __out_sP = &out_s)
            fixed (float* __out_vP = &out_v)
            { ColorConvertRGBtoHSV_PInvoke(r, g, b, __out_hP, __out_sP, __out_vP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z", ExactSpelling = true)]
        private static extern void ColorConvertHSVtoRGB_PInvoke(float h, float s, float v, float* out_r, float* out_g, float* out_b);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float out_r, ref float out_g, ref float out_b)
        {
            fixed (float* __out_rP = &out_r)
            fixed (float* __out_gP = &out_g)
            fixed (float* __out_bP = &out_b)
            { ColorConvertHSVtoRGB_PInvoke(h, s, v, __out_rP, __out_gP, __out_bP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsKeyDown@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte IsKeyDown_PInvoke(ImGuiKey key);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsKeyDown(ImGuiKey key)
        {
            byte __result;

            __result = IsKeyDown_PInvoke(key);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsKeyPressed@ImGui@@YA_NH_N@Z", ExactSpelling = true)]
        private static extern byte IsKeyPressed_PInvoke(ImGuiKey key, byte repeat);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsKeyPressed(ImGuiKey key, bool repeat = true)
        {
            byte __result;

            __result = IsKeyPressed_PInvoke(key, Unsafe.As<bool, byte>(ref repeat));

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsKeyReleased@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte IsKeyReleased_PInvoke(ImGuiKey key);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsKeyReleased(ImGuiKey key)
        {
            byte __result;

            __result = IsKeyReleased_PInvoke(key);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetKeyPressedAmount@ImGui@@YAHHMM@Z", ExactSpelling = true)]
        public static extern int GetKeyPressedAmount(ImGuiKey key, float repeat_delay, float rate);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetKeyName@ImGui@@YAPEBDH@Z", ExactSpelling = true)]
        public static extern byte* GetKeyName(ImGuiKey key);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CaptureKeyboardFromApp@ImGui@@YAX_N@Z", ExactSpelling = true)]
        private static extern void CaptureKeyboardFromApp_PInvoke(byte want_capture_keyboard_value);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CaptureKeyboardFromApp(bool want_capture_keyboard_value = true)
        {
            CaptureKeyboardFromApp_PInvoke(Unsafe.As<bool, byte>(ref want_capture_keyboard_value));
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsMouseDown@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte IsMouseDown_PInvoke(ImGuiMouseButton button);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsMouseDown(ImGuiMouseButton button)
        {
            byte __result;

            __result = IsMouseDown_PInvoke(button);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsMouseClicked@ImGui@@YA_NH_N@Z", ExactSpelling = true)]
        private static extern byte IsMouseClicked_PInvoke(ImGuiMouseButton button, byte repeat);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsMouseClicked(ImGuiMouseButton button, bool repeat = false)
        {
            byte __result;

            __result = IsMouseClicked_PInvoke(button, Unsafe.As<bool, byte>(ref repeat));

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsMouseReleased@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte IsMouseReleased_PInvoke(ImGuiMouseButton button);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsMouseReleased(ImGuiMouseButton button)
        {
            byte __result;

            __result = IsMouseReleased_PInvoke(button);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsMouseDoubleClicked@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte IsMouseDoubleClicked_PInvoke(ImGuiMouseButton button);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsMouseDoubleClicked(ImGuiMouseButton button)
        {
            byte __result;

            __result = IsMouseDoubleClicked_PInvoke(button);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetMouseClickedCount@ImGui@@YAHH@Z", ExactSpelling = true)]
        public static extern int GetMouseClickedCount(ImGuiMouseButton button);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z", ExactSpelling = true)]
        private static extern byte IsMouseHoveringRect_PInvoke(Vector2* r_min, Vector2* r_max, byte clip);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsMouseHoveringRect(in Vector2 r_min, in Vector2 r_max, bool clip = true)
        {
            byte __result;

            fixed (Vector2* __r_minP = &r_min)
            fixed (Vector2* __r_maxP = &r_max)
            { __result = IsMouseHoveringRect_PInvoke(__r_minP, __r_maxP, Unsafe.As<bool, byte>(ref clip)); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern byte IsMousePosValid_PInvoke(Vector2* mouse_pos);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsMousePosValid(Vector2* mouse_pos = null)
        {
            byte __result;

            __result = IsMousePosValid_PInvoke(mouse_pos);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsAnyMouseDown@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte IsAnyMouseDown_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsAnyMouseDown()
        {
            byte __result;

            __result = IsAnyMouseDown_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetMousePos@ImGui@@YA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetMousePos_PInvoke(Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetMousePos()
        {
            Vector2 __returnBuffer;

            GetMousePos_PInvoke(&__returnBuffer);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetMousePosOnOpeningCurrentPopup@ImGui@@YA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetMousePosOnOpeningCurrentPopup_PInvoke(Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetMousePosOnOpeningCurrentPopup()
        {
            Vector2 __returnBuffer;

            GetMousePosOnOpeningCurrentPopup_PInvoke(&__returnBuffer);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsMouseDragging@ImGui@@YA_NHM@Z", ExactSpelling = true)]
        private static extern byte IsMouseDragging_PInvoke(ImGuiMouseButton button, float lock_threshold);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsMouseDragging(ImGuiMouseButton button, float lock_threshold = -1f)
        {
            byte __result;

            __result = IsMouseDragging_PInvoke(button, lock_threshold);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetMouseDragDelta@ImGui@@YA?AUImVec2@@HM@Z", ExactSpelling = true)]
        private static extern Vector2* GetMouseDragDelta_PInvoke(Vector2* __returnBuffer, ImGuiMouseButton button, float lock_threshold);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetMouseDragDelta(ImGuiMouseButton button = ImGuiMouseButton.Left, float lock_threshold = -1f)
        {
            Vector2 __returnBuffer;

            GetMouseDragDelta_PInvoke(&__returnBuffer, button, lock_threshold);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ResetMouseDragDelta@ImGui@@YAXH@Z", ExactSpelling = true)]
        public static extern void ResetMouseDragDelta(ImGuiMouseButton button = ImGuiMouseButton.Left);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetMouseCursor@ImGui@@YAHXZ", ExactSpelling = true)]
        public static extern ImGuiMouseCursor GetMouseCursor();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetMouseCursor@ImGui@@YAXH@Z", ExactSpelling = true)]
        public static extern void SetMouseCursor(ImGuiMouseCursor cursor_type);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CaptureMouseFromApp@ImGui@@YAX_N@Z", ExactSpelling = true)]
        private static extern void CaptureMouseFromApp_PInvoke(byte want_capture_mouse_value);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void CaptureMouseFromApp(bool want_capture_mouse_value = true)
        {
            CaptureMouseFromApp_PInvoke(Unsafe.As<bool, byte>(ref want_capture_mouse_value));
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetClipboardText@ImGui@@YAPEBDXZ", ExactSpelling = true)]
        public static extern byte* GetClipboardText();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetClipboardText@ImGui@@YAXPEBD@Z", ExactSpelling = true)]
        public static extern void SetClipboardText(byte* text);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetClipboardText(DearImGuiInterpolatedStringHandler text)
        {
            fixed (byte* __textP = text.NullTerminateAndGetString())
            { SetClipboardText(__textP); }

            text.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?LoadIniSettingsFromDisk@ImGui@@YAXPEBD@Z", ExactSpelling = true)]
        public static extern void LoadIniSettingsFromDisk(byte* ini_filename);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LoadIniSettingsFromDisk(DearImGuiInterpolatedStringHandler ini_filename)
        {
            fixed (byte* __ini_filenameP = ini_filename.NullTerminateAndGetString())
            { LoadIniSettingsFromDisk(__ini_filenameP); }

            ini_filename.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?LoadIniSettingsFromMemory@ImGui@@YAXPEBD_K@Z", ExactSpelling = true)]
        public static extern void LoadIniSettingsFromMemory(byte* ini_data, nuint ini_size = 0);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LoadIniSettingsFromMemory(DearImGuiInterpolatedStringHandler ini_data, nuint ini_size = 0)
        {
            fixed (byte* __ini_dataP = ini_data.NullTerminateAndGetString())
            { LoadIniSettingsFromMemory(__ini_dataP, ini_size); }

            ini_data.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SaveIniSettingsToDisk@ImGui@@YAXPEBD@Z", ExactSpelling = true)]
        public static extern void SaveIniSettingsToDisk(byte* ini_filename);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SaveIniSettingsToDisk(DearImGuiInterpolatedStringHandler ini_filename)
        {
            fixed (byte* __ini_filenameP = ini_filename.NullTerminateAndGetString())
            { SaveIniSettingsToDisk(__ini_filenameP); }

            ini_filename.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SaveIniSettingsToMemory@ImGui@@YAPEBDPEA_K@Z", ExactSpelling = true)]
        public static extern byte* SaveIniSettingsToMemory(nuint* out_ini_size = null);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugCheckVersionAndDataLayout@ImGui@@YA_NPEBD_K11111@Z", ExactSpelling = true)]
        private static extern byte DebugCheckVersionAndDataLayout_PInvoke(byte* version_str, nuint sz_io, nuint sz_style, nuint sz_vec2, nuint sz_vec4, nuint sz_drawvert, nuint sz_drawidx);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DebugCheckVersionAndDataLayout(byte* version_str, nuint sz_io, nuint sz_style, nuint sz_vec2, nuint sz_vec4, nuint sz_drawvert, nuint sz_drawidx)
        {
            byte __result;

            __result = DebugCheckVersionAndDataLayout_PInvoke(version_str, sz_io, sz_style, sz_vec2, sz_vec4, sz_drawvert, sz_drawidx);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DebugCheckVersionAndDataLayout(DearImGuiInterpolatedStringHandler version_str, nuint sz_io, nuint sz_style, nuint sz_vec2, nuint sz_vec4, nuint sz_drawvert, nuint sz_drawidx)
        {
            byte __result;

            fixed (byte* __version_strP = version_str.NullTerminateAndGetString())
            { __result = DebugCheckVersionAndDataLayout_PInvoke(__version_strP, sz_io, sz_style, sz_vec2, sz_vec4, sz_drawvert, sz_drawidx); }

            version_str.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        public const string IMGUI_VERSION = "1.87";

        public const int IMGUI_VERSION_NUM = 18700;

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetAllocatorFunctions@ImGui@@YAXP6APEAX_KPEAX@ZP6AX11@Z1@Z", ExactSpelling = true)]
        public static extern void SetAllocatorFunctions(delegate* unmanaged[Cdecl]<nuint, void*, void*> alloc_func, delegate* unmanaged[Cdecl]<void*, void*, void> free_func, void* user_data = null);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetAllocatorFunctions@ImGui@@YAXPEAP6APEAX_KPEAX@ZPEAP6AX11@ZPEAPEAX@Z", ExactSpelling = true)]
        public static extern void GetAllocatorFunctions(delegate* unmanaged[Cdecl]<nuint, void*, void*>* p_alloc_func, delegate* unmanaged[Cdecl]<void*, void*, void>* p_free_func, void** p_user_data);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?MemAlloc@ImGui@@YAPEAX_K@Z", ExactSpelling = true)]
        public static extern void* MemAlloc(nuint size);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?MemFree@ImGui@@YAXPEAX@Z", ExactSpelling = true)]
        public static extern void MemFree(void* ptr);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetPlatformIO@ImGui@@YAAEAUImGuiPlatformIO@@XZ", ExactSpelling = true)]
        public static extern ImGuiPlatformIO* GetPlatformIO();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?UpdatePlatformWindows@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void UpdatePlatformWindows();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderPlatformWindowsDefault@ImGui@@YAXPEAX0@Z", ExactSpelling = true)]
        public static extern void RenderPlatformWindowsDefault(void* platform_render_arg = null, void* renderer_render_arg = null);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DestroyPlatformWindows@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void DestroyPlatformWindows();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FindViewportByID@ImGui@@YAPEAUImGuiViewport@@I@Z", ExactSpelling = true)]
        public static extern ImGuiViewport* FindViewportByID(uint id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FindViewportByPlatformHandle@ImGui@@YAPEAUImGuiViewport@@PEAX@Z", ExactSpelling = true)]
        public static extern ImGuiViewport* FindViewportByPlatformHandle(void* platform_handle);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "??2@YAPEAX_KUImNewWrapper@@PEAX@Z", ExactSpelling = true)]
        public static extern void* operator_New(nuint arg0, ImNewWrapper arg1, void* ptr);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "??3@YAXPEAXUImNewWrapper@@0@Z", ExactSpelling = true)]
        public static extern void operator_Delete(void* arg0, ImNewWrapper arg1, void* arg2);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetKeyIndex@ImGui@@YAHH@Z", ExactSpelling = true)]
        public static extern int GetKeyIndex(ImGuiKey key);
    }
}
