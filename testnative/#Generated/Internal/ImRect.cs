// <auto-generated>
// This file was automatically generated by Biohazrd and should not be modified by hand!
// </auto-generated>
#nullable enable
using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Mochi.DearImGui.Internal
{
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public unsafe partial struct ImRect
    {
        [FieldOffset(0)] public Vector2 Min;

        [FieldOffset(8)] public Vector2 Max;

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper24", ExactSpelling = true)]
        private static extern void Constructor_PInvoke(ImRect* @this);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ImRect()
        {
            fixed (ImRect* @this = &this)
            { Constructor_PInvoke(@this); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper25", ExactSpelling = true)]
        private static extern void Constructor_PInvoke(ImRect* @this, Vector2* min, Vector2* max);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ImRect(in Vector2 min, in Vector2 max)
        {
            fixed (ImRect* @this = &this)
            fixed (Vector2* __minP = &min)
            fixed (Vector2* __maxP = &max)
            { Constructor_PInvoke(@this, __minP, __maxP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper26", ExactSpelling = true)]
        private static extern void Constructor_PInvoke(ImRect* @this, Vector4* v);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ImRect(in Vector4 v)
        {
            fixed (ImRect* @this = &this)
            fixed (Vector4* __vP = &v)
            { Constructor_PInvoke(@this, __vP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper27", ExactSpelling = true)]
        private static extern void Constructor_PInvoke(ImRect* @this, float x1, float y1, float x2, float y2);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ImRect(float x1, float y1, float x2, float y2)
        {
            fixed (ImRect* @this = &this)
            { Constructor_PInvoke(@this, x1, y1, x2, y2); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetCenter@ImRect@@QEBA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetCenter_PInvoke(ImRect* @this, Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector2 GetCenter()
        {
            Vector2 __returnBuffer;

            fixed (ImRect* @this = &this)
            { GetCenter_PInvoke(@this, &__returnBuffer); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetSize@ImRect@@QEBA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetSize_PInvoke(ImRect* @this, Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector2 GetSize()
        {
            Vector2 __returnBuffer;

            fixed (ImRect* @this = &this)
            { GetSize_PInvoke(@this, &__returnBuffer); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetWidth@ImRect@@QEBAMXZ", ExactSpelling = true)]
        private static extern float GetWidth_PInvoke(ImRect* @this);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float GetWidth()
        {
            fixed (ImRect* @this = &this)
            { return GetWidth_PInvoke(@this); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetHeight@ImRect@@QEBAMXZ", ExactSpelling = true)]
        private static extern float GetHeight_PInvoke(ImRect* @this);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float GetHeight()
        {
            fixed (ImRect* @this = &this)
            { return GetHeight_PInvoke(@this); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetArea@ImRect@@QEBAMXZ", ExactSpelling = true)]
        private static extern float GetArea_PInvoke(ImRect* @this);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float GetArea()
        {
            fixed (ImRect* @this = &this)
            { return GetArea_PInvoke(@this); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetTL@ImRect@@QEBA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetTL_PInvoke(ImRect* @this, Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector2 GetTL()
        {
            Vector2 __returnBuffer;

            fixed (ImRect* @this = &this)
            { GetTL_PInvoke(@this, &__returnBuffer); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetTR@ImRect@@QEBA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetTR_PInvoke(ImRect* @this, Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector2 GetTR()
        {
            Vector2 __returnBuffer;

            fixed (ImRect* @this = &this)
            { GetTR_PInvoke(@this, &__returnBuffer); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetBL@ImRect@@QEBA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetBL_PInvoke(ImRect* @this, Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector2 GetBL()
        {
            Vector2 __returnBuffer;

            fixed (ImRect* @this = &this)
            { GetBL_PInvoke(@this, &__returnBuffer); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetBR@ImRect@@QEBA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetBR_PInvoke(ImRect* @this, Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector2 GetBR()
        {
            Vector2 __returnBuffer;

            fixed (ImRect* @this = &this)
            { GetBR_PInvoke(@this, &__returnBuffer); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern byte Contains_PInvoke(ImRect* @this, Vector2* p);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(in Vector2 p)
        {
            byte __result;

            fixed (ImRect* @this = &this)
            fixed (Vector2* __pP = &p)
            { __result = Contains_PInvoke(@this, __pP); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Contains@ImRect@@QEBA_NAEBU1@@Z", ExactSpelling = true)]
        private static extern byte Contains_PInvoke(ImRect* @this, ImRect* r);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(in ImRect r)
        {
            byte __result;

            fixed (ImRect* @this = &this)
            fixed (ImRect* __rP = &r)
            { __result = Contains_PInvoke(@this, __rP); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Overlaps@ImRect@@QEBA_NAEBU1@@Z", ExactSpelling = true)]
        private static extern byte Overlaps_PInvoke(ImRect* @this, ImRect* r);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Overlaps(in ImRect r)
        {
            byte __result;

            fixed (ImRect* @this = &this)
            fixed (ImRect* __rP = &r)
            { __result = Overlaps_PInvoke(@this, __rP); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Add@ImRect@@QEAAXAEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern void Add_PInvoke(ImRect* @this, Vector2* p);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(in Vector2 p)
        {
            fixed (ImRect* @this = &this)
            fixed (Vector2* __pP = &p)
            { Add_PInvoke(@this, __pP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Add@ImRect@@QEAAXAEBU1@@Z", ExactSpelling = true)]
        private static extern void Add_PInvoke(ImRect* @this, ImRect* r);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(in ImRect r)
        {
            fixed (ImRect* @this = &this)
            fixed (ImRect* __rP = &r)
            { Add_PInvoke(@this, __rP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Expand@ImRect@@QEAAXM@Z", ExactSpelling = true)]
        private static extern void Expand_PInvoke(ImRect* @this, float amount);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Expand(float amount)
        {
            fixed (ImRect* @this = &this)
            { Expand_PInvoke(@this, amount); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Expand@ImRect@@QEAAXAEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern void Expand_PInvoke(ImRect* @this, Vector2* amount);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Expand(in Vector2 amount)
        {
            fixed (ImRect* @this = &this)
            fixed (Vector2* __amountP = &amount)
            { Expand_PInvoke(@this, __amountP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Translate@ImRect@@QEAAXAEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern void Translate_PInvoke(ImRect* @this, Vector2* d);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Translate(in Vector2 d)
        {
            fixed (ImRect* @this = &this)
            fixed (Vector2* __dP = &d)
            { Translate_PInvoke(@this, __dP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TranslateX@ImRect@@QEAAXM@Z", ExactSpelling = true)]
        private static extern void TranslateX_PInvoke(ImRect* @this, float dx);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TranslateX(float dx)
        {
            fixed (ImRect* @this = &this)
            { TranslateX_PInvoke(@this, dx); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TranslateY@ImRect@@QEAAXM@Z", ExactSpelling = true)]
        private static extern void TranslateY_PInvoke(ImRect* @this, float dy);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TranslateY(float dy)
        {
            fixed (ImRect* @this = &this)
            { TranslateY_PInvoke(@this, dy); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ClipWith@ImRect@@QEAAXAEBU1@@Z", ExactSpelling = true)]
        private static extern void ClipWith_PInvoke(ImRect* @this, ImRect* r);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipWith(in ImRect r)
        {
            fixed (ImRect* @this = &this)
            fixed (ImRect* __rP = &r)
            { ClipWith_PInvoke(@this, __rP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ClipWithFull@ImRect@@QEAAXAEBU1@@Z", ExactSpelling = true)]
        private static extern void ClipWithFull_PInvoke(ImRect* @this, ImRect* r);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipWithFull(in ImRect r)
        {
            fixed (ImRect* @this = &this)
            fixed (ImRect* __rP = &r)
            { ClipWithFull_PInvoke(@this, __rP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Floor@ImRect@@QEAAXXZ", ExactSpelling = true)]
        private static extern void Floor_PInvoke(ImRect* @this);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Floor()
        {
            fixed (ImRect* @this = &this)
            { Floor_PInvoke(@this); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsInverted@ImRect@@QEBA_NXZ", ExactSpelling = true)]
        private static extern byte IsInverted_PInvoke(ImRect* @this);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsInverted()
        {
            byte __result;

            fixed (ImRect* @this = &this)
            { __result = IsInverted_PInvoke(@this); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ToVec4@ImRect@@QEBA?AUImVec4@@XZ", ExactSpelling = true)]
        private static extern Vector4* ToVec4_PInvoke(ImRect* @this, Vector4* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector4 ToVec4()
        {
            Vector4 __returnBuffer;

            fixed (ImRect* @this = &this)
            { ToVec4_PInvoke(@this, &__returnBuffer); }

            return __returnBuffer;
        }
    }
}
