// <auto-generated>
// This file was automatically generated by Biohazrd and should not be modified by hand!
// </auto-generated>
#nullable enable
using Mochi.DearImGui.Infrastructure;
using System;
using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Mochi.DearImGui.Internal
{
    public unsafe static partial class ImGuiInternal
    {
        public static readonly ImGuiContext** GImGui = (ImGuiContext**)NativeLibrary.GetExport(NativeLibrary.Load("Mochi.DearImGui.Native"), "?GImGui@@3PEAUImGuiContext@@EA");

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImHashData@@YAIPEBX_KI@Z", ExactSpelling = true)]
        public static extern uint ImHashData(void* data, nuint data_size, uint seed = 0);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImHashStr@@YAIPEBD_KI@Z", ExactSpelling = true)]
        public static extern uint ImHashStr(byte* data, nuint data_size = 0, uint seed = 0);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint ImHashStr(DearImGuiInterpolatedStringHandler data, nuint data_size = 0, uint seed = 0)
        {
            uint __result;

            fixed (byte* __dataP = data.NullTerminateAndGetString())
            { __result = ImHashStr(__dataP, data_size, seed); }

            data.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper63", ExactSpelling = true)]
        public static extern void ImQsort(void* @base, nuint count, nuint size_of_element, delegate* unmanaged[Cdecl]<void*, void*, int> compare_func);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImAlphaBlendColors@@YAIII@Z", ExactSpelling = true)]
        public static extern uint ImAlphaBlendColors(uint col_a, uint col_b);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper64", ExactSpelling = true)]
        private static extern byte ImIsPowerOfTwo_PInvoke(int v);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ImIsPowerOfTwo(int v)
        {
            byte __result;

            __result = ImIsPowerOfTwo_PInvoke(v);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper65", ExactSpelling = true)]
        private static extern byte ImIsPowerOfTwo_PInvoke(ulong v);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ImIsPowerOfTwo(ulong v)
        {
            byte __result;

            __result = ImIsPowerOfTwo_PInvoke(v);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper66", ExactSpelling = true)]
        public static extern int ImUpperPowerOfTwo(int v);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImStricmp@@YAHPEBD0@Z", ExactSpelling = true)]
        public static extern int ImStricmp(byte* str1, byte* str2);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ImStricmp(DearImGuiInterpolatedStringHandler str1, DearImGuiInterpolatedStringHandler str2)
        {
            int __result;

            fixed (byte* __str1P = str1.NullTerminateAndGetString())
            fixed (byte* __str2P = str2.NullTerminateAndGetString())
            { __result = ImStricmp(__str1P, __str2P); }

            str1.Dispose();
            str2.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImStrnicmp@@YAHPEBD0_K@Z", ExactSpelling = true)]
        public static extern int ImStrnicmp(byte* str1, byte* str2, nuint count);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ImStrnicmp(DearImGuiInterpolatedStringHandler str1, DearImGuiInterpolatedStringHandler str2, nuint count)
        {
            int __result;

            fixed (byte* __str1P = str1.NullTerminateAndGetString())
            fixed (byte* __str2P = str2.NullTerminateAndGetString())
            { __result = ImStrnicmp(__str1P, __str2P, count); }

            str1.Dispose();
            str2.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImStrncpy@@YAXPEADPEBD_K@Z", ExactSpelling = true)]
        public static extern void ImStrncpy(byte* dst, byte* src, nuint count);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ImStrncpy(byte* dst, DearImGuiInterpolatedStringHandler src, nuint count)
        {
            fixed (byte* __srcP = src.NullTerminateAndGetString())
            { ImStrncpy(dst, __srcP, count); }

            src.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImStrdup@@YAPEADPEBD@Z", ExactSpelling = true)]
        public static extern byte* ImStrdup(byte* str);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte* ImStrdup(DearImGuiInterpolatedStringHandler str)
        {
            byte* __result;

            fixed (byte* __strP = str.NullTerminateAndGetString())
            { __result = ImStrdup(__strP); }

            str.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImStrdupcpy@@YAPEADPEADPEA_KPEBD@Z", ExactSpelling = true)]
        public static extern byte* ImStrdupcpy(byte* dst, nuint* p_dst_size, byte* str);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte* ImStrdupcpy(byte* dst, nuint* p_dst_size, DearImGuiInterpolatedStringHandler str)
        {
            byte* __result;

            fixed (byte* __strP = str.NullTerminateAndGetString())
            { __result = ImStrdupcpy(dst, p_dst_size, __strP); }

            str.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImStrchrRange@@YAPEBDPEBD0D@Z", ExactSpelling = true)]
        public static extern byte* ImStrchrRange(byte* str_begin, byte* str_end, byte c);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte* ImStrchrRange(DearImGuiInterpolatedStringHandler str_begin, byte c)
        {
            byte* __result;
            ReadOnlySpan<byte> __str_begin = str_begin.NullTerminateAndGetString();

            fixed (byte* __str_beginP = __str_begin)
            { __result = ImStrchrRange(__str_beginP, __str_beginP + __str_begin.Length, c); }

            str_begin.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImStrlenW@@YAHPEBG@Z", ExactSpelling = true)]
        public static extern int ImStrlenW(char* str);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImStreolRange@@YAPEBDPEBD0@Z", ExactSpelling = true)]
        public static extern byte* ImStreolRange(byte* str, byte* str_end);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte* ImStreolRange(DearImGuiInterpolatedStringHandler str)
        {
            byte* __result;
            ReadOnlySpan<byte> __str = str.NullTerminateAndGetString();

            fixed (byte* __strP = __str)
            { __result = ImStreolRange(__strP, __strP + __str.Length); }

            str.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImStrbolW@@YAPEBGPEBG0@Z", ExactSpelling = true)]
        public static extern char* ImStrbolW(char* buf_mid_line, char* buf_begin);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImStristr@@YAPEBDPEBD000@Z", ExactSpelling = true)]
        public static extern byte* ImStristr(byte* haystack, byte* haystack_end, byte* needle, byte* needle_end);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte* ImStristr(DearImGuiInterpolatedStringHandler haystack, DearImGuiInterpolatedStringHandler needle)
        {
            byte* __result;
            ReadOnlySpan<byte> __haystack = haystack.NullTerminateAndGetString();
            ReadOnlySpan<byte> __needle = needle.NullTerminateAndGetString();

            fixed (byte* __haystackP = __haystack)
            fixed (byte* __needleP = __needle)
            { __result = ImStristr(__haystackP, __haystackP + __haystack.Length, __needleP, __needleP + __needle.Length); }

            haystack.Dispose();
            needle.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImStrTrimBlanks@@YAXPEAD@Z", ExactSpelling = true)]
        public static extern void ImStrTrimBlanks(byte* str);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImStrSkipBlank@@YAPEBDPEBD@Z", ExactSpelling = true)]
        public static extern byte* ImStrSkipBlank(byte* str);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte* ImStrSkipBlank(DearImGuiInterpolatedStringHandler str)
        {
            byte* __result;

            fixed (byte* __strP = str.NullTerminateAndGetString())
            { __result = ImStrSkipBlank(__strP); }

            str.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImFormatString@@YAHPEAD_KPEBDZZ", ExactSpelling = true)]
        public static extern int ImFormatString(byte* buf, nuint buf_size, byte* fmt);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ImFormatString(byte* buf, nuint buf_size, DearImGuiInterpolatedStringHandler fmt)
        {
            int __result;

            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { __result = ImFormatString(buf, buf_size, __fmtP); }

            fmt.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImFormatStringV@@YAHPEAD_KPEBD0@Z", ExactSpelling = true)]
        public static extern int ImFormatStringV(byte* buf, nuint buf_size, byte* fmt, byte* args);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ImFormatStringV(byte* buf, nuint buf_size, DearImGuiInterpolatedStringHandler fmt, byte* args)
        {
            int __result;

            fixed (byte* __fmtP = fmt.NullTerminateAndGetString())
            { __result = ImFormatStringV(buf, buf_size, __fmtP, args); }

            fmt.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImParseFormatFindStart@@YAPEBDPEBD@Z", ExactSpelling = true)]
        public static extern byte* ImParseFormatFindStart(byte* format);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte* ImParseFormatFindStart(DearImGuiInterpolatedStringHandler format)
        {
            byte* __result;

            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = ImParseFormatFindStart(__formatP); }

            format.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImParseFormatFindEnd@@YAPEBDPEBD@Z", ExactSpelling = true)]
        public static extern byte* ImParseFormatFindEnd(byte* format);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte* ImParseFormatFindEnd(DearImGuiInterpolatedStringHandler format)
        {
            byte* __result;

            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = ImParseFormatFindEnd(__formatP); }

            format.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImParseFormatTrimDecorations@@YAPEBDPEBDPEAD_K@Z", ExactSpelling = true)]
        public static extern byte* ImParseFormatTrimDecorations(byte* format, byte* buf, nuint buf_size);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte* ImParseFormatTrimDecorations(DearImGuiInterpolatedStringHandler format, byte* buf, nuint buf_size)
        {
            byte* __result;

            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = ImParseFormatTrimDecorations(__formatP, buf, buf_size); }

            format.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImParseFormatPrecision@@YAHPEBDH@Z", ExactSpelling = true)]
        public static extern int ImParseFormatPrecision(byte* format, int default_value);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ImParseFormatPrecision(DearImGuiInterpolatedStringHandler format, int default_value)
        {
            int __result;

            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = ImParseFormatPrecision(__formatP, default_value); }

            format.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper67", ExactSpelling = true)]
        private static extern byte ImCharIsBlankA_PInvoke(byte c);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ImCharIsBlankA(byte c)
        {
            byte __result;

            __result = ImCharIsBlankA_PInvoke(c);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper68", ExactSpelling = true)]
        private static extern byte ImCharIsBlankW_PInvoke(uint c);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ImCharIsBlankW(uint c)
        {
            byte __result;

            __result = ImCharIsBlankW_PInvoke(c);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImTextCharToUtf8@@YAPEBDQEADI@Z", ExactSpelling = true)]
        public static extern byte* ImTextCharToUtf8(ConstantArray_char_5* out_buf, uint c);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImTextStrToUtf8@@YAHPEADHPEBG1@Z", ExactSpelling = true)]
        public static extern int ImTextStrToUtf8(byte* out_buf, int out_buf_size, char* in_text, char* in_text_end);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z", ExactSpelling = true)]
        public static extern int ImTextCharFromUtf8(uint* out_char, byte* in_text, byte* in_text_end);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ImTextCharFromUtf8(uint* out_char, DearImGuiInterpolatedStringHandler in_text)
        {
            int __result;
            ReadOnlySpan<byte> __in_text = in_text.NullTerminateAndGetString();

            fixed (byte* __in_textP = __in_text)
            { __result = ImTextCharFromUtf8(out_char, __in_textP, __in_textP + __in_text.Length); }

            in_text.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z", ExactSpelling = true)]
        public static extern int ImTextStrFromUtf8(char* out_buf, int out_buf_size, byte* in_text, byte* in_text_end, byte** in_remaining = null);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ImTextStrFromUtf8(char* out_buf, int out_buf_size, DearImGuiInterpolatedStringHandler in_text, byte** in_remaining = null)
        {
            int __result;
            ReadOnlySpan<byte> __in_text = in_text.NullTerminateAndGetString();

            fixed (byte* __in_textP = __in_text)
            { __result = ImTextStrFromUtf8(out_buf, out_buf_size, __in_textP, __in_textP + __in_text.Length, in_remaining); }

            in_text.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImTextCountCharsFromUtf8@@YAHPEBD0@Z", ExactSpelling = true)]
        public static extern int ImTextCountCharsFromUtf8(byte* in_text, byte* in_text_end);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ImTextCountCharsFromUtf8(DearImGuiInterpolatedStringHandler in_text)
        {
            int __result;
            ReadOnlySpan<byte> __in_text = in_text.NullTerminateAndGetString();

            fixed (byte* __in_textP = __in_text)
            { __result = ImTextCountCharsFromUtf8(__in_textP, __in_textP + __in_text.Length); }

            in_text.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImTextCountUtf8BytesFromChar@@YAHPEBD0@Z", ExactSpelling = true)]
        public static extern int ImTextCountUtf8BytesFromChar(byte* in_text, byte* in_text_end);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ImTextCountUtf8BytesFromChar(DearImGuiInterpolatedStringHandler in_text)
        {
            int __result;
            ReadOnlySpan<byte> __in_text = in_text.NullTerminateAndGetString();

            fixed (byte* __in_textP = __in_text)
            { __result = ImTextCountUtf8BytesFromChar(__in_textP, __in_textP + __in_text.Length); }

            in_text.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImTextCountUtf8BytesFromStr@@YAHPEBG0@Z", ExactSpelling = true)]
        public static extern int ImTextCountUtf8BytesFromStr(char* in_text, char* in_text_end);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImFileOpen@@YAPEAU_iobuf@@PEBD0@Z", ExactSpelling = true)]
        public static extern void* ImFileOpen(byte* filename, byte* mode);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void* ImFileOpen(DearImGuiInterpolatedStringHandler filename, DearImGuiInterpolatedStringHandler mode)
        {
            void* __result;

            fixed (byte* __filenameP = filename.NullTerminateAndGetString())
            fixed (byte* __modeP = mode.NullTerminateAndGetString())
            { __result = ImFileOpen(__filenameP, __modeP); }

            filename.Dispose();
            mode.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImFileClose@@YA_NPEAU_iobuf@@@Z", ExactSpelling = true)]
        private static extern byte ImFileClose_PInvoke(void* file);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ImFileClose(void* file)
        {
            byte __result;

            __result = ImFileClose_PInvoke(file);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImFileGetSize@@YA_KPEAU_iobuf@@@Z", ExactSpelling = true)]
        public static extern ulong ImFileGetSize(void* file);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImFileRead@@YA_KPEAX_K1PEAU_iobuf@@@Z", ExactSpelling = true)]
        public static extern ulong ImFileRead(void* data, ulong size, ulong count, void* file);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImFileWrite@@YA_KPEBX_K1PEAU_iobuf@@@Z", ExactSpelling = true)]
        public static extern ulong ImFileWrite(void* data, ulong size, ulong count, void* file);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImFileLoadToMemory@@YAPEAXPEBD0PEA_KH@Z", ExactSpelling = true)]
        public static extern void* ImFileLoadToMemory(byte* filename, byte* mode, nuint* out_file_size = null, int padding_bytes = 0);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void* ImFileLoadToMemory(DearImGuiInterpolatedStringHandler filename, DearImGuiInterpolatedStringHandler mode, nuint* out_file_size = null, int padding_bytes = 0)
        {
            void* __result;

            fixed (byte* __filenameP = filename.NullTerminateAndGetString())
            fixed (byte* __modeP = mode.NullTerminateAndGetString())
            { __result = ImFileLoadToMemory(__filenameP, __modeP, out_file_size, padding_bytes); }

            filename.Dispose();
            mode.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper69", ExactSpelling = true)]
        public static extern float ImPow(float x, float y);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper70", ExactSpelling = true)]
        public static extern double ImPow(double x, double y);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper71", ExactSpelling = true)]
        public static extern float ImLog(float x);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper72", ExactSpelling = true)]
        public static extern double ImLog(double x);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper73", ExactSpelling = true)]
        public static extern int ImAbs(int x);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper74", ExactSpelling = true)]
        public static extern float ImAbs(float x);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper75", ExactSpelling = true)]
        public static extern double ImAbs(double x);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper76", ExactSpelling = true)]
        public static extern float ImSign(float x);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper77", ExactSpelling = true)]
        public static extern double ImSign(double x);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper78", ExactSpelling = true)]
        public static extern float ImRsqrt(float x);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper79", ExactSpelling = true)]
        public static extern double ImRsqrt(double x);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper80", ExactSpelling = true)]
        private static extern Vector2* ImMin_PInvoke(Vector2* __returnBuffer, Vector2* lhs, Vector2* rhs);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 ImMin(in Vector2 lhs, in Vector2 rhs)
        {
            Vector2 __returnBuffer;

            fixed (Vector2* __lhsP = &lhs)
            fixed (Vector2* __rhsP = &rhs)
            { ImMin_PInvoke(&__returnBuffer, __lhsP, __rhsP); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper81", ExactSpelling = true)]
        private static extern Vector2* ImMax_PInvoke(Vector2* __returnBuffer, Vector2* lhs, Vector2* rhs);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 ImMax(in Vector2 lhs, in Vector2 rhs)
        {
            Vector2 __returnBuffer;

            fixed (Vector2* __lhsP = &lhs)
            fixed (Vector2* __rhsP = &rhs)
            { ImMax_PInvoke(&__returnBuffer, __lhsP, __rhsP); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper82", ExactSpelling = true)]
        private static extern Vector2* ImClamp_PInvoke(Vector2* __returnBuffer, Vector2* v, Vector2* mn, Vector2 mx);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 ImClamp(in Vector2 v, in Vector2 mn, Vector2 mx)
        {
            Vector2 __returnBuffer;

            fixed (Vector2* __vP = &v)
            fixed (Vector2* __mnP = &mn)
            { ImClamp_PInvoke(&__returnBuffer, __vP, __mnP, mx); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper83", ExactSpelling = true)]
        private static extern Vector2* ImLerp_PInvoke(Vector2* __returnBuffer, Vector2* a, Vector2* b, float t);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 ImLerp(in Vector2 a, in Vector2 b, float t)
        {
            Vector2 __returnBuffer;

            fixed (Vector2* __aP = &a)
            fixed (Vector2* __bP = &b)
            { ImLerp_PInvoke(&__returnBuffer, __aP, __bP, t); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper84", ExactSpelling = true)]
        private static extern Vector2* ImLerp_PInvoke(Vector2* __returnBuffer, Vector2* a, Vector2* b, Vector2* t);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 ImLerp(in Vector2 a, in Vector2 b, in Vector2 t)
        {
            Vector2 __returnBuffer;

            fixed (Vector2* __aP = &a)
            fixed (Vector2* __bP = &b)
            fixed (Vector2* __tP = &t)
            { ImLerp_PInvoke(&__returnBuffer, __aP, __bP, __tP); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper85", ExactSpelling = true)]
        private static extern Vector4* ImLerp_PInvoke(Vector4* __returnBuffer, Vector4* a, Vector4* b, float t);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 ImLerp(in Vector4 a, in Vector4 b, float t)
        {
            Vector4 __returnBuffer;

            fixed (Vector4* __aP = &a)
            fixed (Vector4* __bP = &b)
            { ImLerp_PInvoke(&__returnBuffer, __aP, __bP, t); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper86", ExactSpelling = true)]
        public static extern float ImSaturate(float f);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper87", ExactSpelling = true)]
        private static extern float ImLengthSqr_PInvoke(Vector2* lhs);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float ImLengthSqr(in Vector2 lhs)
        {
            fixed (Vector2* __lhsP = &lhs)
            { return ImLengthSqr_PInvoke(__lhsP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper88", ExactSpelling = true)]
        private static extern float ImLengthSqr_PInvoke(Vector4* lhs);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float ImLengthSqr(in Vector4 lhs)
        {
            fixed (Vector4* __lhsP = &lhs)
            { return ImLengthSqr_PInvoke(__lhsP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper89", ExactSpelling = true)]
        private static extern float ImInvLength_PInvoke(Vector2* lhs, float fail_value);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float ImInvLength(in Vector2 lhs, float fail_value)
        {
            fixed (Vector2* __lhsP = &lhs)
            { return ImInvLength_PInvoke(__lhsP, fail_value); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper90", ExactSpelling = true)]
        public static extern float ImFloor(float f);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper91", ExactSpelling = true)]
        public static extern float ImFloorSigned(float f);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper92", ExactSpelling = true)]
        private static extern Vector2* ImFloor_PInvoke(Vector2* __returnBuffer, Vector2* v);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 ImFloor(in Vector2 v)
        {
            Vector2 __returnBuffer;

            fixed (Vector2* __vP = &v)
            { ImFloor_PInvoke(&__returnBuffer, __vP); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper93", ExactSpelling = true)]
        private static extern Vector2* ImFloorSigned_PInvoke(Vector2* __returnBuffer, Vector2* v);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 ImFloorSigned(in Vector2 v)
        {
            Vector2 __returnBuffer;

            fixed (Vector2* __vP = &v)
            { ImFloorSigned_PInvoke(&__returnBuffer, __vP); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper94", ExactSpelling = true)]
        public static extern int ImModPositive(int a, int b);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper95", ExactSpelling = true)]
        private static extern float ImDot_PInvoke(Vector2* a, Vector2* b);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float ImDot(in Vector2 a, in Vector2 b)
        {
            fixed (Vector2* __aP = &a)
            fixed (Vector2* __bP = &b)
            { return ImDot_PInvoke(__aP, __bP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper96", ExactSpelling = true)]
        private static extern Vector2* ImRotate_PInvoke(Vector2* __returnBuffer, Vector2* v, float cos_a, float sin_a);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 ImRotate(in Vector2 v, float cos_a, float sin_a)
        {
            Vector2 __returnBuffer;

            fixed (Vector2* __vP = &v)
            { ImRotate_PInvoke(&__returnBuffer, __vP, cos_a, sin_a); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper97", ExactSpelling = true)]
        public static extern float ImLinearSweep(float current, float target, float speed);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper98", ExactSpelling = true)]
        private static extern Vector2* ImMul_PInvoke(Vector2* __returnBuffer, Vector2* lhs, Vector2* rhs);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 ImMul(in Vector2 lhs, in Vector2 rhs)
        {
            Vector2 __returnBuffer;

            fixed (Vector2* __lhsP = &lhs)
            fixed (Vector2* __rhsP = &rhs)
            { ImMul_PInvoke(&__returnBuffer, __lhsP, __rhsP); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__InlineHelper99", ExactSpelling = true)]
        private static extern byte ImIsFloatAboveGuaranteedIntegerPrecision_PInvoke(float f);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ImIsFloatAboveGuaranteedIntegerPrecision(float f)
        {
            byte __result;

            __result = ImIsFloatAboveGuaranteedIntegerPrecision_PInvoke(f);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImBezierCubicCalc@@YA?AUImVec2@@AEBU1@000M@Z", ExactSpelling = true)]
        private static extern Vector2* ImBezierCubicCalc_PInvoke(Vector2* __returnBuffer, Vector2* p1, Vector2* p2, Vector2* p3, Vector2* p4, float t);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 ImBezierCubicCalc(in Vector2 p1, in Vector2 p2, in Vector2 p3, in Vector2 p4, float t)
        {
            Vector2 __returnBuffer;

            fixed (Vector2* __p1P = &p1)
            fixed (Vector2* __p2P = &p2)
            fixed (Vector2* __p3P = &p3)
            fixed (Vector2* __p4P = &p4)
            { ImBezierCubicCalc_PInvoke(&__returnBuffer, __p1P, __p2P, __p3P, __p4P, t); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImBezierCubicClosestPoint@@YA?AUImVec2@@AEBU1@0000H@Z", ExactSpelling = true)]
        private static extern Vector2* ImBezierCubicClosestPoint_PInvoke(Vector2* __returnBuffer, Vector2* p1, Vector2* p2, Vector2* p3, Vector2* p4, Vector2* p, int num_segments);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 ImBezierCubicClosestPoint(in Vector2 p1, in Vector2 p2, in Vector2 p3, in Vector2 p4, in Vector2 p, int num_segments)
        {
            Vector2 __returnBuffer;

            fixed (Vector2* __p1P = &p1)
            fixed (Vector2* __p2P = &p2)
            fixed (Vector2* __p3P = &p3)
            fixed (Vector2* __p4P = &p4)
            fixed (Vector2* __pP = &p)
            { ImBezierCubicClosestPoint_PInvoke(&__returnBuffer, __p1P, __p2P, __p3P, __p4P, __pP, num_segments); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImBezierCubicClosestPointCasteljau@@YA?AUImVec2@@AEBU1@0000M@Z", ExactSpelling = true)]
        private static extern Vector2* ImBezierCubicClosestPointCasteljau_PInvoke(Vector2* __returnBuffer, Vector2* p1, Vector2* p2, Vector2* p3, Vector2* p4, Vector2* p, float tess_tol);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 ImBezierCubicClosestPointCasteljau(in Vector2 p1, in Vector2 p2, in Vector2 p3, in Vector2 p4, in Vector2 p, float tess_tol)
        {
            Vector2 __returnBuffer;

            fixed (Vector2* __p1P = &p1)
            fixed (Vector2* __p2P = &p2)
            fixed (Vector2* __p3P = &p3)
            fixed (Vector2* __p4P = &p4)
            fixed (Vector2* __pP = &p)
            { ImBezierCubicClosestPointCasteljau_PInvoke(&__returnBuffer, __p1P, __p2P, __p3P, __p4P, __pP, tess_tol); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImBezierQuadraticCalc@@YA?AUImVec2@@AEBU1@00M@Z", ExactSpelling = true)]
        private static extern Vector2* ImBezierQuadraticCalc_PInvoke(Vector2* __returnBuffer, Vector2* p1, Vector2* p2, Vector2* p3, float t);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 ImBezierQuadraticCalc(in Vector2 p1, in Vector2 p2, in Vector2 p3, float t)
        {
            Vector2 __returnBuffer;

            fixed (Vector2* __p1P = &p1)
            fixed (Vector2* __p2P = &p2)
            fixed (Vector2* __p3P = &p3)
            { ImBezierQuadraticCalc_PInvoke(&__returnBuffer, __p1P, __p2P, __p3P, t); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImLineClosestPoint@@YA?AUImVec2@@AEBU1@00@Z", ExactSpelling = true)]
        private static extern Vector2* ImLineClosestPoint_PInvoke(Vector2* __returnBuffer, Vector2* a, Vector2* b, Vector2* p);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 ImLineClosestPoint(in Vector2 a, in Vector2 b, in Vector2 p)
        {
            Vector2 __returnBuffer;

            fixed (Vector2* __aP = &a)
            fixed (Vector2* __bP = &b)
            fixed (Vector2* __pP = &p)
            { ImLineClosestPoint_PInvoke(&__returnBuffer, __aP, __bP, __pP); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImTriangleContainsPoint@@YA_NAEBUImVec2@@000@Z", ExactSpelling = true)]
        private static extern byte ImTriangleContainsPoint_PInvoke(Vector2* a, Vector2* b, Vector2* c, Vector2* p);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ImTriangleContainsPoint(in Vector2 a, in Vector2 b, in Vector2 c, in Vector2 p)
        {
            byte __result;

            fixed (Vector2* __aP = &a)
            fixed (Vector2* __bP = &b)
            fixed (Vector2* __cP = &c)
            fixed (Vector2* __pP = &p)
            { __result = ImTriangleContainsPoint_PInvoke(__aP, __bP, __cP, __pP); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImTriangleClosestPoint@@YA?AUImVec2@@AEBU1@000@Z", ExactSpelling = true)]
        private static extern Vector2* ImTriangleClosestPoint_PInvoke(Vector2* __returnBuffer, Vector2* a, Vector2* b, Vector2* c, Vector2* p);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 ImTriangleClosestPoint(in Vector2 a, in Vector2 b, in Vector2 c, in Vector2 p)
        {
            Vector2 __returnBuffer;

            fixed (Vector2* __aP = &a)
            fixed (Vector2* __bP = &b)
            fixed (Vector2* __cP = &c)
            fixed (Vector2* __pP = &p)
            { ImTriangleClosestPoint_PInvoke(&__returnBuffer, __aP, __bP, __cP, __pP); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImTriangleBarycentricCoords@@YAXAEBUImVec2@@000AEAM11@Z", ExactSpelling = true)]
        private static extern void ImTriangleBarycentricCoords_PInvoke(Vector2* a, Vector2* b, Vector2* c, Vector2* p, float* out_u, float* out_v, float* out_w);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ImTriangleBarycentricCoords(in Vector2 a, in Vector2 b, in Vector2 c, in Vector2 p, ref float out_u, ref float out_v, ref float out_w)
        {
            fixed (Vector2* __aP = &a)
            fixed (Vector2* __bP = &b)
            fixed (Vector2* __cP = &c)
            fixed (Vector2* __pP = &p)
            fixed (float* __out_uP = &out_u)
            fixed (float* __out_vP = &out_v)
            fixed (float* __out_wP = &out_w)
            { ImTriangleBarycentricCoords_PInvoke(__aP, __bP, __cP, __pP, __out_uP, __out_vP, __out_wP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImTriangleArea@@YAMAEBUImVec2@@00@Z", ExactSpelling = true)]
        private static extern float ImTriangleArea_PInvoke(Vector2* a, Vector2* b, Vector2* c);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float ImTriangleArea(in Vector2 a, in Vector2 b, in Vector2 c)
        {
            fixed (Vector2* __aP = &a)
            fixed (Vector2* __bP = &b)
            fixed (Vector2* __cP = &c)
            { return ImTriangleArea_PInvoke(__aP, __bP, __cP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImGetDirQuadrantFromDelta@@YAHMM@Z", ExactSpelling = true)]
        public static extern ImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImBitArrayTestBit@@YA_NPEBIH@Z", ExactSpelling = true)]
        private static extern byte ImBitArrayTestBit_PInvoke(uint* arr, int n);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ImBitArrayTestBit(uint* arr, int n)
        {
            byte __result;

            __result = ImBitArrayTestBit_PInvoke(arr, n);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImBitArrayClearBit@@YAXPEAIH@Z", ExactSpelling = true)]
        public static extern void ImBitArrayClearBit(uint* arr, int n);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImBitArraySetBit@@YAXPEAIH@Z", ExactSpelling = true)]
        public static extern void ImBitArraySetBit(uint* arr, int n);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImBitArraySetBitRange@@YAXPEAIHH@Z", ExactSpelling = true)]
        public static extern void ImBitArraySetBitRange(uint* arr, int n, int n2);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetCurrentWindowRead@ImGui@@YAPEAUImGuiWindow@@XZ", ExactSpelling = true)]
        public static extern ImGuiWindow* GetCurrentWindowRead();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetCurrentWindow@ImGui@@YAPEAUImGuiWindow@@XZ", ExactSpelling = true)]
        public static extern ImGuiWindow* GetCurrentWindow();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FindWindowByID@ImGui@@YAPEAUImGuiWindow@@I@Z", ExactSpelling = true)]
        public static extern ImGuiWindow* FindWindowByID(uint id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z", ExactSpelling = true)]
        public static extern ImGuiWindow* FindWindowByName(byte* name);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ImGuiWindow* FindWindowByName(DearImGuiInterpolatedStringHandler name)
        {
            ImGuiWindow* __result;

            fixed (byte* __nameP = name.NullTerminateAndGetString())
            { __result = FindWindowByName(__nameP); }

            name.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?UpdateWindowParentAndRootLinks@ImGui@@YAXPEAUImGuiWindow@@H0@Z", ExactSpelling = true)]
        public static extern void UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CalcWindowNextAutoFitSize@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z", ExactSpelling = true)]
        private static extern Vector2* CalcWindowNextAutoFitSize_PInvoke(Vector2* __returnBuffer, ImGuiWindow* window);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 CalcWindowNextAutoFitSize(ImGuiWindow* window)
        {
            Vector2 __returnBuffer;

            CalcWindowNextAutoFitSize_PInvoke(&__returnBuffer, window);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsWindowChildOf@ImGui@@YA_NPEAUImGuiWindow@@0_N1@Z", ExactSpelling = true)]
        private static extern byte IsWindowChildOf_PInvoke(ImGuiWindow* window, ImGuiWindow* potential_parent, byte popup_hierarchy, byte dock_hierarchy);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent, bool popup_hierarchy, bool dock_hierarchy)
        {
            byte __result;

            __result = IsWindowChildOf_PInvoke(window, potential_parent, Unsafe.As<bool, byte>(ref popup_hierarchy), Unsafe.As<bool, byte>(ref dock_hierarchy));

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsWindowWithinBeginStackOf@ImGui@@YA_NPEAUImGuiWindow@@0@Z", ExactSpelling = true)]
        private static extern byte IsWindowWithinBeginStackOf_PInvoke(ImGuiWindow* window, ImGuiWindow* potential_parent);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsWindowWithinBeginStackOf(ImGuiWindow* window, ImGuiWindow* potential_parent)
        {
            byte __result;

            __result = IsWindowWithinBeginStackOf_PInvoke(window, potential_parent);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsWindowAbove@ImGui@@YA_NPEAUImGuiWindow@@0@Z", ExactSpelling = true)]
        private static extern byte IsWindowAbove_PInvoke(ImGuiWindow* potential_above, ImGuiWindow* potential_below);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsWindowAbove(ImGuiWindow* potential_above, ImGuiWindow* potential_below)
        {
            byte __result;

            __result = IsWindowAbove_PInvoke(potential_above, potential_below);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsWindowNavFocusable@ImGui@@YA_NPEAUImGuiWindow@@@Z", ExactSpelling = true)]
        private static extern byte IsWindowNavFocusable_PInvoke(ImGuiWindow* window);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsWindowNavFocusable(ImGuiWindow* window)
        {
            byte __result;

            __result = IsWindowNavFocusable_PInvoke(window);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetWindowPos@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z", ExactSpelling = true)]
        private static extern void SetWindowPos_PInvoke(ImGuiWindow* window, Vector2* pos, ImGuiCond cond);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetWindowPos(ImGuiWindow* window, in Vector2 pos, ImGuiCond cond = ImGuiCond.None)
        {
            fixed (Vector2* __posP = &pos)
            { SetWindowPos_PInvoke(window, __posP, cond); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetWindowSize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z", ExactSpelling = true)]
        private static extern void SetWindowSize_PInvoke(ImGuiWindow* window, Vector2* size, ImGuiCond cond);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetWindowSize(ImGuiWindow* window, in Vector2 size, ImGuiCond cond = ImGuiCond.None)
        {
            fixed (Vector2* __sizeP = &size)
            { SetWindowSize_PInvoke(window, __sizeP, cond); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetWindowCollapsed@ImGui@@YAXPEAUImGuiWindow@@_NH@Z", ExactSpelling = true)]
        private static extern void SetWindowCollapsed_PInvoke(ImGuiWindow* window, byte collapsed, ImGuiCond cond);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond = ImGuiCond.None)
        {
            SetWindowCollapsed_PInvoke(window, Unsafe.As<bool, byte>(ref collapsed), cond);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetWindowHitTestHole@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@1@Z", ExactSpelling = true)]
        private static extern void SetWindowHitTestHole_PInvoke(ImGuiWindow* window, Vector2* pos, Vector2* size);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetWindowHitTestHole(ImGuiWindow* window, in Vector2 pos, in Vector2 size)
        {
            fixed (Vector2* __posP = &pos)
            fixed (Vector2* __sizeP = &size)
            { SetWindowHitTestHole_PInvoke(window, __posP, __sizeP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?WindowRectAbsToRel@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@AEBU2@@Z", ExactSpelling = true)]
        private static extern ImRect* WindowRectAbsToRel_PInvoke(ImRect* __returnBuffer, ImGuiWindow* window, ImRect* r);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ImRect WindowRectAbsToRel(ImGuiWindow* window, in ImRect r)
        {
            ImRect __returnBuffer;

            fixed (ImRect* __rP = &r)
            { WindowRectAbsToRel_PInvoke(&__returnBuffer, window, __rP); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?WindowRectRelToAbs@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@AEBU2@@Z", ExactSpelling = true)]
        private static extern ImRect* WindowRectRelToAbs_PInvoke(ImRect* __returnBuffer, ImGuiWindow* window, ImRect* r);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ImRect WindowRectRelToAbs(ImGuiWindow* window, in ImRect r)
        {
            ImRect __returnBuffer;

            fixed (ImRect* __rP = &r)
            { WindowRectRelToAbs_PInvoke(&__returnBuffer, window, __rP); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z", ExactSpelling = true)]
        public static extern void FocusWindow(ImGuiWindow* window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FocusTopMostWindowUnderOne@ImGui@@YAXPEAUImGuiWindow@@0@Z", ExactSpelling = true)]
        public static extern void FocusTopMostWindowUnderOne(ImGuiWindow* under_this_window, ImGuiWindow* ignore_window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BringWindowToFocusFront@ImGui@@YAXPEAUImGuiWindow@@@Z", ExactSpelling = true)]
        public static extern void BringWindowToFocusFront(ImGuiWindow* window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BringWindowToDisplayFront@ImGui@@YAXPEAUImGuiWindow@@@Z", ExactSpelling = true)]
        public static extern void BringWindowToDisplayFront(ImGuiWindow* window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BringWindowToDisplayBack@ImGui@@YAXPEAUImGuiWindow@@@Z", ExactSpelling = true)]
        public static extern void BringWindowToDisplayBack(ImGuiWindow* window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BringWindowToDisplayBehind@ImGui@@YAXPEAUImGuiWindow@@0@Z", ExactSpelling = true)]
        public static extern void BringWindowToDisplayBehind(ImGuiWindow* window, ImGuiWindow* above_window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FindWindowDisplayIndex@ImGui@@YAHPEAUImGuiWindow@@@Z", ExactSpelling = true)]
        public static extern int FindWindowDisplayIndex(ImGuiWindow* window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FindBottomMostVisibleWindowWithinBeginStack@ImGui@@YAPEAUImGuiWindow@@PEAU2@@Z", ExactSpelling = true)]
        public static extern ImGuiWindow* FindBottomMostVisibleWindowWithinBeginStack(ImGuiWindow* window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetCurrentFont@ImGui@@YAXPEAUImFont@@@Z", ExactSpelling = true)]
        public static extern void SetCurrentFont(ImFont* font);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetDefaultFont@ImGui@@YAPEAUImFont@@XZ", ExactSpelling = true)]
        public static extern ImFont* GetDefaultFont();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetForegroundDrawList@ImGui@@YAPEAUImDrawList@@PEAUImGuiWindow@@@Z", ExactSpelling = true)]
        public static extern ImDrawList* GetForegroundDrawList(ImGuiWindow* window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Initialize@ImGui@@YAXPEAUImGuiContext@@@Z", ExactSpelling = true)]
        public static extern void Initialize(ImGuiContext* context);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Shutdown@ImGui@@YAXPEAUImGuiContext@@@Z", ExactSpelling = true)]
        public static extern void Shutdown(ImGuiContext* context);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?UpdateInputEvents@ImGui@@YAX_N@Z", ExactSpelling = true)]
        private static extern void UpdateInputEvents_PInvoke(byte trickle_fast_inputs);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void UpdateInputEvents(bool trickle_fast_inputs)
        {
            UpdateInputEvents_PInvoke(Unsafe.As<bool, byte>(ref trickle_fast_inputs));
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?UpdateHoveredWindowAndCaptureFlags@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void UpdateHoveredWindowAndCaptureFlags();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?StartMouseMovingWindow@ImGui@@YAXPEAUImGuiWindow@@@Z", ExactSpelling = true)]
        public static extern void StartMouseMovingWindow(ImGuiWindow* window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?StartMouseMovingWindowOrNode@ImGui@@YAXPEAUImGuiWindow@@PEAUImGuiDockNode@@_N@Z", ExactSpelling = true)]
        private static extern void StartMouseMovingWindowOrNode_PInvoke(ImGuiWindow* window, ImGuiDockNode* node, byte undock_floating_node);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void StartMouseMovingWindowOrNode(ImGuiWindow* window, ImGuiDockNode* node, bool undock_floating_node)
        {
            StartMouseMovingWindowOrNode_PInvoke(window, node, Unsafe.As<bool, byte>(ref undock_floating_node));
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?UpdateMouseMovingWindowNewFrame@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void UpdateMouseMovingWindowNewFrame();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?UpdateMouseMovingWindowEndFrame@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void UpdateMouseMovingWindowEndFrame();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?AddContextHook@ImGui@@YAIPEAUImGuiContext@@PEBUImGuiContextHook@@@Z", ExactSpelling = true)]
        public static extern uint AddContextHook(ImGuiContext* context, ImGuiContextHook* hook);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RemoveContextHook@ImGui@@YAXPEAUImGuiContext@@I@Z", ExactSpelling = true)]
        public static extern void RemoveContextHook(ImGuiContext* context, uint hook_to_remove);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CallContextHooks@ImGui@@YAXPEAUImGuiContext@@W4ImGuiContextHookType@@@Z", ExactSpelling = true)]
        public static extern void CallContextHooks(ImGuiContext* context, ImGuiContextHookType type);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TranslateWindowsInViewport@ImGui@@YAXPEAUImGuiViewportP@@AEBUImVec2@@1@Z", ExactSpelling = true)]
        private static extern void TranslateWindowsInViewport_PInvoke(ImGuiViewportP* viewport, Vector2* old_pos, Vector2* new_pos);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TranslateWindowsInViewport(ImGuiViewportP* viewport, in Vector2 old_pos, in Vector2 new_pos)
        {
            fixed (Vector2* __old_posP = &old_pos)
            fixed (Vector2* __new_posP = &new_pos)
            { TranslateWindowsInViewport_PInvoke(viewport, __old_posP, __new_posP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ScaleWindowsInViewport@ImGui@@YAXPEAUImGuiViewportP@@M@Z", ExactSpelling = true)]
        public static extern void ScaleWindowsInViewport(ImGuiViewportP* viewport, float scale);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DestroyPlatformWindow@ImGui@@YAXPEAUImGuiViewportP@@@Z", ExactSpelling = true)]
        public static extern void DestroyPlatformWindow(ImGuiViewportP* viewport);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetCurrentViewport@ImGui@@YAXPEAUImGuiWindow@@PEAUImGuiViewportP@@@Z", ExactSpelling = true)]
        public static extern void SetCurrentViewport(ImGuiWindow* window, ImGuiViewportP* viewport);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetViewportPlatformMonitor@ImGui@@YAPEBUImGuiPlatformMonitor@@PEAUImGuiViewport@@@Z", ExactSpelling = true)]
        public static extern ImGuiPlatformMonitor* GetViewportPlatformMonitor(ImGuiViewport* viewport);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FindHoveredViewportFromPlatformWindowStack@ImGui@@YAPEAUImGuiViewportP@@AEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern ImGuiViewportP* FindHoveredViewportFromPlatformWindowStack_PInvoke(Vector2* mouse_platform_pos);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ImGuiViewportP* FindHoveredViewportFromPlatformWindowStack(in Vector2 mouse_platform_pos)
        {
            fixed (Vector2* __mouse_platform_posP = &mouse_platform_pos)
            { return FindHoveredViewportFromPlatformWindowStack_PInvoke(__mouse_platform_posP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?MarkIniSettingsDirty@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void MarkIniSettingsDirty();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?MarkIniSettingsDirty@ImGui@@YAXPEAUImGuiWindow@@@Z", ExactSpelling = true)]
        public static extern void MarkIniSettingsDirty(ImGuiWindow* window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ClearIniSettings@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void ClearIniSettings();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CreateNewWindowSettings@ImGui@@YAPEAUImGuiWindowSettings@@PEBD@Z", ExactSpelling = true)]
        public static extern ImGuiWindowSettings* CreateNewWindowSettings(byte* name);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ImGuiWindowSettings* CreateNewWindowSettings(DearImGuiInterpolatedStringHandler name)
        {
            ImGuiWindowSettings* __result;

            fixed (byte* __nameP = name.NullTerminateAndGetString())
            { __result = CreateNewWindowSettings(__nameP); }

            name.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FindWindowSettings@ImGui@@YAPEAUImGuiWindowSettings@@I@Z", ExactSpelling = true)]
        public static extern ImGuiWindowSettings* FindWindowSettings(uint id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FindOrCreateWindowSettings@ImGui@@YAPEAUImGuiWindowSettings@@PEBD@Z", ExactSpelling = true)]
        public static extern ImGuiWindowSettings* FindOrCreateWindowSettings(byte* name);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ImGuiWindowSettings* FindOrCreateWindowSettings(DearImGuiInterpolatedStringHandler name)
        {
            ImGuiWindowSettings* __result;

            fixed (byte* __nameP = name.NullTerminateAndGetString())
            { __result = FindOrCreateWindowSettings(__nameP); }

            name.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FindSettingsHandler@ImGui@@YAPEAUImGuiSettingsHandler@@PEBD@Z", ExactSpelling = true)]
        public static extern ImGuiSettingsHandler* FindSettingsHandler(byte* type_name);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ImGuiSettingsHandler* FindSettingsHandler(DearImGuiInterpolatedStringHandler type_name)
        {
            ImGuiSettingsHandler* __result;

            fixed (byte* __type_nameP = type_name.NullTerminateAndGetString())
            { __result = FindSettingsHandler(__type_nameP); }

            type_name.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetNextWindowScroll@ImGui@@YAXAEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern void SetNextWindowScroll_PInvoke(Vector2* scroll);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetNextWindowScroll(in Vector2 scroll)
        {
            fixed (Vector2* __scrollP = &scroll)
            { SetNextWindowScroll_PInvoke(__scrollP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetScrollX@ImGui@@YAXPEAUImGuiWindow@@M@Z", ExactSpelling = true)]
        public static extern void SetScrollX(ImGuiWindow* window, float scroll_x);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetScrollY@ImGui@@YAXPEAUImGuiWindow@@M@Z", ExactSpelling = true)]
        public static extern void SetScrollY(ImGuiWindow* window, float scroll_y);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetScrollFromPosX@ImGui@@YAXPEAUImGuiWindow@@MM@Z", ExactSpelling = true)]
        public static extern void SetScrollFromPosX(ImGuiWindow* window, float local_x, float center_x_ratio);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetScrollFromPosY@ImGui@@YAXPEAUImGuiWindow@@MM@Z", ExactSpelling = true)]
        public static extern void SetScrollFromPosY(ImGuiWindow* window, float local_y, float center_y_ratio);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ScrollToItem@ImGui@@YAXH@Z", ExactSpelling = true)]
        public static extern void ScrollToItem(ImGuiScrollFlags flags = ImGuiScrollFlags.None);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ScrollToRect@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@H@Z", ExactSpelling = true)]
        private static extern void ScrollToRect_PInvoke(ImGuiWindow* window, ImRect* rect, ImGuiScrollFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ScrollToRect(ImGuiWindow* window, in ImRect rect, ImGuiScrollFlags flags = ImGuiScrollFlags.None)
        {
            fixed (ImRect* __rectP = &rect)
            { ScrollToRect_PInvoke(window, __rectP, flags); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ScrollToRectEx@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@AEBUImRect@@H@Z", ExactSpelling = true)]
        private static extern Vector2* ScrollToRectEx_PInvoke(Vector2* __returnBuffer, ImGuiWindow* window, ImRect* rect, ImGuiScrollFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 ScrollToRectEx(ImGuiWindow* window, in ImRect rect, ImGuiScrollFlags flags = ImGuiScrollFlags.None)
        {
            Vector2 __returnBuffer;

            fixed (ImRect* __rectP = &rect)
            { ScrollToRectEx_PInvoke(&__returnBuffer, window, __rectP, flags); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ScrollToBringRectIntoView@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z", ExactSpelling = true)]
        private static extern void ScrollToBringRectIntoView_PInvoke(ImGuiWindow* window, ImRect* rect);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ScrollToBringRectIntoView(ImGuiWindow* window, in ImRect rect)
        {
            fixed (ImRect* __rectP = &rect)
            { ScrollToBringRectIntoView_PInvoke(window, __rectP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetItemID@ImGui@@YAIXZ", ExactSpelling = true)]
        public static extern uint GetItemID();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetItemStatusFlags@ImGui@@YAHXZ", ExactSpelling = true)]
        public static extern ImGuiItemStatusFlags GetItemStatusFlags();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetItemFlags@ImGui@@YAHXZ", ExactSpelling = true)]
        public static extern ImGuiItemFlags GetItemFlags();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetActiveID@ImGui@@YAIXZ", ExactSpelling = true)]
        public static extern uint GetActiveID();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetFocusID@ImGui@@YAIXZ", ExactSpelling = true)]
        public static extern uint GetFocusID();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z", ExactSpelling = true)]
        public static extern void SetActiveID(uint id, ImGuiWindow* window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z", ExactSpelling = true)]
        public static extern void SetFocusID(uint id, ImGuiWindow* window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ClearActiveID@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void ClearActiveID();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetHoveredID@ImGui@@YAIXZ", ExactSpelling = true)]
        public static extern uint GetHoveredID();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetHoveredID@ImGui@@YAXI@Z", ExactSpelling = true)]
        public static extern void SetHoveredID(uint id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?KeepAliveID@ImGui@@YAXI@Z", ExactSpelling = true)]
        public static extern void KeepAliveID(uint id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?MarkItemEdited@ImGui@@YAXI@Z", ExactSpelling = true)]
        public static extern void MarkItemEdited(uint id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushOverrideID@ImGui@@YAXI@Z", ExactSpelling = true)]
        public static extern void PushOverrideID(uint id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetIDWithSeed@ImGui@@YAIPEBD0I@Z", ExactSpelling = true)]
        public static extern uint GetIDWithSeed(byte* str_id_begin, byte* str_id_end, uint seed);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint GetIDWithSeed(DearImGuiInterpolatedStringHandler str_id_begin, uint seed)
        {
            uint __result;
            ReadOnlySpan<byte> __str_id_begin = str_id_begin.NullTerminateAndGetString();

            fixed (byte* __str_id_beginP = __str_id_begin)
            { __result = GetIDWithSeed(__str_id_beginP, __str_id_beginP + __str_id_begin.Length, seed); }

            str_id_begin.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z", ExactSpelling = true)]
        private static extern void ItemSize_PInvoke(Vector2* size, float text_baseline_y);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ItemSize(in Vector2 size, float text_baseline_y = -1f)
        {
            fixed (Vector2* __sizeP = &size)
            { ItemSize_PInvoke(__sizeP, text_baseline_y); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ItemSize@ImGui@@YAXAEBUImRect@@M@Z", ExactSpelling = true)]
        private static extern void ItemSize_PInvoke(ImRect* bb, float text_baseline_y);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ItemSize(in ImRect bb, float text_baseline_y = -1f)
        {
            fixed (ImRect* __bbP = &bb)
            { ItemSize_PInvoke(__bbP, text_baseline_y); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@H@Z", ExactSpelling = true)]
        private static extern byte ItemAdd_PInvoke(ImRect* bb, uint id, ImRect* nav_bb, ImGuiItemFlags extra_flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ItemAdd(in ImRect bb, uint id, ImRect* nav_bb = null, ImGuiItemFlags extra_flags = ImGuiItemFlags.None)
        {
            byte __result;

            fixed (ImRect* __bbP = &bb)
            { __result = ItemAdd_PInvoke(__bbP, id, nav_bb, extra_flags); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z", ExactSpelling = true)]
        private static extern byte ItemHoverable_PInvoke(ImRect* bb, uint id);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ItemHoverable(in ImRect bb, uint id)
        {
            byte __result;

            fixed (ImRect* __bbP = &bb)
            { __result = ItemHoverable_PInvoke(__bbP, id); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsClippedEx@ImGui@@YA_NAEBUImRect@@I@Z", ExactSpelling = true)]
        private static extern byte IsClippedEx_PInvoke(ImRect* bb, uint id);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsClippedEx(in ImRect bb, uint id)
        {
            byte __result;

            fixed (ImRect* __bbP = &bb)
            { __result = IsClippedEx_PInvoke(__bbP, id); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetLastItemData@ImGui@@YAXIHHAEBUImRect@@@Z", ExactSpelling = true)]
        private static extern void SetLastItemData_PInvoke(uint item_id, ImGuiItemFlags in_flags, ImGuiItemStatusFlags status_flags, ImRect* item_rect);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetLastItemData(uint item_id, ImGuiItemFlags in_flags, ImGuiItemStatusFlags status_flags, in ImRect item_rect)
        {
            fixed (ImRect* __item_rectP = &item_rect)
            { SetLastItemData_PInvoke(item_id, in_flags, status_flags, __item_rectP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z", ExactSpelling = true)]
        private static extern Vector2* CalcItemSize_PInvoke(Vector2* __returnBuffer, Vector2 size, float default_w, float default_h);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 CalcItemSize(Vector2 size, float default_w, float default_h)
        {
            Vector2 __returnBuffer;

            CalcItemSize_PInvoke(&__returnBuffer, size, default_w, default_h);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CalcWrapWidthForPos@ImGui@@YAMAEBUImVec2@@M@Z", ExactSpelling = true)]
        private static extern float CalcWrapWidthForPos_PInvoke(Vector2* pos, float wrap_pos_x);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float CalcWrapWidthForPos(in Vector2 pos, float wrap_pos_x)
        {
            fixed (Vector2* __posP = &pos)
            { return CalcWrapWidthForPos_PInvoke(__posP, wrap_pos_x); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushMultiItemsWidths@ImGui@@YAXHM@Z", ExactSpelling = true)]
        public static extern void PushMultiItemsWidths(int components, float width_full);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsItemToggledSelection@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte IsItemToggledSelection_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsItemToggledSelection()
        {
            byte __result;

            __result = IsItemToggledSelection_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetContentRegionMaxAbs@ImGui@@YA?AUImVec2@@XZ", ExactSpelling = true)]
        private static extern Vector2* GetContentRegionMaxAbs_PInvoke(Vector2* __returnBuffer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetContentRegionMaxAbs()
        {
            Vector2 __returnBuffer;

            GetContentRegionMaxAbs_PInvoke(&__returnBuffer);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z", ExactSpelling = true)]
        public static extern void ShrinkWidths(ImGuiShrinkWidthItem* items, int count, float width_excess);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushItemFlag@ImGui@@YAXH_N@Z", ExactSpelling = true)]
        private static extern void PushItemFlag_PInvoke(ImGuiItemFlags option, byte enabled);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void PushItemFlag(ImGuiItemFlags option, bool enabled)
        {
            PushItemFlag_PInvoke(option, Unsafe.As<bool, byte>(ref enabled));
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PopItemFlag@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void PopItemFlag();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?LogBegin@ImGui@@YAXW4ImGuiLogType@@H@Z", ExactSpelling = true)]
        public static extern void LogBegin(ImGuiLogType type, int auto_open_depth);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?LogToBuffer@ImGui@@YAXH@Z", ExactSpelling = true)]
        public static extern void LogToBuffer(int auto_open_depth = -1);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?LogRenderedText@ImGui@@YAXPEBUImVec2@@PEBD1@Z", ExactSpelling = true)]
        public static extern void LogRenderedText(Vector2* ref_pos, byte* text, byte* text_end = null);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogRenderedText(Vector2* ref_pos, DearImGuiInterpolatedStringHandler text)
        {
            ReadOnlySpan<byte> __text = text.NullTerminateAndGetString();

            fixed (byte* __textP = __text)
            { LogRenderedText(ref_pos, __textP, __textP + __text.Length); }

            text.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?LogSetNextTextDecoration@ImGui@@YAXPEBD0@Z", ExactSpelling = true)]
        public static extern void LogSetNextTextDecoration(byte* prefix, byte* suffix);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogSetNextTextDecoration(DearImGuiInterpolatedStringHandler prefix, DearImGuiInterpolatedStringHandler suffix)
        {
            fixed (byte* __prefixP = prefix.NullTerminateAndGetString())
            fixed (byte* __suffixP = suffix.NullTerminateAndGetString())
            { LogSetNextTextDecoration(__prefixP, __suffixP); }

            prefix.Dispose();
            suffix.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginChildEx@ImGui@@YA_NPEBDIAEBUImVec2@@_NH@Z", ExactSpelling = true)]
        private static extern byte BeginChildEx_PInvoke(byte* name, uint id, Vector2* size_arg, byte border, ImGuiWindowFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginChildEx(byte* name, uint id, in Vector2 size_arg, bool border, ImGuiWindowFlags flags)
        {
            byte __result;

            fixed (Vector2* __size_argP = &size_arg)
            { __result = BeginChildEx_PInvoke(name, id, __size_argP, Unsafe.As<bool, byte>(ref border), flags); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginChildEx(DearImGuiInterpolatedStringHandler name, uint id, in Vector2 size_arg, bool border, ImGuiWindowFlags flags)
        {
            byte __result;

            fixed (byte* __nameP = name.NullTerminateAndGetString())
            fixed (Vector2* __size_argP = &size_arg)
            { __result = BeginChildEx_PInvoke(__nameP, id, __size_argP, Unsafe.As<bool, byte>(ref border), flags); }

            name.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?OpenPopupEx@ImGui@@YAXIH@Z", ExactSpelling = true)]
        public static extern void OpenPopupEx(uint id, ImGuiPopupFlags popup_flags = ImGuiPopupFlags.None);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ClosePopupToLevel@ImGui@@YAXH_N@Z", ExactSpelling = true)]
        private static extern void ClosePopupToLevel_PInvoke(int remaining, byte restore_focus_to_window_under_popup);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup)
        {
            ClosePopupToLevel_PInvoke(remaining, Unsafe.As<bool, byte>(ref restore_focus_to_window_under_popup));
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ClosePopupsOverWindow@ImGui@@YAXPEAUImGuiWindow@@_N@Z", ExactSpelling = true)]
        private static extern void ClosePopupsOverWindow_PInvoke(ImGuiWindow* ref_window, byte restore_focus_to_window_under_popup);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ClosePopupsOverWindow(ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup)
        {
            ClosePopupsOverWindow_PInvoke(ref_window, Unsafe.As<bool, byte>(ref restore_focus_to_window_under_popup));
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ClosePopupsExceptModals@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void ClosePopupsExceptModals();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsPopupOpen@ImGui@@YA_NIH@Z", ExactSpelling = true)]
        private static extern byte IsPopupOpen_PInvoke(uint id, ImGuiPopupFlags popup_flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPopupOpen(uint id, ImGuiPopupFlags popup_flags)
        {
            byte __result;

            __result = IsPopupOpen_PInvoke(id, popup_flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginPopupEx@ImGui@@YA_NIH@Z", ExactSpelling = true)]
        private static extern byte BeginPopupEx_PInvoke(uint id, ImGuiWindowFlags extra_flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginPopupEx(uint id, ImGuiWindowFlags extra_flags)
        {
            byte __result;

            __result = BeginPopupEx_PInvoke(id, extra_flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginTooltipEx@ImGui@@YAXHH@Z", ExactSpelling = true)]
        public static extern void BeginTooltipEx(ImGuiTooltipFlags tooltip_flags, ImGuiWindowFlags extra_window_flags);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetPopupAllowedExtentRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@@Z", ExactSpelling = true)]
        private static extern ImRect* GetPopupAllowedExtentRect_PInvoke(ImRect* __returnBuffer, ImGuiWindow* window);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ImRect GetPopupAllowedExtentRect(ImGuiWindow* window)
        {
            ImRect __returnBuffer;

            GetPopupAllowedExtentRect_PInvoke(&__returnBuffer, window);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetTopMostPopupModal@ImGui@@YAPEAUImGuiWindow@@XZ", ExactSpelling = true)]
        public static extern ImGuiWindow* GetTopMostPopupModal();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetTopMostAndVisiblePopupModal@ImGui@@YAPEAUImGuiWindow@@XZ", ExactSpelling = true)]
        public static extern ImGuiWindow* GetTopMostAndVisiblePopupModal();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FindBestWindowPosForPopup@ImGui@@YA?AUImVec2@@PEAUImGuiWindow@@@Z", ExactSpelling = true)]
        private static extern Vector2* FindBestWindowPosForPopup_PInvoke(Vector2* __returnBuffer, ImGuiWindow* window);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 FindBestWindowPosForPopup(ImGuiWindow* window)
        {
            Vector2 __returnBuffer;

            FindBestWindowPosForPopup_PInvoke(&__returnBuffer, window);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FindBestWindowPosForPopupEx@ImGui@@YA?AUImVec2@@AEBU2@0PEAHAEBUImRect@@2W4ImGuiPopupPositionPolicy@@@Z", ExactSpelling = true)]
        private static extern Vector2* FindBestWindowPosForPopupEx_PInvoke(Vector2* __returnBuffer, Vector2* ref_pos, Vector2* size, ImGuiDir* last_dir, ImRect* r_outer, ImRect* r_avoid, ImGuiPopupPositionPolicy policy);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 FindBestWindowPosForPopupEx(in Vector2 ref_pos, in Vector2 size, ImGuiDir* last_dir, in ImRect r_outer, in ImRect r_avoid, ImGuiPopupPositionPolicy policy)
        {
            Vector2 __returnBuffer;

            fixed (Vector2* __ref_posP = &ref_pos)
            fixed (Vector2* __sizeP = &size)
            fixed (ImRect* __r_outerP = &r_outer)
            fixed (ImRect* __r_avoidP = &r_avoid)
            { FindBestWindowPosForPopupEx_PInvoke(&__returnBuffer, __ref_posP, __sizeP, last_dir, __r_outerP, __r_avoidP, policy); }

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginViewportSideBar@ImGui@@YA_NPEBDPEAUImGuiViewport@@HMH@Z", ExactSpelling = true)]
        private static extern byte BeginViewportSideBar_PInvoke(byte* name, ImGuiViewport* viewport, ImGuiDir dir, float size, ImGuiWindowFlags window_flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginViewportSideBar(byte* name, ImGuiViewport* viewport, ImGuiDir dir, float size, ImGuiWindowFlags window_flags)
        {
            byte __result;

            __result = BeginViewportSideBar_PInvoke(name, viewport, dir, size, window_flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginViewportSideBar(DearImGuiInterpolatedStringHandler name, ImGuiViewport* viewport, ImGuiDir dir, float size, ImGuiWindowFlags window_flags)
        {
            byte __result;

            fixed (byte* __nameP = name.NullTerminateAndGetString())
            { __result = BeginViewportSideBar_PInvoke(__nameP, viewport, dir, size, window_flags); }

            name.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginMenuEx@ImGui@@YA_NPEBD0_N@Z", ExactSpelling = true)]
        private static extern byte BeginMenuEx_PInvoke(byte* label, byte* icon, byte enabled);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginMenuEx(byte* label, byte* icon, bool enabled = true)
        {
            byte __result;

            __result = BeginMenuEx_PInvoke(label, icon, Unsafe.As<bool, byte>(ref enabled));

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginMenuEx(DearImGuiInterpolatedStringHandler label, DearImGuiInterpolatedStringHandler icon, bool enabled = true)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __iconP = icon.NullTerminateAndGetString())
            { __result = BeginMenuEx_PInvoke(__labelP, __iconP, Unsafe.As<bool, byte>(ref enabled)); }

            label.Dispose();
            icon.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?MenuItemEx@ImGui@@YA_NPEBD00_N1@Z", ExactSpelling = true)]
        private static extern byte MenuItemEx_PInvoke(byte* label, byte* icon, byte* shortcut, byte selected, byte enabled);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool MenuItemEx(byte* label, byte* icon, byte* shortcut = null, bool selected = false, bool enabled = true)
        {
            byte __result;

            __result = MenuItemEx_PInvoke(label, icon, shortcut, Unsafe.As<bool, byte>(ref selected), Unsafe.As<bool, byte>(ref enabled));

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool MenuItemEx(DearImGuiInterpolatedStringHandler label, DearImGuiInterpolatedStringHandler icon, DearImGuiInterpolatedStringHandler shortcut, bool selected = false, bool enabled = true)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __iconP = icon.NullTerminateAndGetString())
            fixed (byte* __shortcutP = shortcut.NullTerminateAndGetString())
            { __result = MenuItemEx_PInvoke(__labelP, __iconP, __shortcutP, Unsafe.As<bool, byte>(ref selected), Unsafe.As<bool, byte>(ref enabled)); }

            label.Dispose();
            icon.Dispose();
            shortcut.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginComboPopup@ImGui@@YA_NIAEBUImRect@@H@Z", ExactSpelling = true)]
        private static extern byte BeginComboPopup_PInvoke(uint popup_id, ImRect* bb, ImGuiComboFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginComboPopup(uint popup_id, in ImRect bb, ImGuiComboFlags flags)
        {
            byte __result;

            fixed (ImRect* __bbP = &bb)
            { __result = BeginComboPopup_PInvoke(popup_id, __bbP, flags); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginComboPreview@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte BeginComboPreview_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginComboPreview()
        {
            byte __result;

            __result = BeginComboPreview_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndComboPreview@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndComboPreview();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?NavInitWindow@ImGui@@YAXPEAUImGuiWindow@@_N@Z", ExactSpelling = true)]
        private static extern void NavInitWindow_PInvoke(ImGuiWindow* window, byte force_reinit);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void NavInitWindow(ImGuiWindow* window, bool force_reinit)
        {
            NavInitWindow_PInvoke(window, Unsafe.As<bool, byte>(ref force_reinit));
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?NavInitRequestApplyResult@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void NavInitRequestApplyResult();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?NavMoveRequestButNoResultYet@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte NavMoveRequestButNoResultYet_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool NavMoveRequestButNoResultYet()
        {
            byte __result;

            __result = NavMoveRequestButNoResultYet_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?NavMoveRequestSubmit@ImGui@@YAXHHHH@Z", ExactSpelling = true)]
        public static extern void NavMoveRequestSubmit(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?NavMoveRequestForward@ImGui@@YAXHHHH@Z", ExactSpelling = true)]
        public static extern void NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?NavMoveRequestResolveWithLastItem@ImGui@@YAXPEAUImGuiNavItemData@@@Z", ExactSpelling = true)]
        public static extern void NavMoveRequestResolveWithLastItem(ImGuiNavItemData* result);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?NavMoveRequestCancel@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void NavMoveRequestCancel();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?NavMoveRequestApplyResult@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void NavMoveRequestApplyResult();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?NavMoveRequestTryWrapping@ImGui@@YAXPEAUImGuiWindow@@H@Z", ExactSpelling = true)]
        public static extern void NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetNavInputName@ImGui@@YAPEBDH@Z", ExactSpelling = true)]
        public static extern byte* GetNavInputName(ImGuiNavInput n);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetNavInputAmount@ImGui@@YAMHW4ImGuiInputReadMode@@@Z", ExactSpelling = true)]
        public static extern float GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetNavInputAmount2d@ImGui@@YA?AUImVec2@@HW4ImGuiInputReadMode@@MM@Z", ExactSpelling = true)]
        private static extern Vector2* GetNavInputAmount2d_PInvoke(Vector2* __returnBuffer, ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor, float fast_factor);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor = 0f, float fast_factor = 0f)
        {
            Vector2 __returnBuffer;

            GetNavInputAmount2d_PInvoke(&__returnBuffer, dir_sources, mode, slow_factor, fast_factor);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CalcTypematicRepeatAmount@ImGui@@YAHMMMM@Z", ExactSpelling = true)]
        public static extern int CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ActivateItem@ImGui@@YAXI@Z", ExactSpelling = true)]
        public static extern void ActivateItem(uint id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetNavID@ImGui@@YAXIW4ImGuiNavLayer@@IAEBUImRect@@@Z", ExactSpelling = true)]
        private static extern void SetNavID_PInvoke(uint id, ImGuiNavLayer nav_layer, uint focus_scope_id, ImRect* rect_rel);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetNavID(uint id, ImGuiNavLayer nav_layer, uint focus_scope_id, in ImRect rect_rel)
        {
            fixed (ImRect* __rect_relP = &rect_rel)
            { SetNavID_PInvoke(id, nav_layer, focus_scope_id, __rect_relP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushFocusScope@ImGui@@YAXI@Z", ExactSpelling = true)]
        public static extern void PushFocusScope(uint id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PopFocusScope@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void PopFocusScope();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetFocusedFocusScope@ImGui@@YAIXZ", ExactSpelling = true)]
        public static extern uint GetFocusedFocusScope();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetFocusScope@ImGui@@YAIXZ", ExactSpelling = true)]
        public static extern uint GetFocusScope();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsNamedKey@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte IsNamedKey_PInvoke(ImGuiKey key);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsNamedKey(ImGuiKey key)
        {
            byte __result;

            __result = IsNamedKey_PInvoke(key);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsLegacyKey@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte IsLegacyKey_PInvoke(ImGuiKey key);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsLegacyKey(ImGuiKey key)
        {
            byte __result;

            __result = IsLegacyKey_PInvoke(key);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsGamepadKey@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte IsGamepadKey_PInvoke(ImGuiKey key);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsGamepadKey(ImGuiKey key)
        {
            byte __result;

            __result = IsGamepadKey_PInvoke(key);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetKeyData@ImGui@@YAPEAUImGuiKeyData@@H@Z", ExactSpelling = true)]
        public static extern ImGuiKeyData* GetKeyData(ImGuiKey key);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetItemUsingMouseWheel@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void SetItemUsingMouseWheel();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetActiveIdUsingNavAndKeys@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void SetActiveIdUsingNavAndKeys();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsActiveIdUsingNavDir@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte IsActiveIdUsingNavDir_PInvoke(ImGuiDir dir);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsActiveIdUsingNavDir(ImGuiDir dir)
        {
            byte __result;

            __result = IsActiveIdUsingNavDir_PInvoke(dir);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsActiveIdUsingNavInput@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte IsActiveIdUsingNavInput_PInvoke(ImGuiNavInput input);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsActiveIdUsingNavInput(ImGuiNavInput input)
        {
            byte __result;

            __result = IsActiveIdUsingNavInput_PInvoke(input);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsActiveIdUsingKey@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte IsActiveIdUsingKey_PInvoke(ImGuiKey key);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsActiveIdUsingKey(ImGuiKey key)
        {
            byte __result;

            __result = IsActiveIdUsingKey_PInvoke(key);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetActiveIdUsingKey@ImGui@@YAXH@Z", ExactSpelling = true)]
        public static extern void SetActiveIdUsingKey(ImGuiKey key);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsMouseDragPastThreshold@ImGui@@YA_NHM@Z", ExactSpelling = true)]
        private static extern byte IsMouseDragPastThreshold_PInvoke(ImGuiMouseButton button, float lock_threshold);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsMouseDragPastThreshold(ImGuiMouseButton button, float lock_threshold = -1f)
        {
            byte __result;

            __result = IsMouseDragPastThreshold_PInvoke(button, lock_threshold);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsNavInputDown@ImGui@@YA_NH@Z", ExactSpelling = true)]
        private static extern byte IsNavInputDown_PInvoke(ImGuiNavInput n);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsNavInputDown(ImGuiNavInput n)
        {
            byte __result;

            __result = IsNavInputDown_PInvoke(n);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsNavInputTest@ImGui@@YA_NHW4ImGuiInputReadMode@@@Z", ExactSpelling = true)]
        private static extern byte IsNavInputTest_PInvoke(ImGuiNavInput n, ImGuiInputReadMode rm);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsNavInputTest(ImGuiNavInput n, ImGuiInputReadMode rm)
        {
            byte __result;

            __result = IsNavInputTest_PInvoke(n, rm);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetMergedKeyModFlags@ImGui@@YAHXZ", ExactSpelling = true)]
        public static extern ImGuiKeyModFlags GetMergedKeyModFlags();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsKeyPressedMap@ImGui@@YA_NH_N@Z", ExactSpelling = true)]
        private static extern byte IsKeyPressedMap_PInvoke(ImGuiKey key, byte repeat);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsKeyPressedMap(ImGuiKey key, bool repeat = true)
        {
            byte __result;

            __result = IsKeyPressedMap_PInvoke(key, Unsafe.As<bool, byte>(ref repeat));

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockContextInitialize@ImGui@@YAXPEAUImGuiContext@@@Z", ExactSpelling = true)]
        public static extern void DockContextInitialize(ImGuiContext* ctx);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockContextShutdown@ImGui@@YAXPEAUImGuiContext@@@Z", ExactSpelling = true)]
        public static extern void DockContextShutdown(ImGuiContext* ctx);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockContextClearNodes@ImGui@@YAXPEAUImGuiContext@@I_N@Z", ExactSpelling = true)]
        private static extern void DockContextClearNodes_PInvoke(ImGuiContext* ctx, uint root_id, byte clear_settings_refs);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DockContextClearNodes(ImGuiContext* ctx, uint root_id, bool clear_settings_refs)
        {
            DockContextClearNodes_PInvoke(ctx, root_id, Unsafe.As<bool, byte>(ref clear_settings_refs));
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockContextRebuildNodes@ImGui@@YAXPEAUImGuiContext@@@Z", ExactSpelling = true)]
        public static extern void DockContextRebuildNodes(ImGuiContext* ctx);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockContextNewFrameUpdateUndocking@ImGui@@YAXPEAUImGuiContext@@@Z", ExactSpelling = true)]
        public static extern void DockContextNewFrameUpdateUndocking(ImGuiContext* ctx);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockContextNewFrameUpdateDocking@ImGui@@YAXPEAUImGuiContext@@@Z", ExactSpelling = true)]
        public static extern void DockContextNewFrameUpdateDocking(ImGuiContext* ctx);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockContextEndFrame@ImGui@@YAXPEAUImGuiContext@@@Z", ExactSpelling = true)]
        public static extern void DockContextEndFrame(ImGuiContext* ctx);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockContextGenNodeID@ImGui@@YAIPEAUImGuiContext@@@Z", ExactSpelling = true)]
        public static extern uint DockContextGenNodeID(ImGuiContext* ctx);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockContextQueueDock@ImGui@@YAXPEAUImGuiContext@@PEAUImGuiWindow@@PEAUImGuiDockNode@@1HM_N@Z", ExactSpelling = true)]
        private static extern void DockContextQueueDock_PInvoke(ImGuiContext* ctx, ImGuiWindow* target, ImGuiDockNode* target_node, ImGuiWindow* payload, ImGuiDir split_dir, float split_ratio, byte split_outer);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DockContextQueueDock(ImGuiContext* ctx, ImGuiWindow* target, ImGuiDockNode* target_node, ImGuiWindow* payload, ImGuiDir split_dir, float split_ratio, bool split_outer)
        {
            DockContextQueueDock_PInvoke(ctx, target, target_node, payload, split_dir, split_ratio, Unsafe.As<bool, byte>(ref split_outer));
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockContextQueueUndockWindow@ImGui@@YAXPEAUImGuiContext@@PEAUImGuiWindow@@@Z", ExactSpelling = true)]
        public static extern void DockContextQueueUndockWindow(ImGuiContext* ctx, ImGuiWindow* window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockContextQueueUndockNode@ImGui@@YAXPEAUImGuiContext@@PEAUImGuiDockNode@@@Z", ExactSpelling = true)]
        public static extern void DockContextQueueUndockNode(ImGuiContext* ctx, ImGuiDockNode* node);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockContextCalcDropPosForDocking@ImGui@@YA_NPEAUImGuiWindow@@PEAUImGuiDockNode@@0H_NPEAUImVec2@@@Z", ExactSpelling = true)]
        private static extern byte DockContextCalcDropPosForDocking_PInvoke(ImGuiWindow* target, ImGuiDockNode* target_node, ImGuiWindow* payload, ImGuiDir split_dir, byte split_outer, Vector2* out_pos);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DockContextCalcDropPosForDocking(ImGuiWindow* target, ImGuiDockNode* target_node, ImGuiWindow* payload, ImGuiDir split_dir, bool split_outer, Vector2* out_pos)
        {
            byte __result;

            __result = DockContextCalcDropPosForDocking_PInvoke(target, target_node, payload, split_dir, Unsafe.As<bool, byte>(ref split_outer), out_pos);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockNodeBeginAmendTabBar@ImGui@@YA_NPEAUImGuiDockNode@@@Z", ExactSpelling = true)]
        private static extern byte DockNodeBeginAmendTabBar_PInvoke(ImGuiDockNode* node);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DockNodeBeginAmendTabBar(ImGuiDockNode* node)
        {
            byte __result;

            __result = DockNodeBeginAmendTabBar_PInvoke(node);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockNodeEndAmendTabBar@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void DockNodeEndAmendTabBar();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockNodeGetRootNode@ImGui@@YAPEAUImGuiDockNode@@PEAU2@@Z", ExactSpelling = true)]
        public static extern ImGuiDockNode* DockNodeGetRootNode(ImGuiDockNode* node);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockNodeIsInHierarchyOf@ImGui@@YA_NPEAUImGuiDockNode@@0@Z", ExactSpelling = true)]
        private static extern byte DockNodeIsInHierarchyOf_PInvoke(ImGuiDockNode* node, ImGuiDockNode* parent);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DockNodeIsInHierarchyOf(ImGuiDockNode* node, ImGuiDockNode* parent)
        {
            byte __result;

            __result = DockNodeIsInHierarchyOf_PInvoke(node, parent);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockNodeGetDepth@ImGui@@YAHPEBUImGuiDockNode@@@Z", ExactSpelling = true)]
        public static extern int DockNodeGetDepth(ImGuiDockNode* node);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockNodeGetWindowMenuButtonId@ImGui@@YAIPEBUImGuiDockNode@@@Z", ExactSpelling = true)]
        public static extern uint DockNodeGetWindowMenuButtonId(ImGuiDockNode* node);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetWindowDockNode@ImGui@@YAPEAUImGuiDockNode@@XZ", ExactSpelling = true)]
        public static extern ImGuiDockNode* GetWindowDockNode();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetWindowAlwaysWantOwnTabBar@ImGui@@YA_NPEAUImGuiWindow@@@Z", ExactSpelling = true)]
        private static extern byte GetWindowAlwaysWantOwnTabBar_PInvoke(ImGuiWindow* window);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool GetWindowAlwaysWantOwnTabBar(ImGuiWindow* window)
        {
            byte __result;

            __result = GetWindowAlwaysWantOwnTabBar_PInvoke(window);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginDocked@ImGui@@YAXPEAUImGuiWindow@@PEA_N@Z", ExactSpelling = true)]
        public static extern void BeginDocked(ImGuiWindow* window, bool* p_open);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginDockableDragDropSource@ImGui@@YAXPEAUImGuiWindow@@@Z", ExactSpelling = true)]
        public static extern void BeginDockableDragDropSource(ImGuiWindow* window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginDockableDragDropTarget@ImGui@@YAXPEAUImGuiWindow@@@Z", ExactSpelling = true)]
        public static extern void BeginDockableDragDropTarget(ImGuiWindow* window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetWindowDock@ImGui@@YAXPEAUImGuiWindow@@IH@Z", ExactSpelling = true)]
        public static extern void SetWindowDock(ImGuiWindow* window, uint dock_id, ImGuiCond cond);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockBuilderDockWindow@ImGui@@YAXPEBDI@Z", ExactSpelling = true)]
        public static extern void DockBuilderDockWindow(byte* window_name, uint node_id);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DockBuilderDockWindow(DearImGuiInterpolatedStringHandler window_name, uint node_id)
        {
            fixed (byte* __window_nameP = window_name.NullTerminateAndGetString())
            { DockBuilderDockWindow(__window_nameP, node_id); }

            window_name.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockBuilderGetNode@ImGui@@YAPEAUImGuiDockNode@@I@Z", ExactSpelling = true)]
        public static extern ImGuiDockNode* DockBuilderGetNode(uint node_id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockBuilderGetCentralNode@ImGui@@YAPEAUImGuiDockNode@@I@Z", ExactSpelling = true)]
        public static extern ImGuiDockNode* DockBuilderGetCentralNode(uint node_id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockBuilderAddNode@ImGui@@YAIIH@Z", ExactSpelling = true)]
        public static extern uint DockBuilderAddNode(uint node_id = 0, ImGuiDockNodeFlags flags = ImGuiDockNodeFlags.None);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockBuilderRemoveNode@ImGui@@YAXI@Z", ExactSpelling = true)]
        public static extern void DockBuilderRemoveNode(uint node_id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockBuilderRemoveNodeDockedWindows@ImGui@@YAXI_N@Z", ExactSpelling = true)]
        private static extern void DockBuilderRemoveNodeDockedWindows_PInvoke(uint node_id, byte clear_settings_refs);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DockBuilderRemoveNodeDockedWindows(uint node_id, bool clear_settings_refs = true)
        {
            DockBuilderRemoveNodeDockedWindows_PInvoke(node_id, Unsafe.As<bool, byte>(ref clear_settings_refs));
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockBuilderRemoveNodeChildNodes@ImGui@@YAXI@Z", ExactSpelling = true)]
        public static extern void DockBuilderRemoveNodeChildNodes(uint node_id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockBuilderSetNodePos@ImGui@@YAXIUImVec2@@@Z", ExactSpelling = true)]
        public static extern void DockBuilderSetNodePos(uint node_id, Vector2 pos);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockBuilderSetNodeSize@ImGui@@YAXIUImVec2@@@Z", ExactSpelling = true)]
        public static extern void DockBuilderSetNodeSize(uint node_id, Vector2 size);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockBuilderSplitNode@ImGui@@YAIIHMPEAI0@Z", ExactSpelling = true)]
        public static extern uint DockBuilderSplitNode(uint node_id, ImGuiDir split_dir, float size_ratio_for_node_at_dir, uint* out_id_at_dir, uint* out_id_at_opposite_dir);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockBuilderCopyDockSpace@ImGui@@YAXIIPEAU?$ImVector@PEBD@@@Z", ExactSpelling = true)]
        public static extern void DockBuilderCopyDockSpace(uint src_dockspace_id, uint dst_dockspace_id, ImVector<Pointer<byte>>* in_window_remap_pairs);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockBuilderCopyNode@ImGui@@YAXIIPEAU?$ImVector@I@@@Z", ExactSpelling = true)]
        public static extern void DockBuilderCopyNode(uint src_node_id, uint dst_node_id, ImVector<uint>* out_node_remap_pairs);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockBuilderCopyWindowSettings@ImGui@@YAXPEBD0@Z", ExactSpelling = true)]
        public static extern void DockBuilderCopyWindowSettings(byte* src_name, byte* dst_name);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DockBuilderCopyWindowSettings(DearImGuiInterpolatedStringHandler src_name, DearImGuiInterpolatedStringHandler dst_name)
        {
            fixed (byte* __src_nameP = src_name.NullTerminateAndGetString())
            fixed (byte* __dst_nameP = dst_name.NullTerminateAndGetString())
            { DockBuilderCopyWindowSettings(__src_nameP, __dst_nameP); }

            src_name.Dispose();
            dst_name.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DockBuilderFinish@ImGui@@YAXI@Z", ExactSpelling = true)]
        public static extern void DockBuilderFinish(uint node_id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginDragDropTargetCustom@ImGui@@YA_NAEBUImRect@@I@Z", ExactSpelling = true)]
        private static extern byte BeginDragDropTargetCustom_PInvoke(ImRect* bb, uint id);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginDragDropTargetCustom(in ImRect bb, uint id)
        {
            byte __result;

            fixed (ImRect* __bbP = &bb)
            { __result = BeginDragDropTargetCustom_PInvoke(__bbP, id); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ClearDragDrop@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void ClearDragDrop();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsDragDropPayloadBeingAccepted@ImGui@@YA_NXZ", ExactSpelling = true)]
        private static extern byte IsDragDropPayloadBeingAccepted_PInvoke();

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsDragDropPayloadBeingAccepted()
        {
            byte __result;

            __result = IsDragDropPayloadBeingAccepted_PInvoke();

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z", ExactSpelling = true)]
        private static extern void SetWindowClipRectBeforeSetChannel_PInvoke(ImGuiWindow* window, ImRect* clip_rect);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetWindowClipRectBeforeSetChannel(ImGuiWindow* window, in ImRect clip_rect)
        {
            fixed (ImRect* __clip_rectP = &clip_rect)
            { SetWindowClipRectBeforeSetChannel_PInvoke(window, __clip_rectP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginColumns@ImGui@@YAXPEBDHH@Z", ExactSpelling = true)]
        public static extern void BeginColumns(byte* str_id, int count, ImGuiOldColumnFlags flags = ImGuiOldColumnFlags.None);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void BeginColumns(DearImGuiInterpolatedStringHandler str_id, int count, ImGuiOldColumnFlags flags = ImGuiOldColumnFlags.None)
        {
            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            { BeginColumns(__str_idP, count, flags); }

            str_id.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?EndColumns@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void EndColumns();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushColumnClipRect@ImGui@@YAXH@Z", ExactSpelling = true)]
        public static extern void PushColumnClipRect(int column_index);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PushColumnsBackground@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void PushColumnsBackground();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PopColumnsBackground@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void PopColumnsBackground();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetColumnsID@ImGui@@YAIPEBDH@Z", ExactSpelling = true)]
        public static extern uint GetColumnsID(byte* str_id, int count);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint GetColumnsID(DearImGuiInterpolatedStringHandler str_id, int count)
        {
            uint __result;

            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            { __result = GetColumnsID(__str_idP, count); }

            str_id.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z", ExactSpelling = true)]
        public static extern ImGuiOldColumns* FindOrCreateColumns(ImGuiWindow* window, uint id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetColumnOffsetFromNorm@ImGui@@YAMPEBUImGuiOldColumns@@M@Z", ExactSpelling = true)]
        public static extern float GetColumnOffsetFromNorm(ImGuiOldColumns* columns, float offset_norm);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetColumnNormFromOffset@ImGui@@YAMPEBUImGuiOldColumns@@M@Z", ExactSpelling = true)]
        public static extern float GetColumnNormFromOffset(ImGuiOldColumns* columns, float offset);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableOpenContextMenu@ImGui@@YAXH@Z", ExactSpelling = true)]
        public static extern void TableOpenContextMenu(int column_n = -1);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableSetColumnWidth@ImGui@@YAXHM@Z", ExactSpelling = true)]
        public static extern void TableSetColumnWidth(int column_n, float width);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableSetColumnSortDirection@ImGui@@YAXHH_N@Z", ExactSpelling = true)]
        private static extern void TableSetColumnSortDirection_PInvoke(int column_n, ImGuiSortDirection sort_direction, byte append_to_sort_specs);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TableSetColumnSortDirection(int column_n, ImGuiSortDirection sort_direction, bool append_to_sort_specs)
        {
            TableSetColumnSortDirection_PInvoke(column_n, sort_direction, Unsafe.As<bool, byte>(ref append_to_sort_specs));
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGetHoveredColumn@ImGui@@YAHXZ", ExactSpelling = true)]
        public static extern int TableGetHoveredColumn();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGetHeaderRowHeight@ImGui@@YAMXZ", ExactSpelling = true)]
        public static extern float TableGetHeaderRowHeight();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TablePushBackgroundChannel@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void TablePushBackgroundChannel();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TablePopBackgroundChannel@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void TablePopBackgroundChannel();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetCurrentTable@ImGui@@YAPEAUImGuiTable@@XZ", ExactSpelling = true)]
        public static extern ImGuiTable* GetCurrentTable();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableFindByID@ImGui@@YAPEAUImGuiTable@@I@Z", ExactSpelling = true)]
        public static extern ImGuiTable* TableFindByID(uint id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z", ExactSpelling = true)]
        private static extern byte BeginTableEx_PInvoke(byte* name, uint id, int columns_count, ImGuiTableFlags flags, Vector2* outer_size, float inner_width);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginTableEx(byte* name, uint id, int columns_count, ImGuiTableFlags flags, in Vector2 outer_size, float inner_width = 0f)
        {
            byte __result;

            fixed (Vector2* __outer_sizeP = &outer_size)
            { __result = BeginTableEx_PInvoke(name, id, columns_count, flags, __outer_sizeP, inner_width); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginTableEx(DearImGuiInterpolatedStringHandler name, uint id, int columns_count, ImGuiTableFlags flags, in Vector2 outer_size, float inner_width = 0f)
        {
            byte __result;

            fixed (byte* __nameP = name.NullTerminateAndGetString())
            fixed (Vector2* __outer_sizeP = &outer_size)
            { __result = BeginTableEx_PInvoke(__nameP, id, columns_count, flags, __outer_sizeP, inner_width); }

            name.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableBeginInitMemory@ImGui@@YAXPEAUImGuiTable@@H@Z", ExactSpelling = true)]
        public static extern void TableBeginInitMemory(ImGuiTable* table, int columns_count);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableBeginApplyRequests@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableBeginApplyRequests(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableSetupDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableSetupDrawChannels(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableUpdateLayout(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableUpdateBorders(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableUpdateColumnsWeightFromWidth@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableUpdateColumnsWeightFromWidth(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableDrawBorders@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableDrawBorders(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableDrawContextMenu@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableDrawContextMenu(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableMergeDrawChannels(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableSortSpecsSanitize@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableSortSpecsSanitize(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableSortSpecsBuild@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableSortSpecsBuild(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGetColumnNextSortDirection@ImGui@@YAHPEAUImGuiTableColumn@@@Z", ExactSpelling = true)]
        public static extern ImGuiSortDirection TableGetColumnNextSortDirection(ImGuiTableColumn* column);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableFixColumnSortDirection@ImGui@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z", ExactSpelling = true)]
        public static extern void TableFixColumnSortDirection(ImGuiTable* table, ImGuiTableColumn* column);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGetColumnWidthAuto@ImGui@@YAMPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z", ExactSpelling = true)]
        public static extern float TableGetColumnWidthAuto(ImGuiTable* table, ImGuiTableColumn* column);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableBeginRow@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableBeginRow(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableEndRow(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableBeginCell@ImGui@@YAXPEAUImGuiTable@@H@Z", ExactSpelling = true)]
        public static extern void TableBeginCell(ImGuiTable* table, int column_n);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableEndCell@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableEndCell(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGetCellBgRect@ImGui@@YA?AUImRect@@PEBUImGuiTable@@H@Z", ExactSpelling = true)]
        private static extern ImRect* TableGetCellBgRect_PInvoke(ImRect* __returnBuffer, ImGuiTable* table, int column_n);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ImRect TableGetCellBgRect(ImGuiTable* table, int column_n)
        {
            ImRect __returnBuffer;

            TableGetCellBgRect_PInvoke(&__returnBuffer, table, column_n);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGetColumnName@ImGui@@YAPEBDPEBUImGuiTable@@H@Z", ExactSpelling = true)]
        public static extern byte* TableGetColumnName(ImGuiTable* table, int column_n);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGetColumnResizeID@ImGui@@YAIPEBUImGuiTable@@HH@Z", ExactSpelling = true)]
        public static extern uint TableGetColumnResizeID(ImGuiTable* table, int column_n, int instance_no = 0);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGetMaxColumnWidth@ImGui@@YAMPEBUImGuiTable@@H@Z", ExactSpelling = true)]
        public static extern float TableGetMaxColumnWidth(ImGuiTable* table, int column_n);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableSetColumnWidthAutoSingle@ImGui@@YAXPEAUImGuiTable@@H@Z", ExactSpelling = true)]
        public static extern void TableSetColumnWidthAutoSingle(ImGuiTable* table, int column_n);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableSetColumnWidthAutoAll@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableSetColumnWidthAutoAll(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableRemove@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableRemove(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableGcCompactTransientBuffers(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTableTempData@@@Z", ExactSpelling = true)]
        public static extern void TableGcCompactTransientBuffers(ImGuiTableTempData* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGcCompactSettings@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void TableGcCompactSettings();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableLoadSettings@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableLoadSettings(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableSaveSettings@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableSaveSettings(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableResetSettings@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void TableResetSettings(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableGetBoundSettings@ImGui@@YAPEAUImGuiTableSettings@@PEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern ImGuiTableSettings* TableGetBoundSettings(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableSettingsInstallHandler@ImGui@@YAXPEAUImGuiContext@@@Z", ExactSpelling = true)]
        public static extern void TableSettingsInstallHandler(ImGuiContext* context);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z", ExactSpelling = true)]
        public static extern ImGuiTableSettings* TableSettingsCreate(uint id, int columns_count);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TableSettingsFindByID@ImGui@@YAPEAUImGuiTableSettings@@I@Z", ExactSpelling = true)]
        public static extern ImGuiTableSettings* TableSettingsFindByID(uint id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z", ExactSpelling = true)]
        private static extern byte BeginTabBarEx_PInvoke(ImGuiTabBar* tab_bar, ImRect* bb, ImGuiTabBarFlags flags, ImGuiDockNode* dock_node);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool BeginTabBarEx(ImGuiTabBar* tab_bar, in ImRect bb, ImGuiTabBarFlags flags, ImGuiDockNode* dock_node)
        {
            byte __result;

            fixed (ImRect* __bbP = &bb)
            { __result = BeginTabBarEx_PInvoke(tab_bar, __bbP, flags, dock_node); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TabBarFindTabByID@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@I@Z", ExactSpelling = true)]
        public static extern ImGuiTabItem* TabBarFindTabByID(ImGuiTabBar* tab_bar, uint tab_id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TabBarFindMostRecentlySelectedTabForActiveWindow@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z", ExactSpelling = true)]
        public static extern ImGuiTabItem* TabBarFindMostRecentlySelectedTabForActiveWindow(ImGuiTabBar* tab_bar);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TabBarAddTab@ImGui@@YAXPEAUImGuiTabBar@@HPEAUImGuiWindow@@@Z", ExactSpelling = true)]
        public static extern void TabBarAddTab(ImGuiTabBar* tab_bar, ImGuiTabItemFlags tab_flags, ImGuiWindow* window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TabBarRemoveTab@ImGui@@YAXPEAUImGuiTabBar@@I@Z", ExactSpelling = true)]
        public static extern void TabBarRemoveTab(ImGuiTabBar* tab_bar, uint tab_id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TabBarCloseTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z", ExactSpelling = true)]
        public static extern void TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TabBarQueueReorder@ImGui@@YAXPEAUImGuiTabBar@@PEBUImGuiTabItem@@H@Z", ExactSpelling = true)]
        public static extern void TabBarQueueReorder(ImGuiTabBar* tab_bar, ImGuiTabItem* tab, int offset);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TabBarQueueReorderFromMousePos@ImGui@@YAXPEAUImGuiTabBar@@PEBUImGuiTabItem@@UImVec2@@@Z", ExactSpelling = true)]
        public static extern void TabBarQueueReorderFromMousePos(ImGuiTabBar* tab_bar, ImGuiTabItem* tab, Vector2 mouse_pos);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TabBarProcessReorder@ImGui@@YA_NPEAUImGuiTabBar@@@Z", ExactSpelling = true)]
        private static extern byte TabBarProcessReorder_PInvoke(ImGuiTabBar* tab_bar);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TabBarProcessReorder(ImGuiTabBar* tab_bar)
        {
            byte __result;

            __result = TabBarProcessReorder_PInvoke(tab_bar);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z", ExactSpelling = true)]
        private static extern byte TabItemEx_PInvoke(ImGuiTabBar* tab_bar, byte* label, bool* p_open, ImGuiTabItemFlags flags, ImGuiWindow* docked_window);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TabItemEx(ImGuiTabBar* tab_bar, byte* label, bool* p_open, ImGuiTabItemFlags flags, ImGuiWindow* docked_window)
        {
            byte __result;

            __result = TabItemEx_PInvoke(tab_bar, label, p_open, flags, docked_window);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TabItemEx(ImGuiTabBar* tab_bar, DearImGuiInterpolatedStringHandler label, bool* p_open, ImGuiTabItemFlags flags, ImGuiWindow* docked_window)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = TabItemEx_PInvoke(tab_bar, __labelP, p_open, flags, docked_window); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TabItemCalcSize@ImGui@@YA?AUImVec2@@PEBD_N@Z", ExactSpelling = true)]
        private static extern Vector2* TabItemCalcSize_PInvoke(Vector2* __returnBuffer, byte* label, byte has_close_button);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 TabItemCalcSize(byte* label, bool has_close_button)
        {
            Vector2 __returnBuffer;

            TabItemCalcSize_PInvoke(&__returnBuffer, label, Unsafe.As<bool, byte>(ref has_close_button));

            return __returnBuffer;
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector2 TabItemCalcSize(DearImGuiInterpolatedStringHandler label, bool has_close_button)
        {
            Vector2 __returnBuffer;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { TabItemCalcSize_PInvoke(&__returnBuffer, __labelP, Unsafe.As<bool, byte>(ref has_close_button)); }

            label.Dispose();
            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TabItemBackground@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HI@Z", ExactSpelling = true)]
        private static extern void TabItemBackground_PInvoke(ImDrawList* draw_list, ImRect* bb, ImGuiTabItemFlags flags, uint col);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TabItemBackground(ImDrawList* draw_list, in ImRect bb, ImGuiTabItemFlags flags, uint col)
        {
            fixed (ImRect* __bbP = &bb)
            { TabItemBackground_PInvoke(draw_list, __bbP, flags, col); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z", ExactSpelling = true)]
        private static extern void TabItemLabelAndCloseButton_PInvoke(ImDrawList* draw_list, ImRect* bb, ImGuiTabItemFlags flags, Vector2 frame_padding, byte* label, uint tab_id, uint close_button_id, byte is_contents_visible, bool* out_just_closed, bool* out_text_clipped);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TabItemLabelAndCloseButton(ImDrawList* draw_list, in ImRect bb, ImGuiTabItemFlags flags, Vector2 frame_padding, byte* label, uint tab_id, uint close_button_id, bool is_contents_visible, bool* out_just_closed, bool* out_text_clipped)
        {
            fixed (ImRect* __bbP = &bb)
            { TabItemLabelAndCloseButton_PInvoke(draw_list, __bbP, flags, frame_padding, label, tab_id, close_button_id, Unsafe.As<bool, byte>(ref is_contents_visible), out_just_closed, out_text_clipped); }
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TabItemLabelAndCloseButton(ImDrawList* draw_list, in ImRect bb, ImGuiTabItemFlags flags, Vector2 frame_padding, DearImGuiInterpolatedStringHandler label, uint tab_id, uint close_button_id, bool is_contents_visible, bool* out_just_closed, bool* out_text_clipped)
        {
            fixed (ImRect* __bbP = &bb)
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { TabItemLabelAndCloseButton_PInvoke(draw_list, __bbP, flags, frame_padding, __labelP, tab_id, close_button_id, Unsafe.As<bool, byte>(ref is_contents_visible), out_just_closed, out_text_clipped); }

            label.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z", ExactSpelling = true)]
        private static extern void RenderText_PInvoke(Vector2 pos, byte* text, byte* text_end, byte hide_text_after_hash);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RenderText(Vector2 pos, byte* text, byte* text_end = null, bool hide_text_after_hash = true)
        {
            RenderText_PInvoke(pos, text, text_end, Unsafe.As<bool, byte>(ref hide_text_after_hash));
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RenderText(Vector2 pos, DearImGuiInterpolatedStringHandler text, bool hide_text_after_hash = true)
        {
            ReadOnlySpan<byte> __text = text.NullTerminateAndGetString();

            fixed (byte* __textP = __text)
            { RenderText_PInvoke(pos, __textP, __textP + __text.Length, Unsafe.As<bool, byte>(ref hide_text_after_hash)); }

            text.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderTextWrapped@ImGui@@YAXUImVec2@@PEBD1M@Z", ExactSpelling = true)]
        public static extern void RenderTextWrapped(Vector2 pos, byte* text, byte* text_end, float wrap_width);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RenderTextWrapped(Vector2 pos, DearImGuiInterpolatedStringHandler text, float wrap_width)
        {
            ReadOnlySpan<byte> __text = text.NullTerminateAndGetString();

            fixed (byte* __textP = __text)
            { RenderTextWrapped(pos, __textP, __textP + __text.Length, wrap_width); }

            text.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z", ExactSpelling = true)]
        private static extern void RenderTextClipped_PInvoke(Vector2* pos_min, Vector2* pos_max, byte* text, byte* text_end, Vector2* text_size_if_known, Vector2* align, ImRect* clip_rect);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RenderTextClipped(in Vector2 pos_min, in Vector2 pos_max, byte* text, byte* text_end, Vector2* text_size_if_known, in Vector2 align, ImRect* clip_rect = null)
        {
            fixed (Vector2* __pos_minP = &pos_min)
            fixed (Vector2* __pos_maxP = &pos_max)
            fixed (Vector2* __alignP = &align)
            { RenderTextClipped_PInvoke(__pos_minP, __pos_maxP, text, text_end, text_size_if_known, __alignP, clip_rect); }
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RenderTextClipped(in Vector2 pos_min, in Vector2 pos_max, DearImGuiInterpolatedStringHandler text, Vector2* text_size_if_known, in Vector2 align, ImRect* clip_rect = null)
        {
            ReadOnlySpan<byte> __text = text.NullTerminateAndGetString();

            fixed (Vector2* __pos_minP = &pos_min)
            fixed (Vector2* __pos_maxP = &pos_max)
            fixed (byte* __textP = __text)
            fixed (Vector2* __alignP = &align)
            { RenderTextClipped_PInvoke(__pos_minP, __pos_maxP, __textP, __textP + __text.Length, text_size_if_known, __alignP, clip_rect); }

            text.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderTextClippedEx@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1PEBD2PEBU3@1PEBUImRect@@@Z", ExactSpelling = true)]
        private static extern void RenderTextClippedEx_PInvoke(ImDrawList* draw_list, Vector2* pos_min, Vector2* pos_max, byte* text, byte* text_end, Vector2* text_size_if_known, Vector2* align, ImRect* clip_rect);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RenderTextClippedEx(ImDrawList* draw_list, in Vector2 pos_min, in Vector2 pos_max, byte* text, byte* text_end, Vector2* text_size_if_known, in Vector2 align, ImRect* clip_rect = null)
        {
            fixed (Vector2* __pos_minP = &pos_min)
            fixed (Vector2* __pos_maxP = &pos_max)
            fixed (Vector2* __alignP = &align)
            { RenderTextClippedEx_PInvoke(draw_list, __pos_minP, __pos_maxP, text, text_end, text_size_if_known, __alignP, clip_rect); }
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RenderTextClippedEx(ImDrawList* draw_list, in Vector2 pos_min, in Vector2 pos_max, DearImGuiInterpolatedStringHandler text, Vector2* text_size_if_known, in Vector2 align, ImRect* clip_rect = null)
        {
            ReadOnlySpan<byte> __text = text.NullTerminateAndGetString();

            fixed (Vector2* __pos_minP = &pos_min)
            fixed (Vector2* __pos_maxP = &pos_max)
            fixed (byte* __textP = __text)
            fixed (Vector2* __alignP = &align)
            { RenderTextClippedEx_PInvoke(draw_list, __pos_minP, __pos_maxP, __textP, __textP + __text.Length, text_size_if_known, __alignP, clip_rect); }

            text.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderTextEllipsis@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1MMPEBD2PEBU3@@Z", ExactSpelling = true)]
        private static extern void RenderTextEllipsis_PInvoke(ImDrawList* draw_list, Vector2* pos_min, Vector2* pos_max, float clip_max_x, float ellipsis_max_x, byte* text, byte* text_end, Vector2* text_size_if_known);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RenderTextEllipsis(ImDrawList* draw_list, in Vector2 pos_min, in Vector2 pos_max, float clip_max_x, float ellipsis_max_x, byte* text, byte* text_end, Vector2* text_size_if_known)
        {
            fixed (Vector2* __pos_minP = &pos_min)
            fixed (Vector2* __pos_maxP = &pos_max)
            { RenderTextEllipsis_PInvoke(draw_list, __pos_minP, __pos_maxP, clip_max_x, ellipsis_max_x, text, text_end, text_size_if_known); }
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RenderTextEllipsis(ImDrawList* draw_list, in Vector2 pos_min, in Vector2 pos_max, float clip_max_x, float ellipsis_max_x, DearImGuiInterpolatedStringHandler text, Vector2* text_size_if_known)
        {
            ReadOnlySpan<byte> __text = text.NullTerminateAndGetString();

            fixed (Vector2* __pos_minP = &pos_min)
            fixed (Vector2* __pos_maxP = &pos_max)
            fixed (byte* __textP = __text)
            { RenderTextEllipsis_PInvoke(draw_list, __pos_minP, __pos_maxP, clip_max_x, ellipsis_max_x, __textP, __textP + __text.Length, text_size_if_known); }

            text.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z", ExactSpelling = true)]
        private static extern void RenderFrame_PInvoke(Vector2 p_min, Vector2 p_max, uint fill_col, byte border, float rounding);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RenderFrame(Vector2 p_min, Vector2 p_max, uint fill_col, bool border = true, float rounding = 0f)
        {
            RenderFrame_PInvoke(p_min, p_max, fill_col, Unsafe.As<bool, byte>(ref border), rounding);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z", ExactSpelling = true)]
        public static extern void RenderFrameBorder(Vector2 p_min, Vector2 p_max, float rounding = 0f);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z", ExactSpelling = true)]
        public static extern void RenderColorRectWithAlphaCheckerboard(ImDrawList* draw_list, Vector2 p_min, Vector2 p_max, uint fill_col, float grid_step, Vector2 grid_off, float rounding = 0f, ImDrawFlags flags = ImDrawFlags.None);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z", ExactSpelling = true)]
        private static extern void RenderNavHighlight_PInvoke(ImRect* bb, uint id, ImGuiNavHighlightFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RenderNavHighlight(in ImRect bb, uint id, ImGuiNavHighlightFlags flags = ImGuiNavHighlightFlags.TypeDefault)
        {
            fixed (ImRect* __bbP = &bb)
            { RenderNavHighlight_PInvoke(__bbP, id, flags); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z", ExactSpelling = true)]
        public static extern byte* FindRenderedTextEnd(byte* text, byte* text_end = null);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte* FindRenderedTextEnd(DearImGuiInterpolatedStringHandler text)
        {
            byte* __result;
            ReadOnlySpan<byte> __text = text.NullTerminateAndGetString();

            fixed (byte* __textP = __text)
            { __result = FindRenderedTextEnd(__textP, __textP + __text.Length); }

            text.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z", ExactSpelling = true)]
        public static extern void RenderArrow(ImDrawList* draw_list, Vector2 pos, uint col, ImGuiDir dir, float scale = 1f);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z", ExactSpelling = true)]
        public static extern void RenderBullet(ImDrawList* draw_list, Vector2 pos, uint col);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderCheckMark@ImGui@@YAXPEAUImDrawList@@UImVec2@@IM@Z", ExactSpelling = true)]
        public static extern void RenderCheckMark(ImDrawList* draw_list, Vector2 pos, uint col, float sz);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z", ExactSpelling = true)]
        public static extern void RenderMouseCursor(ImDrawList* draw_list, Vector2 pos, float scale, ImGuiMouseCursor mouse_cursor, uint col_fill, uint col_border, uint col_shadow);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z", ExactSpelling = true)]
        public static extern void RenderArrowPointingAt(ImDrawList* draw_list, Vector2 pos, Vector2 half_sz, ImGuiDir direction, uint col);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z", ExactSpelling = true)]
        public static extern void RenderArrowDockMenu(ImDrawList* draw_list, Vector2 p_min, float sz, uint col);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderRectFilledRangeH@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@IMMM@Z", ExactSpelling = true)]
        private static extern void RenderRectFilledRangeH_PInvoke(ImDrawList* draw_list, ImRect* rect, uint col, float x_start_norm, float x_end_norm, float rounding);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RenderRectFilledRangeH(ImDrawList* draw_list, in ImRect rect, uint col, float x_start_norm, float x_end_norm, float rounding)
        {
            fixed (ImRect* __rectP = &rect)
            { RenderRectFilledRangeH_PInvoke(draw_list, __rectP, col, x_start_norm, x_end_norm, rounding); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderRectFilledWithHole@ImGui@@YAXPEAUImDrawList@@UImRect@@1IM@Z", ExactSpelling = true)]
        private static extern void RenderRectFilledWithHole_PInvoke(ImDrawList* draw_list, ImRect* outer, ImRect* inner, uint col, float rounding);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RenderRectFilledWithHole(ImDrawList* draw_list, ImRect outer, ImRect inner, uint col, float rounding)
        {
            RenderRectFilledWithHole_PInvoke(draw_list, &outer, &inner, col, rounding);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CalcRoundingFlagsForRectInRect@ImGui@@YAHAEBUImRect@@0M@Z", ExactSpelling = true)]
        private static extern ImDrawFlags CalcRoundingFlagsForRectInRect_PInvoke(ImRect* r_in, ImRect* r_outer, float threshold);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ImDrawFlags CalcRoundingFlagsForRectInRect(in ImRect r_in, in ImRect r_outer, float threshold)
        {
            fixed (ImRect* __r_inP = &r_in)
            fixed (ImRect* __r_outerP = &r_outer)
            { return CalcRoundingFlagsForRectInRect_PInvoke(__r_inP, __r_outerP, threshold); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TextEx@ImGui@@YAXPEBD0H@Z", ExactSpelling = true)]
        public static extern void TextEx(byte* text, byte* text_end = null, ImGuiTextFlags flags = ImGuiTextFlags.None);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void TextEx(DearImGuiInterpolatedStringHandler text, ImGuiTextFlags flags = ImGuiTextFlags.None)
        {
            ReadOnlySpan<byte> __text = text.NullTerminateAndGetString();

            fixed (byte* __textP = __text)
            { TextEx(__textP, __textP + __text.Length, flags); }

            text.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z", ExactSpelling = true)]
        private static extern byte ButtonEx_PInvoke(byte* label, Vector2* size_arg, ImGuiButtonFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ButtonEx(byte* label, in Vector2 size_arg, ImGuiButtonFlags flags = ImGuiButtonFlags.None)
        {
            byte __result;

            fixed (Vector2* __size_argP = &size_arg)
            { __result = ButtonEx_PInvoke(label, __size_argP, flags); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ButtonEx(DearImGuiInterpolatedStringHandler label, in Vector2 size_arg, ImGuiButtonFlags flags = ImGuiButtonFlags.None)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (Vector2* __size_argP = &size_arg)
            { __result = ButtonEx_PInvoke(__labelP, __size_argP, flags); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z", ExactSpelling = true)]
        private static extern byte CloseButton_PInvoke(uint id, Vector2* pos);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool CloseButton(uint id, in Vector2 pos)
        {
            byte __result;

            fixed (Vector2* __posP = &pos)
            { __result = CloseButton_PInvoke(id, __posP); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z", ExactSpelling = true)]
        private static extern byte CollapseButton_PInvoke(uint id, Vector2* pos, ImGuiDockNode* dock_node);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool CollapseButton(uint id, in Vector2 pos, ImGuiDockNode* dock_node)
        {
            byte __result;

            fixed (Vector2* __posP = &pos)
            { __result = CollapseButton_PInvoke(id, __posP, dock_node); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z", ExactSpelling = true)]
        private static extern byte ArrowButtonEx_PInvoke(byte* str_id, ImGuiDir dir, Vector2 size_arg, ImGuiButtonFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ArrowButtonEx(byte* str_id, ImGuiDir dir, Vector2 size_arg, ImGuiButtonFlags flags = ImGuiButtonFlags.None)
        {
            byte __result;

            __result = ArrowButtonEx_PInvoke(str_id, dir, size_arg, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ArrowButtonEx(DearImGuiInterpolatedStringHandler str_id, ImGuiDir dir, Vector2 size_arg, ImGuiButtonFlags flags = ImGuiButtonFlags.None)
        {
            byte __result;

            fixed (byte* __str_idP = str_id.NullTerminateAndGetString())
            { __result = ArrowButtonEx_PInvoke(__str_idP, dir, size_arg, flags); }

            str_id.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?Scrollbar@ImGui@@YAXW4ImGuiAxis@@@Z", ExactSpelling = true)]
        public static extern void Scrollbar(ImGuiAxis axis);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ScrollbarEx@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEA_J_J3H@Z", ExactSpelling = true)]
        private static extern byte ScrollbarEx_PInvoke(ImRect* bb, uint id, ImGuiAxis axis, long* p_scroll_v, long avail_v, long contents_v, ImDrawFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ScrollbarEx(in ImRect bb, uint id, ImGuiAxis axis, long* p_scroll_v, long avail_v, long contents_v, ImDrawFlags flags)
        {
            byte __result;

            fixed (ImRect* __bbP = &bb)
            { __result = ScrollbarEx_PInvoke(__bbP, id, axis, p_scroll_v, avail_v, contents_v, flags); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@111AEBUImVec4@@2@Z", ExactSpelling = true)]
        private static extern byte ImageButtonEx_PInvoke(uint id, void* texture_id, Vector2* size, Vector2* uv0, Vector2* uv1, Vector2* padding, Vector4* bg_col, Vector4* tint_col);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ImageButtonEx(uint id, void* texture_id, in Vector2 size, in Vector2 uv0, in Vector2 uv1, in Vector2 padding, in Vector4 bg_col, in Vector4 tint_col)
        {
            byte __result;

            fixed (Vector2* __sizeP = &size)
            fixed (Vector2* __uv0P = &uv0)
            fixed (Vector2* __uv1P = &uv1)
            fixed (Vector2* __paddingP = &padding)
            fixed (Vector4* __bg_colP = &bg_col)
            fixed (Vector4* __tint_colP = &tint_col)
            { __result = ImageButtonEx_PInvoke(id, texture_id, __sizeP, __uv0P, __uv1P, __paddingP, __bg_colP, __tint_colP); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetWindowScrollbarRect@ImGui@@YA?AUImRect@@PEAUImGuiWindow@@W4ImGuiAxis@@@Z", ExactSpelling = true)]
        private static extern ImRect* GetWindowScrollbarRect_PInvoke(ImRect* __returnBuffer, ImGuiWindow* window, ImGuiAxis axis);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ImRect GetWindowScrollbarRect(ImGuiWindow* window, ImGuiAxis axis)
        {
            ImRect __returnBuffer;

            GetWindowScrollbarRect_PInvoke(&__returnBuffer, window, axis);

            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetWindowScrollbarID@ImGui@@YAIPEAUImGuiWindow@@W4ImGuiAxis@@@Z", ExactSpelling = true)]
        public static extern uint GetWindowScrollbarID(ImGuiWindow* window, ImGuiAxis axis);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetWindowResizeCornerID@ImGui@@YAIPEAUImGuiWindow@@H@Z", ExactSpelling = true)]
        public static extern uint GetWindowResizeCornerID(ImGuiWindow* window, int n);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetWindowResizeBorderID@ImGui@@YAIPEAUImGuiWindow@@H@Z", ExactSpelling = true)]
        public static extern uint GetWindowResizeBorderID(ImGuiWindow* window, ImGuiDir dir);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SeparatorEx@ImGui@@YAXH@Z", ExactSpelling = true)]
        public static extern void SeparatorEx(ImGuiSeparatorFlags flags);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CheckboxFlags@ImGui@@YA_NPEBDPEA_J_J@Z", ExactSpelling = true)]
        private static extern byte CheckboxFlags_PInvoke(byte* label, long* flags, long flags_value);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool CheckboxFlags(byte* label, long* flags, long flags_value)
        {
            byte __result;

            __result = CheckboxFlags_PInvoke(label, flags, flags_value);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool CheckboxFlags(DearImGuiInterpolatedStringHandler label, long* flags, long flags_value)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = CheckboxFlags_PInvoke(__labelP, flags, flags_value); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CheckboxFlags@ImGui@@YA_NPEBDPEA_K_K@Z", ExactSpelling = true)]
        private static extern byte CheckboxFlags_PInvoke(byte* label, ulong* flags, ulong flags_value);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool CheckboxFlags(byte* label, ulong* flags, ulong flags_value)
        {
            byte __result;

            __result = CheckboxFlags_PInvoke(label, flags, flags_value);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool CheckboxFlags(DearImGuiInterpolatedStringHandler label, ulong* flags, ulong flags_value)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = CheckboxFlags_PInvoke(__labelP, flags, flags_value); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z", ExactSpelling = true)]
        private static extern byte ButtonBehavior_PInvoke(ImRect* bb, uint id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ButtonBehavior(in ImRect bb, uint id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags = ImGuiButtonFlags.None)
        {
            byte __result;

            fixed (ImRect* __bbP = &bb)
            { __result = ButtonBehavior_PInvoke(__bbP, id, out_hovered, out_held, flags); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DragBehavior@ImGui@@YA_NIHPEAXMPEBX1PEBDH@Z", ExactSpelling = true)]
        private static extern byte DragBehavior_PInvoke(uint id, ImGuiDataType data_type, void* p_v, float v_speed, void* p_min, void* p_max, byte* format, ImGuiSliderFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragBehavior(uint id, ImGuiDataType data_type, void* p_v, float v_speed, void* p_min, void* p_max, byte* format, ImGuiSliderFlags flags)
        {
            byte __result;

            __result = DragBehavior_PInvoke(id, data_type, p_v, v_speed, p_min, p_max, format, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DragBehavior(uint id, ImGuiDataType data_type, void* p_v, float v_speed, void* p_min, void* p_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags)
        {
            byte __result;

            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = DragBehavior_PInvoke(id, data_type, p_v, v_speed, p_min, p_max, __formatP, flags); }

            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SliderBehavior@ImGui@@YA_NAEBUImRect@@IHPEAXPEBX2PEBDHPEAU2@@Z", ExactSpelling = true)]
        private static extern byte SliderBehavior_PInvoke(ImRect* bb, uint id, ImGuiDataType data_type, void* p_v, void* p_min, void* p_max, byte* format, ImGuiSliderFlags flags, ImRect* out_grab_bb);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderBehavior(in ImRect bb, uint id, ImGuiDataType data_type, void* p_v, void* p_min, void* p_max, byte* format, ImGuiSliderFlags flags, ImRect* out_grab_bb)
        {
            byte __result;

            fixed (ImRect* __bbP = &bb)
            { __result = SliderBehavior_PInvoke(__bbP, id, data_type, p_v, p_min, p_max, format, flags, out_grab_bb); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SliderBehavior(in ImRect bb, uint id, ImGuiDataType data_type, void* p_v, void* p_min, void* p_max, DearImGuiInterpolatedStringHandler format, ImGuiSliderFlags flags, ImRect* out_grab_bb)
        {
            byte __result;

            fixed (ImRect* __bbP = &bb)
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = SliderBehavior_PInvoke(__bbP, id, data_type, p_v, p_min, p_max, __formatP, flags, out_grab_bb); }

            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SplitterBehavior@ImGui@@YA_NAEBUImRect@@IW4ImGuiAxis@@PEAM2MMMMI@Z", ExactSpelling = true)]
        private static extern byte SplitterBehavior_PInvoke(ImRect* bb, uint id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay, uint bg_col);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool SplitterBehavior(in ImRect bb, uint id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend = 0f, float hover_visibility_delay = 0f, uint bg_col = 0)
        {
            byte __result;

            fixed (ImRect* __bbP = &bb)
            { __result = SplitterBehavior_PInvoke(__bbP, id, axis, size1, size2, min_size1, min_size2, hover_extend, hover_visibility_delay, bg_col); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z", ExactSpelling = true)]
        private static extern byte TreeNodeBehavior_PInvoke(uint id, ImGuiTreeNodeFlags flags, byte* label, byte* label_end);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, byte* label, byte* label_end = null)
        {
            byte __result;

            __result = TreeNodeBehavior_PInvoke(id, flags, label, label_end);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNodeBehavior(uint id, ImGuiTreeNodeFlags flags, DearImGuiInterpolatedStringHandler label)
        {
            byte __result;
            ReadOnlySpan<byte> __label = label.NullTerminateAndGetString();

            fixed (byte* __labelP = __label)
            { __result = TreeNodeBehavior_PInvoke(id, flags, __labelP, __labelP + __label.Length); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z", ExactSpelling = true)]
        private static extern byte TreeNodeBehaviorIsOpen_PInvoke(uint id, ImGuiTreeNodeFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TreeNodeBehaviorIsOpen(uint id, ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags.None)
        {
            byte __result;

            __result = TreeNodeBehaviorIsOpen_PInvoke(id, flags);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TreePushOverrideID@ImGui@@YAXI@Z", ExactSpelling = true)]
        public static extern void TreePushOverrideID(uint id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DataTypeGetInfo@ImGui@@YAPEBUImGuiDataTypeInfo@@H@Z", ExactSpelling = true)]
        public static extern ImGuiDataTypeInfo* DataTypeGetInfo(ImGuiDataType data_type);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DataTypeFormatString@ImGui@@YAHPEADHHPEBXPEBD@Z", ExactSpelling = true)]
        public static extern int DataTypeFormatString(byte* buf, int buf_size, ImGuiDataType data_type, void* p_data, byte* format);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int DataTypeFormatString(byte* buf, int buf_size, ImGuiDataType data_type, void* p_data, DearImGuiInterpolatedStringHandler format)
        {
            int __result;

            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = DataTypeFormatString(buf, buf_size, data_type, p_data, __formatP); }

            format.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DataTypeApplyOp@ImGui@@YAXHHPEAXPEBX1@Z", ExactSpelling = true)]
        public static extern void DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, void* arg_1, void* arg_2);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DataTypeApplyFromText@ImGui@@YA_NPEBDHPEAX0@Z", ExactSpelling = true)]
        private static extern byte DataTypeApplyFromText_PInvoke(byte* buf, ImGuiDataType data_type, void* p_data, byte* format);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DataTypeApplyFromText(byte* buf, ImGuiDataType data_type, void* p_data, byte* format)
        {
            byte __result;

            __result = DataTypeApplyFromText_PInvoke(buf, data_type, p_data, format);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DataTypeApplyFromText(DearImGuiInterpolatedStringHandler buf, ImGuiDataType data_type, void* p_data, DearImGuiInterpolatedStringHandler format)
        {
            byte __result;

            fixed (byte* __bufP = buf.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = DataTypeApplyFromText_PInvoke(__bufP, data_type, p_data, __formatP); }

            buf.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DataTypeCompare@ImGui@@YAHHPEBX0@Z", ExactSpelling = true)]
        public static extern int DataTypeCompare(ImGuiDataType data_type, void* arg_1, void* arg_2);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DataTypeClamp@ImGui@@YA_NHPEAXPEBX1@Z", ExactSpelling = true)]
        private static extern byte DataTypeClamp_PInvoke(ImGuiDataType data_type, void* p_data, void* p_min, void* p_max);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool DataTypeClamp(ImGuiDataType data_type, void* p_data, void* p_min, void* p_max)
        {
            byte __result;

            __result = DataTypeClamp_PInvoke(data_type, p_data, p_min, p_max);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z", ExactSpelling = true)]
        private static extern byte InputTextEx_PInvoke(byte* label, byte* hint, byte* buf, int buf_size, Vector2* size_arg, ImGuiInputTextFlags flags, delegate* unmanaged[Cdecl]<ImGuiInputTextCallbackData*, int> callback, void* user_data);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputTextEx(byte* label, byte* hint, byte* buf, int buf_size, in Vector2 size_arg, ImGuiInputTextFlags flags, delegate* unmanaged[Cdecl]<ImGuiInputTextCallbackData*, int> callback = null, void* user_data = null)
        {
            byte __result;

            fixed (Vector2* __size_argP = &size_arg)
            { __result = InputTextEx_PInvoke(label, hint, buf, buf_size, __size_argP, flags, callback, user_data); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool InputTextEx(DearImGuiInterpolatedStringHandler label, DearImGuiInterpolatedStringHandler hint, byte* buf, int buf_size, in Vector2 size_arg, ImGuiInputTextFlags flags, delegate* unmanaged[Cdecl]<ImGuiInputTextCallbackData*, int> callback = null, void* user_data = null)
        {
            byte __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __hintP = hint.NullTerminateAndGetString())
            fixed (Vector2* __size_argP = &size_arg)
            { __result = InputTextEx_PInvoke(__labelP, __hintP, buf, buf_size, __size_argP, flags, callback, user_data); }

            label.Dispose();
            hint.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TempInputText@ImGui@@YA_NAEBUImRect@@IPEBDPEADHH@Z", ExactSpelling = true)]
        private static extern byte TempInputText_PInvoke(ImRect* bb, uint id, byte* label, byte* buf, int buf_size, ImGuiInputTextFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TempInputText(in ImRect bb, uint id, byte* label, byte* buf, int buf_size, ImGuiInputTextFlags flags)
        {
            byte __result;

            fixed (ImRect* __bbP = &bb)
            { __result = TempInputText_PInvoke(__bbP, id, label, buf, buf_size, flags); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TempInputText(in ImRect bb, uint id, DearImGuiInterpolatedStringHandler label, byte* buf, int buf_size, ImGuiInputTextFlags flags)
        {
            byte __result;

            fixed (ImRect* __bbP = &bb)
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { __result = TempInputText_PInvoke(__bbP, id, __labelP, buf, buf_size, flags); }

            label.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TempInputScalar@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1PEBX3@Z", ExactSpelling = true)]
        private static extern byte TempInputScalar_PInvoke(ImRect* bb, uint id, byte* label, ImGuiDataType data_type, void* p_data, byte* format, void* p_clamp_min, void* p_clamp_max);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TempInputScalar(in ImRect bb, uint id, byte* label, ImGuiDataType data_type, void* p_data, byte* format, void* p_clamp_min = null, void* p_clamp_max = null)
        {
            byte __result;

            fixed (ImRect* __bbP = &bb)
            { __result = TempInputScalar_PInvoke(__bbP, id, label, data_type, p_data, format, p_clamp_min, p_clamp_max); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TempInputScalar(in ImRect bb, uint id, DearImGuiInterpolatedStringHandler label, ImGuiDataType data_type, void* p_data, DearImGuiInterpolatedStringHandler format, void* p_clamp_min = null, void* p_clamp_max = null)
        {
            byte __result;

            fixed (ImRect* __bbP = &bb)
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __formatP = format.NullTerminateAndGetString())
            { __result = TempInputScalar_PInvoke(__bbP, id, __labelP, data_type, p_data, __formatP, p_clamp_min, p_clamp_max); }

            label.Dispose();
            format.Dispose();
            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?TempInputIsActive@ImGui@@YA_NI@Z", ExactSpelling = true)]
        private static extern byte TempInputIsActive_PInvoke(uint id);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TempInputIsActive(uint id)
        {
            byte __result;

            __result = TempInputIsActive_PInvoke(id);

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetInputTextState@ImGui@@YAPEAUImGuiInputTextState@@I@Z", ExactSpelling = true)]
        public static extern ImGuiInputTextState* GetInputTextState(uint id);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z", ExactSpelling = true)]
        public static extern void ColorTooltip(byte* text, float* col, ImGuiColorEditFlags flags);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ColorTooltip(DearImGuiInterpolatedStringHandler text, float* col, ImGuiColorEditFlags flags)
        {
            fixed (byte* __textP = text.NullTerminateAndGetString())
            { ColorTooltip(__textP, col, flags); }

            text.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z", ExactSpelling = true)]
        public static extern void ColorEditOptionsPopup(float* col, ImGuiColorEditFlags flags);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z", ExactSpelling = true)]
        public static extern void ColorPickerOptionsPopup(float* ref_col, ImGuiColorEditFlags flags);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?PlotEx@ImGui@@YAHW4ImGuiPlotType@@PEBDP6AMPEAXH@Z2HH1MMUImVec2@@@Z", ExactSpelling = true)]
        public static extern int PlotEx(ImGuiPlotType plot_type, byte* label, delegate* unmanaged[Cdecl]<void*, int, float> values_getter, void* data, int values_count, int values_offset, byte* overlay_text, float scale_min, float scale_max, Vector2 frame_size);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int PlotEx(ImGuiPlotType plot_type, DearImGuiInterpolatedStringHandler label, delegate* unmanaged[Cdecl]<void*, int, float> values_getter, void* data, int values_count, int values_offset, DearImGuiInterpolatedStringHandler overlay_text, float scale_min, float scale_max, Vector2 frame_size)
        {
            int __result;

            fixed (byte* __labelP = label.NullTerminateAndGetString())
            fixed (byte* __overlay_textP = overlay_text.NullTerminateAndGetString())
            { __result = PlotEx(plot_type, __labelP, values_getter, data, values_count, values_offset, __overlay_textP, scale_min, scale_max, frame_size); }

            label.Dispose();
            overlay_text.Dispose();
            return __result;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z", ExactSpelling = true)]
        public static extern void ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, Vector2 gradient_p0, Vector2 gradient_p1, uint col0, uint col1);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ShadeVertsLinearUV@ImGui@@YAXPEAUImDrawList@@HHAEBUImVec2@@111_N@Z", ExactSpelling = true)]
        private static extern void ShadeVertsLinearUV_PInvoke(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, Vector2* a, Vector2* b, Vector2* uv_a, Vector2* uv_b, byte clamp);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, in Vector2 a, in Vector2 b, in Vector2 uv_a, in Vector2 uv_b, bool clamp)
        {
            fixed (Vector2* __aP = &a)
            fixed (Vector2* __bP = &b)
            fixed (Vector2* __uv_aP = &uv_a)
            fixed (Vector2* __uv_bP = &uv_b)
            { ShadeVertsLinearUV_PInvoke(draw_list, vert_start_idx, vert_end_idx, __aP, __bP, __uv_aP, __uv_bP, Unsafe.As<bool, byte>(ref clamp)); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GcCompactTransientMiscBuffers@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void GcCompactTransientMiscBuffers();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GcCompactTransientWindowBuffers@ImGui@@YAXPEAUImGuiWindow@@@Z", ExactSpelling = true)]
        public static extern void GcCompactTransientWindowBuffers(ImGuiWindow* window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GcAwakeTransientWindowBuffers@ImGui@@YAXPEAUImGuiWindow@@@Z", ExactSpelling = true)]
        public static extern void GcAwakeTransientWindowBuffers(ImGuiWindow* window);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ErrorCheckEndFrameRecover@ImGui@@YAXP6AXPEAXPEBDZZ0@Z", ExactSpelling = true)]
        public static extern void ErrorCheckEndFrameRecover(delegate* unmanaged[Cdecl]<void*, byte*, void> log_callback, void* user_data = null);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ErrorCheckEndWindowRecover@ImGui@@YAXP6AXPEAXPEBDZZ0@Z", ExactSpelling = true)]
        public static extern void ErrorCheckEndWindowRecover(delegate* unmanaged[Cdecl]<void*, byte*, void> log_callback, void* user_data = null);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugDrawItemRect@ImGui@@YAXI@Z", ExactSpelling = true)]
        public static extern void DebugDrawItemRect(uint col = 4278190335);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugStartItemPicker@ImGui@@YAXXZ", ExactSpelling = true)]
        public static extern void DebugStartItemPicker();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ShowFontAtlas@ImGui@@YAXPEAUImFontAtlas@@@Z", ExactSpelling = true)]
        public static extern void ShowFontAtlas(ImFontAtlas* atlas);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugHookIdInfo@ImGui@@YAXIHPEBX0@Z", ExactSpelling = true)]
        public static extern void DebugHookIdInfo(uint id, ImGuiDataType data_type, void* data_id, void* data_id_end);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugNodeColumns@ImGui@@YAXPEAUImGuiOldColumns@@@Z", ExactSpelling = true)]
        public static extern void DebugNodeColumns(ImGuiOldColumns* columns);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugNodeDockNode@ImGui@@YAXPEAUImGuiDockNode@@PEBD@Z", ExactSpelling = true)]
        public static extern void DebugNodeDockNode(ImGuiDockNode* node, byte* label);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DebugNodeDockNode(ImGuiDockNode* node, DearImGuiInterpolatedStringHandler label)
        {
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { DebugNodeDockNode(node, __labelP); }

            label.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugNodeDrawList@ImGui@@YAXPEAUImGuiWindow@@PEAUImGuiViewportP@@PEBUImDrawList@@PEBD@Z", ExactSpelling = true)]
        public static extern void DebugNodeDrawList(ImGuiWindow* window, ImGuiViewportP* viewport, ImDrawList* draw_list, byte* label);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DebugNodeDrawList(ImGuiWindow* window, ImGuiViewportP* viewport, ImDrawList* draw_list, DearImGuiInterpolatedStringHandler label)
        {
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { DebugNodeDrawList(window, viewport, draw_list, __labelP); }

            label.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugNodeDrawCmdShowMeshAndBoundingBox@ImGui@@YAXPEAUImDrawList@@PEBU2@PEBUImDrawCmd@@_N3@Z", ExactSpelling = true)]
        private static extern void DebugNodeDrawCmdShowMeshAndBoundingBox_PInvoke(ImDrawList* out_draw_list, ImDrawList* draw_list, ImDrawCmd* draw_cmd, byte show_mesh, byte show_aabb);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList* out_draw_list, ImDrawList* draw_list, ImDrawCmd* draw_cmd, bool show_mesh, bool show_aabb)
        {
            DebugNodeDrawCmdShowMeshAndBoundingBox_PInvoke(out_draw_list, draw_list, draw_cmd, Unsafe.As<bool, byte>(ref show_mesh), Unsafe.As<bool, byte>(ref show_aabb));
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugNodeFont@ImGui@@YAXPEAUImFont@@@Z", ExactSpelling = true)]
        public static extern void DebugNodeFont(ImFont* font);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugNodeStorage@ImGui@@YAXPEAUImGuiStorage@@PEBD@Z", ExactSpelling = true)]
        public static extern void DebugNodeStorage(ImGuiStorage* storage, byte* label);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DebugNodeStorage(ImGuiStorage* storage, DearImGuiInterpolatedStringHandler label)
        {
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { DebugNodeStorage(storage, __labelP); }

            label.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugNodeTabBar@ImGui@@YAXPEAUImGuiTabBar@@PEBD@Z", ExactSpelling = true)]
        public static extern void DebugNodeTabBar(ImGuiTabBar* tab_bar, byte* label);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DebugNodeTabBar(ImGuiTabBar* tab_bar, DearImGuiInterpolatedStringHandler label)
        {
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { DebugNodeTabBar(tab_bar, __labelP); }

            label.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugNodeTable@ImGui@@YAXPEAUImGuiTable@@@Z", ExactSpelling = true)]
        public static extern void DebugNodeTable(ImGuiTable* table);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugNodeTableSettings@ImGui@@YAXPEAUImGuiTableSettings@@@Z", ExactSpelling = true)]
        public static extern void DebugNodeTableSettings(ImGuiTableSettings* settings);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugNodeWindow@ImGui@@YAXPEAUImGuiWindow@@PEBD@Z", ExactSpelling = true)]
        public static extern void DebugNodeWindow(ImGuiWindow* window, byte* label);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DebugNodeWindow(ImGuiWindow* window, DearImGuiInterpolatedStringHandler label)
        {
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { DebugNodeWindow(window, __labelP); }

            label.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugNodeWindowSettings@ImGui@@YAXPEAUImGuiWindowSettings@@@Z", ExactSpelling = true)]
        public static extern void DebugNodeWindowSettings(ImGuiWindowSettings* settings);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugNodeWindowsList@ImGui@@YAXPEAU?$ImVector@PEAUImGuiWindow@@@@PEBD@Z", ExactSpelling = true)]
        public static extern void DebugNodeWindowsList(ImVector<Pointer<ImGuiWindow>>* windows, byte* label);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DebugNodeWindowsList(ImVector<Pointer<ImGuiWindow>>* windows, DearImGuiInterpolatedStringHandler label)
        {
            fixed (byte* __labelP = label.NullTerminateAndGetString())
            { DebugNodeWindowsList(windows, __labelP); }

            label.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugNodeWindowsListByBeginStackParent@ImGui@@YAXPEAPEAUImGuiWindow@@HPEAU2@@Z", ExactSpelling = true)]
        public static extern void DebugNodeWindowsListByBeginStackParent(ImGuiWindow** windows, int windows_size, ImGuiWindow* parent_in_begin_stack);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugNodeViewport@ImGui@@YAXPEAUImGuiViewportP@@@Z", ExactSpelling = true)]
        public static extern void DebugNodeViewport(ImGuiViewportP* viewport);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?DebugRenderViewportThumbnail@ImGui@@YAXPEAUImDrawList@@PEAUImGuiViewportP@@AEBUImRect@@@Z", ExactSpelling = true)]
        private static extern void DebugRenderViewportThumbnail_PInvoke(ImDrawList* draw_list, ImGuiViewportP* viewport, ImRect* bb);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void DebugRenderViewportThumbnail(ImDrawList* draw_list, ImGuiViewportP* viewport, in ImRect bb)
        {
            fixed (ImRect* __bbP = &bb)
            { DebugRenderViewportThumbnail_PInvoke(draw_list, viewport, __bbP); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ", ExactSpelling = true)]
        public static extern ImFontBuilderIO* ImFontAtlasGetBuilderForStbTruetype();

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImFontAtlasBuildInit@@YAXPEAUImFontAtlas@@@Z", ExactSpelling = true)]
        public static extern void ImFontAtlasBuildInit(ImFontAtlas* atlas);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z", ExactSpelling = true)]
        public static extern void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z", ExactSpelling = true)]
        public static extern void ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z", ExactSpelling = true)]
        public static extern void ImFontAtlasBuildFinish(ImFontAtlas* atlas);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z", ExactSpelling = true)]
        public static extern void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, byte* in_str, byte in_marker_char, byte in_marker_pixel_value);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, DearImGuiInterpolatedStringHandler in_str, byte in_marker_char, byte in_marker_pixel_value)
        {
            fixed (byte* __in_strP = in_str.NullTerminateAndGetString())
            { ImFontAtlasBuildRender8bppRectFromString(atlas, x, y, w, h, __in_strP, in_marker_char, in_marker_pixel_value); }

            in_str.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z", ExactSpelling = true)]
        public static extern void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, byte* in_str, byte in_marker_char, uint in_marker_pixel_value);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, DearImGuiInterpolatedStringHandler in_str, byte in_marker_char, uint in_marker_pixel_value)
        {
            fixed (byte* __in_strP = in_str.NullTerminateAndGetString())
            { ImFontAtlasBuildRender32bppRectFromString(atlas, x, y, w, h, __in_strP, in_marker_char, in_marker_pixel_value); }

            in_str.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQEAEM@Z", ExactSpelling = true)]
        public static extern void ImFontAtlasBuildMultiplyCalcLookupTable(ConstantArray_unsigned__UNICODE_0020__char_256* out_table, float in_multiply_factor);

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z", ExactSpelling = true)]
        public static extern void ImFontAtlasBuildMultiplyRectAlpha8(ConstantArray_const__UNICODE_0020__unsigned__UNICODE_0020__char_256* table, byte* pixels, int x, int y, int w, int h, int stride);
    }
}
