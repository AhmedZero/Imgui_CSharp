// <auto-generated>
// This file was automatically generated by Biohazrd and should not be modified by hand!
// </auto-generated>
#nullable enable
using Mochi.DearImGui.Internal;
using System;
using System.Numerics;
using System.Runtime.InteropServices;

namespace Mochi.DearImGui.Infrastructure
{
    public unsafe ref struct ConstantArrayEnumerator<T>
        where T : unmanaged
    {
        private readonly T* Element0;
        private readonly int Count;
        private int Index;

        public T Current => (uint)Index < Count ? Element0[Index] : default;

        internal ConstantArrayEnumerator(T* element0, int count)
        {
            Element0 = element0;
            Count = count;
            Index = -1;
        }

        public bool MoveNext()
        {
            int index = Index + 1;
            if (index < Count)
            {
                Index = index;
                return true;
            }

            return false;
        }
    }

    public unsafe ref struct ConstantArrayOfPointersEnumerator<T>
        where T : unmanaged
    {
        private readonly T** Element0;
        private readonly int Count;
        private int Index;

        public T* Current => (uint)Index < Count ? Element0[Index] : default;

        internal ConstantArrayOfPointersEnumerator(T** element0, int count)
        {
            Element0 = element0;
            Count = count;
            Index = -1;
        }

        public bool MoveNext()
        {
            int index = Index + 1;
            if (index < Count)
            {
                Index = index;
                return true;
            }

            return false;
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 5)]
    public unsafe partial struct ConstantArray_bool_5
    {
        [FieldOffset(0)] private bool Element0;

        private bool* Element0Pointer
        {
            get
            {
                fixed (bool* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref bool this[int index]
        {
            get
            {
                if ((uint)index < 5)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 5;

        public override string ToString()
            => $"{typeof(bool)}[5]";

        public bool[] ToArray()
        {
            bool[] result = new bool[5];

            for (int i = 0; i < 5; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<bool> AsSpan()
            => new Span<bool>(Element0Pointer, 5);

        public ConstantArrayEnumerator<bool> GetEnumerator()
            => new ConstantArrayEnumerator<bool>(Element0Pointer, 5);
    }

    [StructLayout(LayoutKind.Explicit, Size = 512)]
    public unsafe partial struct ConstantArray_bool_512
    {
        [FieldOffset(0)] private bool Element0;

        private bool* Element0Pointer
        {
            get
            {
                fixed (bool* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref bool this[int index]
        {
            get
            {
                if ((uint)index < 512)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 512;

        public override string ToString()
            => $"{typeof(bool)}[512]";

        public bool[] ToArray()
        {
            bool[] result = new bool[512];

            for (int i = 0; i < 512; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<bool> AsSpan()
            => new Span<bool>(Element0Pointer, 512);

        public ConstantArrayEnumerator<bool> GetEnumerator()
            => new ConstantArrayEnumerator<bool>(Element0Pointer, 512);
    }

    [StructLayout(LayoutKind.Explicit, Size = 1)]
    public unsafe partial struct ConstantArray_char_1
    {
        [FieldOffset(0)] private byte Element0;

        private byte* Element0Pointer
        {
            get
            {
                fixed (byte* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref byte this[int index]
        {
            get
            {
                if ((uint)index < 1)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 1;

        public override string ToString()
            => $"{typeof(byte)}[1]";

        public byte[] ToArray()
        {
            byte[] result = new byte[1];

            for (int i = 0; i < 1; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<byte> AsSpan()
            => new Span<byte>(Element0Pointer, 1);

        public ConstantArrayEnumerator<byte> GetEnumerator()
            => new ConstantArrayEnumerator<byte>(Element0Pointer, 1);
    }

    [StructLayout(LayoutKind.Explicit, Size = 256)]
    public unsafe partial struct ConstantArray_char_256
    {
        [FieldOffset(0)] private byte Element0;

        private byte* Element0Pointer
        {
            get
            {
                fixed (byte* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref byte this[int index]
        {
            get
            {
                if ((uint)index < 256)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 256;

        public override string ToString()
            => $"{typeof(byte)}[256]";

        public byte[] ToArray()
        {
            byte[] result = new byte[256];

            for (int i = 0; i < 256; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<byte> AsSpan()
            => new Span<byte>(Element0Pointer, 256);

        public ConstantArrayEnumerator<byte> GetEnumerator()
            => new ConstantArrayEnumerator<byte>(Element0Pointer, 256);
    }

    [StructLayout(LayoutKind.Explicit, Size = 3073)]
    public unsafe partial struct ConstantArray_char_3073
    {
        [FieldOffset(0)] private byte Element0;

        private byte* Element0Pointer
        {
            get
            {
                fixed (byte* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref byte this[int index]
        {
            get
            {
                if ((uint)index < 3073)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 3073;

        public override string ToString()
            => $"{typeof(byte)}[3073]";

        public byte[] ToArray()
        {
            byte[] result = new byte[3073];

            for (int i = 0; i < 3073; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<byte> AsSpan()
            => new Span<byte>(Element0Pointer, 3073);

        public ConstantArrayEnumerator<byte> GetEnumerator()
            => new ConstantArrayEnumerator<byte>(Element0Pointer, 3073);
    }

    [StructLayout(LayoutKind.Explicit, Size = 33)]
    public unsafe partial struct ConstantArray_char_33
    {
        [FieldOffset(0)] private byte Element0;

        private byte* Element0Pointer
        {
            get
            {
                fixed (byte* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref byte this[int index]
        {
            get
            {
                if ((uint)index < 33)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 33;

        public override string ToString()
            => $"{typeof(byte)}[33]";

        public byte[] ToArray()
        {
            byte[] result = new byte[33];

            for (int i = 0; i < 33; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<byte> AsSpan()
            => new Span<byte>(Element0Pointer, 33);

        public ConstantArrayEnumerator<byte> GetEnumerator()
            => new ConstantArrayEnumerator<byte>(Element0Pointer, 33);
    }

    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public unsafe partial struct ConstantArray_char_40
    {
        [FieldOffset(0)] private byte Element0;

        private byte* Element0Pointer
        {
            get
            {
                fixed (byte* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref byte this[int index]
        {
            get
            {
                if ((uint)index < 40)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 40;

        public override string ToString()
            => $"{typeof(byte)}[40]";

        public byte[] ToArray()
        {
            byte[] result = new byte[40];

            for (int i = 0; i < 40; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<byte> AsSpan()
            => new Span<byte>(Element0Pointer, 40);

        public ConstantArrayEnumerator<byte> GetEnumerator()
            => new ConstantArrayEnumerator<byte>(Element0Pointer, 40);
    }

    [StructLayout(LayoutKind.Explicit, Size = 5)]
    public unsafe partial struct ConstantArray_char_5
    {
        [FieldOffset(0)] private byte Element0;

        private byte* Element0Pointer
        {
            get
            {
                fixed (byte* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref byte this[int index]
        {
            get
            {
                if ((uint)index < 5)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 5;

        public override string ToString()
            => $"{typeof(byte)}[5]";

        public byte[] ToArray()
        {
            byte[] result = new byte[5];

            for (int i = 0; i < 5; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<byte> AsSpan()
            => new Span<byte>(Element0Pointer, 5);

        public ConstantArrayEnumerator<byte> GetEnumerator()
            => new ConstantArrayEnumerator<byte>(Element0Pointer, 5);
    }

    [StructLayout(LayoutKind.Explicit, Size = 58)]
    public unsafe partial struct ConstantArray_char_58
    {
        [FieldOffset(0)] private byte Element0;

        private byte* Element0Pointer
        {
            get
            {
                fixed (byte* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref byte this[int index]
        {
            get
            {
                if ((uint)index < 58)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 58;

        public override string ToString()
            => $"{typeof(byte)}[58]";

        public byte[] ToArray()
        {
            byte[] result = new byte[58];

            for (int i = 0; i < 58; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<byte> AsSpan()
            => new Span<byte>(Element0Pointer, 58);

        public ConstantArrayEnumerator<byte> GetEnumerator()
            => new ConstantArrayEnumerator<byte>(Element0Pointer, 58);
    }

    [StructLayout(LayoutKind.Explicit, Size = 256)]
    public unsafe partial struct ConstantArray_const__UNICODE_0020__unsigned__UNICODE_0020__char_256
    {
        [FieldOffset(0)] private byte Element0;

        private byte* Element0Pointer
        {
            get
            {
                fixed (byte* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref byte this[int index]
        {
            get
            {
                if ((uint)index < 256)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 256;

        public override string ToString()
            => $"{typeof(byte)}[256]";

        public byte[] ToArray()
        {
            byte[] result = new byte[256];

            for (int i = 0; i < 256; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<byte> AsSpan()
            => new Span<byte>(Element0Pointer, 256);

        public ConstantArrayEnumerator<byte> GetEnumerator()
            => new ConstantArrayEnumerator<byte>(Element0Pointer, 256);
    }

    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public unsafe partial struct ConstantArray_double_5
    {
        [FieldOffset(0)] private double Element0;

        private double* Element0Pointer
        {
            get
            {
                fixed (double* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref double this[int index]
        {
            get
            {
                if ((uint)index < 5)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 5;

        public override string ToString()
            => $"{typeof(double)}[5]";

        public double[] ToArray()
        {
            double[] result = new double[5];

            for (int i = 0; i < 5; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<double> AsSpan()
            => new Span<double>(Element0Pointer, 5);

        public ConstantArrayEnumerator<double> GetEnumerator()
            => new ConstantArrayEnumerator<double>(Element0Pointer, 5);
    }

    [StructLayout(LayoutKind.Explicit, Size = 480)]
    public unsafe partial struct ConstantArray_float_120
    {
        [FieldOffset(0)] private float Element0;

        private float* Element0Pointer
        {
            get
            {
                fixed (float* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref float this[int index]
        {
            get
            {
                if ((uint)index < 120)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 120;

        public override string ToString()
            => $"{typeof(float)}[120]";

        public float[] ToArray()
        {
            float[] result = new float[120];

            for (int i = 0; i < 120; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<float> AsSpan()
            => new Span<float>(Element0Pointer, 120);

        public ConstantArrayEnumerator<float> GetEnumerator()
            => new ConstantArrayEnumerator<float>(Element0Pointer, 120);
    }

    [StructLayout(LayoutKind.Explicit, Size = 80)]
    public unsafe partial struct ConstantArray_float_20
    {
        [FieldOffset(0)] private float Element0;

        private float* Element0Pointer
        {
            get
            {
                fixed (float* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref float this[int index]
        {
            get
            {
                if ((uint)index < 20)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 20;

        public override string ToString()
            => $"{typeof(float)}[20]";

        public float[] ToArray()
        {
            float[] result = new float[20];

            for (int i = 0; i < 20; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<float> AsSpan()
            => new Span<float>(Element0Pointer, 20);

        public ConstantArrayEnumerator<float> GetEnumerator()
            => new ConstantArrayEnumerator<float>(Element0Pointer, 20);
    }

    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public unsafe partial struct ConstantArray_float_5
    {
        [FieldOffset(0)] private float Element0;

        private float* Element0Pointer
        {
            get
            {
                fixed (float* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref float this[int index]
        {
            get
            {
                if ((uint)index < 5)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 5;

        public override string ToString()
            => $"{typeof(float)}[5]";

        public float[] ToArray()
        {
            float[] result = new float[5];

            for (int i = 0; i < 5; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<float> AsSpan()
            => new Span<float>(Element0Pointer, 5);

        public ConstantArrayEnumerator<float> GetEnumerator()
            => new ConstantArrayEnumerator<float>(Element0Pointer, 5);
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public unsafe partial struct ConstantArray_ImDrawList__UNICODE_0020____UNICODE_002A___2
    {
        [FieldOffset(0)] private ImDrawList* Element0;

        private ImDrawList** Element0Pointer
        {
            get
            {
                fixed (ImDrawList** pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref ImDrawList* this[int index]
        {
            get
            {
                if ((uint)index < 2)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 2;

        public override string ToString()
            => $"{typeof(ImDrawList*)}[2]";

        public ImDrawList*[] ToArray()
        {
            ImDrawList*[] result = new ImDrawList*[2];

            for (int i = 0; i < 2; i++)
            { result[i] = this[i]; }

            return result;
        }

        public ConstantArrayOfPointersEnumerator<ImDrawList> GetEnumerator()
            => new ConstantArrayOfPointersEnumerator<ImDrawList>(Element0Pointer, 2);
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public unsafe partial struct ConstantArray_ImGuiDockNode__UNICODE_0020____UNICODE_002A___2
    {
        [FieldOffset(0)] private ImGuiDockNode* Element0;

        private ImGuiDockNode** Element0Pointer
        {
            get
            {
                fixed (ImGuiDockNode** pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref ImGuiDockNode* this[int index]
        {
            get
            {
                if ((uint)index < 2)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 2;

        public override string ToString()
            => $"{typeof(ImGuiDockNode*)}[2]";

        public ImGuiDockNode*[] ToArray()
        {
            ImGuiDockNode*[] result = new ImGuiDockNode*[2];

            for (int i = 0; i < 2; i++)
            { result[i] = this[i]; }

            return result;
        }

        public ConstantArrayOfPointersEnumerator<ImGuiDockNode> GetEnumerator()
            => new ConstantArrayOfPointersEnumerator<ImGuiDockNode>(Element0Pointer, 2);
    }

    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public unsafe partial struct ConstantArray_ImGuiID_2
    {
        [FieldOffset(0)] private uint Element0;

        private uint* Element0Pointer
        {
            get
            {
                fixed (uint* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref uint this[int index]
        {
            get
            {
                if ((uint)index < 2)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 2;

        public override string ToString()
            => $"{typeof(uint)}[2]";

        public uint[] ToArray()
        {
            uint[] result = new uint[2];

            for (int i = 0; i < 2; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<uint> AsSpan()
            => new Span<uint>(Element0Pointer, 2);

        public ConstantArrayEnumerator<uint> GetEnumerator()
            => new ConstantArrayEnumerator<uint>(Element0Pointer, 2);
    }

    [StructLayout(LayoutKind.Explicit, Size = 10320)]
    public unsafe partial struct ConstantArray_ImGuiKeyData_645
    {
        [FieldOffset(0)] private ImGuiKeyData Element0;

        private ImGuiKeyData* Element0Pointer
        {
            get
            {
                fixed (ImGuiKeyData* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref ImGuiKeyData this[int index]
        {
            get
            {
                if ((uint)index < 645)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 645;

        public override string ToString()
            => $"{typeof(ImGuiKeyData)}[645]";

        public ImGuiKeyData[] ToArray()
        {
            ImGuiKeyData[] result = new ImGuiKeyData[645];

            for (int i = 0; i < 645; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<ImGuiKeyData> AsSpan()
            => new Span<ImGuiKeyData>(Element0Pointer, 645);

        public ConstantArrayEnumerator<ImGuiKeyData> GetEnumerator()
            => new ConstantArrayEnumerator<ImGuiKeyData>(Element0Pointer, 645);
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public unsafe partial struct ConstantArray_ImRect_2
    {
        [FieldOffset(0)] private ImRect Element0;

        private ImRect* Element0Pointer
        {
            get
            {
                fixed (ImRect* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref ImRect this[int index]
        {
            get
            {
                if ((uint)index < 2)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 2;

        public override string ToString()
            => $"{typeof(ImRect)}[2]";

        public ImRect[] ToArray()
        {
            ImRect[] result = new ImRect[2];

            for (int i = 0; i < 2; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<ImRect> AsSpan()
            => new Span<ImRect>(Element0Pointer, 2);

        public ConstantArrayEnumerator<ImRect> GetEnumerator()
            => new ConstantArrayEnumerator<ImRect>(Element0Pointer, 2);
    }

    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public unsafe partial struct ConstantArray_ImU16_4
    {
        [FieldOffset(0)] private ushort Element0;

        private ushort* Element0Pointer
        {
            get
            {
                fixed (ushort* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref ushort this[int index]
        {
            get
            {
                if ((uint)index < 4)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 4;

        public override string ToString()
            => $"{typeof(ushort)}[4]";

        public ushort[] ToArray()
        {
            ushort[] result = new ushort[4];

            for (int i = 0; i < 4; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<ushort> AsSpan()
            => new Span<ushort>(Element0Pointer, 4);

        public ConstantArrayEnumerator<ushort> GetEnumerator()
            => new ConstantArrayEnumerator<ushort>(Element0Pointer, 4);
    }

    [StructLayout(LayoutKind.Explicit, Size = 10)]
    public unsafe partial struct ConstantArray_ImU16_5
    {
        [FieldOffset(0)] private ushort Element0;

        private ushort* Element0Pointer
        {
            get
            {
                fixed (ushort* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref ushort this[int index]
        {
            get
            {
                if ((uint)index < 5)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 5;

        public override string ToString()
            => $"{typeof(ushort)}[5]";

        public ushort[] ToArray()
        {
            ushort[] result = new ushort[5];

            for (int i = 0; i < 5; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<ushort> AsSpan()
            => new Span<ushort>(Element0Pointer, 5);

        public ConstantArrayEnumerator<ushort> GetEnumerator()
            => new ConstantArrayEnumerator<ushort>(Element0Pointer, 5);
    }

    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public unsafe partial struct ConstantArray_ImU32_2
    {
        [FieldOffset(0)] private uint Element0;

        private uint* Element0Pointer
        {
            get
            {
                fixed (uint* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref uint this[int index]
        {
            get
            {
                if ((uint)index < 2)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 2;

        public override string ToString()
            => $"{typeof(uint)}[2]";

        public uint[] ToArray()
        {
            uint[] result = new uint[2];

            for (int i = 0; i < 2; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<uint> AsSpan()
            => new Span<uint>(Element0Pointer, 2);

        public ConstantArrayEnumerator<uint> GetEnumerator()
            => new ConstantArrayEnumerator<uint>(Element0Pointer, 2);
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public unsafe partial struct ConstantArray_ImU32_6
    {
        [FieldOffset(0)] private uint Element0;

        private uint* Element0Pointer
        {
            get
            {
                fixed (uint* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref uint this[int index]
        {
            get
            {
                if ((uint)index < 6)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 6;

        public override string ToString()
            => $"{typeof(uint)}[6]";

        public uint[] ToArray()
        {
            uint[] result = new uint[6];

            for (int i = 0; i < 6; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<uint> AsSpan()
            => new Span<uint>(Element0Pointer, 6);

        public ConstantArrayEnumerator<uint> GetEnumerator()
            => new ConstantArrayEnumerator<uint>(Element0Pointer, 6);
    }

    [StructLayout(LayoutKind.Explicit, Size = 2)]
    public unsafe partial struct ConstantArray_ImU8_2
    {
        [FieldOffset(0)] private byte Element0;

        private byte* Element0Pointer
        {
            get
            {
                fixed (byte* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref byte this[int index]
        {
            get
            {
                if ((uint)index < 2)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 2;

        public override string ToString()
            => $"{typeof(byte)}[2]";

        public byte[] ToArray()
        {
            byte[] result = new byte[2];

            for (int i = 0; i < 2; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<byte> AsSpan()
            => new Span<byte>(Element0Pointer, 2);

        public ConstantArrayEnumerator<byte> GetEnumerator()
            => new ConstantArrayEnumerator<byte>(Element0Pointer, 2);
    }

    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public unsafe partial struct ConstantArray_ImU8_64
    {
        [FieldOffset(0)] private byte Element0;

        private byte* Element0Pointer
        {
            get
            {
                fixed (byte* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref byte this[int index]
        {
            get
            {
                if ((uint)index < 64)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 64;

        public override string ToString()
            => $"{typeof(byte)}[64]";

        public byte[] ToArray()
        {
            byte[] result = new byte[64];

            for (int i = 0; i < 64; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<byte> AsSpan()
            => new Span<byte>(Element0Pointer, 64);

        public ConstantArrayEnumerator<byte> GetEnumerator()
            => new ConstantArrayEnumerator<byte>(Element0Pointer, 64);
    }

    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public unsafe partial struct ConstantArray_ImU8_8
    {
        [FieldOffset(0)] private byte Element0;

        private byte* Element0Pointer
        {
            get
            {
                fixed (byte* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref byte this[int index]
        {
            get
            {
                if ((uint)index < 8)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 8;

        public override string ToString()
            => $"{typeof(byte)}[8]";

        public byte[] ToArray()
        {
            byte[] result = new byte[8];

            for (int i = 0; i < 8; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<byte> AsSpan()
            => new Span<byte>(Element0Pointer, 8);

        public ConstantArrayEnumerator<byte> GetEnumerator()
            => new ConstantArrayEnumerator<byte>(Element0Pointer, 8);
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public unsafe partial struct ConstantArray_ImVec2_2
    {
        [FieldOffset(0)] private Vector2 Element0;

        private Vector2* Element0Pointer
        {
            get
            {
                fixed (Vector2* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref Vector2 this[int index]
        {
            get
            {
                if ((uint)index < 2)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 2;

        public override string ToString()
            => $"{typeof(Vector2)}[2]";

        public Vector2[] ToArray()
        {
            Vector2[] result = new Vector2[2];

            for (int i = 0; i < 2; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<Vector2> AsSpan()
            => new Span<Vector2>(Element0Pointer, 2);

        public ConstantArrayEnumerator<Vector2> GetEnumerator()
            => new ConstantArrayEnumerator<Vector2>(Element0Pointer, 2);
    }

    [StructLayout(LayoutKind.Explicit, Size = 384)]
    public unsafe partial struct ConstantArray_ImVec2_48
    {
        [FieldOffset(0)] private Vector2 Element0;

        private Vector2* Element0Pointer
        {
            get
            {
                fixed (Vector2* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref Vector2 this[int index]
        {
            get
            {
                if ((uint)index < 48)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 48;

        public override string ToString()
            => $"{typeof(Vector2)}[48]";

        public Vector2[] ToArray()
        {
            Vector2[] result = new Vector2[48];

            for (int i = 0; i < 48; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<Vector2> AsSpan()
            => new Span<Vector2>(Element0Pointer, 48);

        public ConstantArrayEnumerator<Vector2> GetEnumerator()
            => new ConstantArrayEnumerator<Vector2>(Element0Pointer, 48);
    }

    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public unsafe partial struct ConstantArray_ImVec2_5
    {
        [FieldOffset(0)] private Vector2 Element0;

        private Vector2* Element0Pointer
        {
            get
            {
                fixed (Vector2* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref Vector2 this[int index]
        {
            get
            {
                if ((uint)index < 5)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 5;

        public override string ToString()
            => $"{typeof(Vector2)}[5]";

        public Vector2[] ToArray()
        {
            Vector2[] result = new Vector2[5];

            for (int i = 0; i < 5; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<Vector2> AsSpan()
            => new Span<Vector2>(Element0Pointer, 5);

        public ConstantArrayEnumerator<Vector2> GetEnumerator()
            => new ConstantArrayEnumerator<Vector2>(Element0Pointer, 5);
    }

    [StructLayout(LayoutKind.Explicit, Size = 880)]
    public unsafe partial struct ConstantArray_ImVec4_55
    {
        [FieldOffset(0)] private Vector4 Element0;

        private Vector4* Element0Pointer
        {
            get
            {
                fixed (Vector4* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref Vector4 this[int index]
        {
            get
            {
                if ((uint)index < 55)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 55;

        public override string ToString()
            => $"{typeof(Vector4)}[55]";

        public Vector4[] ToArray()
        {
            Vector4[] result = new Vector4[55];

            for (int i = 0; i < 55; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<Vector4> AsSpan()
            => new Span<Vector4>(Element0Pointer, 55);

        public ConstantArrayEnumerator<Vector4> GetEnumerator()
            => new ConstantArrayEnumerator<Vector4>(Element0Pointer, 55);
    }

    [StructLayout(LayoutKind.Explicit, Size = 1024)]
    public unsafe partial struct ConstantArray_ImVec4_64
    {
        [FieldOffset(0)] private Vector4 Element0;

        private Vector4* Element0Pointer
        {
            get
            {
                fixed (Vector4* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref Vector4 this[int index]
        {
            get
            {
                if ((uint)index < 64)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 64;

        public override string ToString()
            => $"{typeof(Vector4)}[64]";

        public Vector4[] ToArray()
        {
            Vector4[] result = new Vector4[64];

            for (int i = 0; i < 64; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<Vector4> AsSpan()
            => new Span<Vector4>(Element0Pointer, 64);

        public ConstantArrayEnumerator<Vector4> GetEnumerator()
            => new ConstantArrayEnumerator<Vector4>(Element0Pointer, 64);
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public unsafe partial struct ConstantArray_ImVector__UNICODE_003C__ImDrawList__UNICODE_0020____UNICODE_002A____UNICODE_003E___2
    {
        [FieldOffset(0)] private ImVector<Pointer<ImDrawList>> Element0;

        private ImVector<Pointer<ImDrawList>>* Element0Pointer
        {
            get
            {
                fixed (ImVector<Pointer<ImDrawList>>* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref ImVector<Pointer<ImDrawList>> this[int index]
        {
            get
            {
                if ((uint)index < 2)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 2;

        public override string ToString()
            => $"{typeof(ImVector<Pointer<ImDrawList>>)}[2]";

        public ImVector<Pointer<ImDrawList>>[] ToArray()
        {
            ImVector<Pointer<ImDrawList>>[] result = new ImVector<Pointer<ImDrawList>>[2];

            for (int i = 0; i < 2; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<ImVector<Pointer<ImDrawList>>> AsSpan()
            => new Span<ImVector<Pointer<ImDrawList>>>(Element0Pointer, 2);

        public ConstantArrayEnumerator<ImVector<Pointer<ImDrawList>>> GetEnumerator()
            => new ConstantArrayEnumerator<ImVector<Pointer<ImDrawList>>>(Element0Pointer, 2);
    }

    [StructLayout(LayoutKind.Explicit, Size = 2580)]
    public unsafe partial struct ConstantArray_int_645
    {
        [FieldOffset(0)] private int Element0;

        private int* Element0Pointer
        {
            get
            {
                fixed (int* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref int this[int index]
        {
            get
            {
                if ((uint)index < 645)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 645;

        public override string ToString()
            => $"{typeof(int)}[645]";

        public int[] ToArray()
        {
            int[] result = new int[645];

            for (int i = 0; i < 645; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<int> AsSpan()
            => new Span<int>(Element0Pointer, 645);

        public ConstantArrayEnumerator<int> GetEnumerator()
            => new ConstantArrayEnumerator<int>(Element0Pointer, 645);
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public unsafe partial struct ConstantArray_unsigned__UNICODE_0020__char_16
    {
        [FieldOffset(0)] private byte Element0;

        private byte* Element0Pointer
        {
            get
            {
                fixed (byte* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref byte this[int index]
        {
            get
            {
                if ((uint)index < 16)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 16;

        public override string ToString()
            => $"{typeof(byte)}[16]";

        public byte[] ToArray()
        {
            byte[] result = new byte[16];

            for (int i = 0; i < 16; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<byte> AsSpan()
            => new Span<byte>(Element0Pointer, 16);

        public ConstantArrayEnumerator<byte> GetEnumerator()
            => new ConstantArrayEnumerator<byte>(Element0Pointer, 16);
    }

    [StructLayout(LayoutKind.Explicit, Size = 256)]
    public unsafe partial struct ConstantArray_unsigned__UNICODE_0020__char_256
    {
        [FieldOffset(0)] private byte Element0;

        private byte* Element0Pointer
        {
            get
            {
                fixed (byte* pElement0 = &Element0)
                { return pElement0; }
            }
        }

        public ref byte this[int index]
        {
            get
            {
                if ((uint)index < 256)
                { return ref Element0Pointer[index]; }
                else
                { throw new IndexOutOfRangeException(); }
            }
        }

        public int Length => 256;

        public override string ToString()
            => $"{typeof(byte)}[256]";

        public byte[] ToArray()
        {
            byte[] result = new byte[256];

            for (int i = 0; i < 256; i++)
            { result[i] = this[i]; }

            return result;
        }

        public Span<byte> AsSpan()
            => new Span<byte>(Element0Pointer, 256);

        public ConstantArrayEnumerator<byte> GetEnumerator()
            => new ConstantArrayEnumerator<byte>(Element0Pointer, 256);
    }
}
