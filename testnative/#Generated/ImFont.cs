// <auto-generated>
// This file was automatically generated by Biohazrd and should not be modified by hand!
// </auto-generated>
#nullable enable
using Mochi.DearImGui.Infrastructure;
using System;
using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Mochi.DearImGui
{
    [StructLayout(LayoutKind.Explicit, Size = 112, CharSet = CharSet.Unicode)]
    public unsafe partial struct ImFont
    {
        [FieldOffset(0)] public ImVector<float> IndexAdvanceX;

        [FieldOffset(16)] public float FallbackAdvanceX;

        [FieldOffset(20)] public float FontSize;

        [FieldOffset(24)] public ImVector<ushort> IndexLookup;

        [FieldOffset(40)] public ImVector<ImFontGlyph> Glyphs;

        [FieldOffset(56)] public ImFontGlyph* FallbackGlyph;

        [FieldOffset(64)] public ImFontAtlas* ContainerAtlas;

        [FieldOffset(72)] public ImFontConfig* ConfigData;

        [FieldOffset(80)] public short ConfigDataCount;

        [FieldOffset(82)] public char FallbackChar;

        [FieldOffset(84)] public char EllipsisChar;

        [FieldOffset(86)] public char DotChar;

        [FieldOffset(88)] [MarshalAs(UnmanagedType.I1)] public bool DirtyLookupTables;

        [FieldOffset(92)] public float Scale;

        [FieldOffset(96)] public float Ascent;

        [FieldOffset(100)] public float Descent;

        [FieldOffset(104)] public int MetricsTotalSurface;

        [FieldOffset(108)] public ConstantArray_ImU8_2 Used4kPagesMap;

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "??0ImFont@@QEAA@XZ", ExactSpelling = true)]
        private static extern void Constructor_PInvoke(ImFont* @this);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ImFont()
        {
            fixed (ImFont* @this = &this)
            { Constructor_PInvoke(@this); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "??1ImFont@@QEAA@XZ", ExactSpelling = true)]
        private static extern void Destructor_PInvoke(ImFont* @this);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Destructor()
        {
            fixed (ImFont* @this = &this)
            { Destructor_PInvoke(@this); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z", ExactSpelling = true)]
        private static extern ImFontGlyph* FindGlyph_PInvoke(ImFont* @this, char c);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ImFontGlyph* FindGlyph(char c)
        {
            fixed (ImFont* @this = &this)
            { return FindGlyph_PInvoke(@this, c); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z", ExactSpelling = true)]
        private static extern ImFontGlyph* FindGlyphNoFallback_PInvoke(ImFont* @this, char c);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ImFontGlyph* FindGlyphNoFallback(char c)
        {
            fixed (ImFont* @this = &this)
            { return FindGlyphNoFallback_PInvoke(@this, c); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetCharAdvance@ImFont@@QEBAMG@Z", ExactSpelling = true)]
        private static extern float GetCharAdvance_PInvoke(ImFont* @this, char c);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float GetCharAdvance(char c)
        {
            fixed (ImFont* @this = &this)
            { return GetCharAdvance_PInvoke(@this, c); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsLoaded@ImFont@@QEBA_NXZ", ExactSpelling = true)]
        private static extern byte IsLoaded_PInvoke(ImFont* @this);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsLoaded()
        {
            byte __result;

            fixed (ImFont* @this = &this)
            { __result = IsLoaded_PInvoke(@this); }

            return Unsafe.As<byte, bool>(ref __result);
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GetDebugName@ImFont@@QEBAPEBDXZ", ExactSpelling = true)]
        private static extern byte* GetDebugName_PInvoke(ImFont* @this);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public byte* GetDebugName()
        {
            fixed (ImFont* @this = &this)
            { return GetDebugName_PInvoke(@this); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z", ExactSpelling = true)]
        private static extern Vector2* CalcTextSizeA_PInvoke(ImFont* @this, Vector2* __returnBuffer, float size, float max_width, float wrap_width, byte* text_begin, byte* text_end, byte** remaining);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector2 CalcTextSizeA(float size, float max_width, float wrap_width, byte* text_begin, byte* text_end = null, byte** remaining = null)
        {
            Vector2 __returnBuffer;

            fixed (ImFont* @this = &this)
            { CalcTextSizeA_PInvoke(@this, &__returnBuffer, size, max_width, wrap_width, text_begin, text_end, remaining); }

            return __returnBuffer;
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector2 CalcTextSizeA(float size, float max_width, float wrap_width, DearImGuiInterpolatedStringHandler text_begin, byte** remaining = null)
        {
            Vector2 __returnBuffer;
            ReadOnlySpan<byte> __text_begin = text_begin.NullTerminateAndGetString();

            fixed (ImFont* @this = &this)
            fixed (byte* __text_beginP = __text_begin)
            { CalcTextSizeA_PInvoke(@this, &__returnBuffer, size, max_width, wrap_width, __text_beginP, __text_beginP + __text_begin.Length, remaining); }

            text_begin.Dispose();
            return __returnBuffer;
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z", ExactSpelling = true)]
        private static extern byte* CalcWordWrapPositionA_PInvoke(ImFont* @this, float scale, byte* text, byte* text_end, float wrap_width);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public byte* CalcWordWrapPositionA(float scale, byte* text, byte* text_end, float wrap_width)
        {
            fixed (ImFont* @this = &this)
            { return CalcWordWrapPositionA_PInvoke(@this, scale, text, text_end, wrap_width); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IG@Z", ExactSpelling = true)]
        private static extern void RenderChar_PInvoke(ImFont* @this, ImDrawList* draw_list, float size, Vector2 pos, uint col, char c);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RenderChar(ImDrawList* draw_list, float size, Vector2 pos, uint col, char c)
        {
            fixed (ImFont* @this = &this)
            { RenderChar_PInvoke(@this, draw_list, size, pos, col, c); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z", ExactSpelling = true)]
        private static extern void RenderText_PInvoke(ImFont* @this, ImDrawList* draw_list, float size, Vector2 pos, uint col, Vector4* clip_rect, byte* text_begin, byte* text_end, float wrap_width, byte cpu_fine_clip);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RenderText(ImDrawList* draw_list, float size, Vector2 pos, uint col, in Vector4 clip_rect, byte* text_begin, byte* text_end, float wrap_width = 0f, bool cpu_fine_clip = false)
        {
            fixed (ImFont* @this = &this)
            fixed (Vector4* __clip_rectP = &clip_rect)
            { RenderText_PInvoke(@this, draw_list, size, pos, col, __clip_rectP, text_begin, text_end, wrap_width, Unsafe.As<bool, byte>(ref cpu_fine_clip)); }
        }

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RenderText(ImDrawList* draw_list, float size, Vector2 pos, uint col, in Vector4 clip_rect, DearImGuiInterpolatedStringHandler text_begin, float wrap_width = 0f, bool cpu_fine_clip = false)
        {
            ReadOnlySpan<byte> __text_begin = text_begin.NullTerminateAndGetString();

            fixed (ImFont* @this = &this)
            fixed (Vector4* __clip_rectP = &clip_rect)
            fixed (byte* __text_beginP = __text_begin)
            { RenderText_PInvoke(@this, draw_list, size, pos, col, __clip_rectP, __text_beginP, __text_beginP + __text_begin.Length, wrap_width, Unsafe.As<bool, byte>(ref cpu_fine_clip)); }

            text_begin.Dispose();
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?BuildLookupTable@ImFont@@QEAAXXZ", ExactSpelling = true)]
        private static extern void BuildLookupTable_PInvoke(ImFont* @this);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BuildLookupTable()
        {
            fixed (ImFont* @this = &this)
            { BuildLookupTable_PInvoke(@this); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?ClearOutputData@ImFont@@QEAAXXZ", ExactSpelling = true)]
        private static extern void ClearOutputData_PInvoke(ImFont* @this);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearOutputData()
        {
            fixed (ImFont* @this = &this)
            { ClearOutputData_PInvoke(@this); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?GrowIndex@ImFont@@QEAAXH@Z", ExactSpelling = true)]
        private static extern void GrowIndex_PInvoke(ImFont* @this, int new_size);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GrowIndex(int new_size)
        {
            fixed (ImFont* @this = &this)
            { GrowIndex_PInvoke(@this, new_size); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z", ExactSpelling = true)]
        private static extern void AddGlyph_PInvoke(ImFont* @this, ImFontConfig* src_cfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddGlyph(ImFontConfig* src_cfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)
        {
            fixed (ImFont* @this = &this)
            { AddGlyph_PInvoke(@this, src_cfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advance_x); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?AddRemapChar@ImFont@@QEAAXGG_N@Z", ExactSpelling = true)]
        private static extern void AddRemapChar_PInvoke(ImFont* @this, char dst, char src, byte overwrite_dst);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddRemapChar(char dst, char src, bool overwrite_dst = true)
        {
            fixed (ImFont* @this = &this)
            { AddRemapChar_PInvoke(@this, dst, src, Unsafe.As<bool, byte>(ref overwrite_dst)); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?SetGlyphVisible@ImFont@@QEAAXG_N@Z", ExactSpelling = true)]
        private static extern void SetGlyphVisible_PInvoke(ImFont* @this, char c, byte visible);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetGlyphVisible(char c, bool visible)
        {
            fixed (ImFont* @this = &this)
            { SetGlyphVisible_PInvoke(@this, c, Unsafe.As<bool, byte>(ref visible)); }
        }

        [DllImport("Mochi.DearImGui.Native", CallingConvention = CallingConvention.Cdecl, EntryPoint = "?IsGlyphRangeUnused@ImFont@@QEAA_NII@Z", ExactSpelling = true)]
        private static extern byte IsGlyphRangeUnused_PInvoke(ImFont* @this, uint c_begin, uint c_last);

        [DebuggerStepThrough, DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsGlyphRangeUnused(uint c_begin, uint c_last)
        {
            byte __result;

            fixed (ImFont* @this = &this)
            { __result = IsGlyphRangeUnused_PInvoke(@this, c_begin, c_last); }

            return Unsafe.As<byte, bool>(ref __result);
        }
    }
}
